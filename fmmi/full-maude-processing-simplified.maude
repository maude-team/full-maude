***(

    This file is part of the Maude 3 interpreter.

    Copyright 2017-2022 SRI International, Menlo Park, CA 94025, USA.

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

)

----                                                   To be run on Maude 3.2.1
----                                                    author: Francisco Duran

set show loop stats off .
set show loop timing off .
----set show advisories off .

fmod FM-BANNER is
  pr STRING .
  op banner : -> String .
  eq banner = "Full Maude MI Mar 24 2022" .
endfm

set include BOOL off .
set include TRUTH-VALUE on .
set show advisories off .

mod CONFIGURATION is
  sorts Attribute AttributeSet .
  subsort Attribute < AttributeSet .
  op none : -> AttributeSet  [ctor] .
  op _,_ : AttributeSet AttributeSet -> AttributeSet
    [ctor assoc comm id: none format (o !r nio o)] .

  sorts Oid Cid Object Msg Portal Configuration .
  subsort Object Msg Portal < Configuration .
  op <_:_|_> : Oid Cid AttributeSet -> Object
    [ctor object format (ni!r o !r o !r++ oni !r-- o)] .
  op none : -> Configuration [ctor] .
  op __ : Configuration Configuration -> Configuration
    [ctor config assoc comm id: none] .
  op <> : -> Portal [ctor] .
endm

mod CONFIGURATION+ is
  including CONFIGURATION .
  op <_:_|`> : Oid Cid -> Object [format (ni!r o !r o !r o o)] .
  op getClass : Object -> Cid .
  ---- eq < O:Oid : C:Cid | > = < O:Oid : C:Cid | none > .
  eq getClass(< O:Oid : C:Cid | A:AttributeSet >) = C:Cid .
endm

set show advisories on .
set include BOOL on .
set include TRUTH-VALUE off .

view Oid from TRIV to CONFIGURATION+ is
  sort Elt to Oid .
endv

view Module from TRIV to META-MODULE is
  sort Elt to Module .
endv

fmod FM-TERMSET is
  ----MI protecting FM-META-LEVEL-MNPA .
  ----MI protecting FM-SUBSTITUTION-HANDLING .
  pr META-TERM .

  sort TermSet .
  subsort Term < TermSet .
  op emptyTermSet : -> TermSet [ctor] .
  op _|_ : TermSet TermSet -> TermSet
    [ctor assoc comm id: emptyTermSet format (d n d d)] .
  eq X:Term | X:Term = X:Term .

  op _inTermSet_ : Term TermSet -> Bool .
  eq T:Term inTermSet (T:Term | TS:TermSet) = true .
  eq T:Term inTermSet TS:TermSet = false [owise] .

  op TermSet : TermList -> TermSet .
  eq TermSet(empty)
   = emptyTermSet .
  eq TermSet((T:Term,TL:TermList))
   = T:Term | TermSet(TL:TermList) .

endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------


*** The \texttt{GRAMMAR} module will be used in calls to the \texttt{metaParse}
*** function in order to get the input parsed in this signature. Note that
*** this module is not the data type in which we shall represent the inputs.
*** From the call to \texttt{metaParse} we shall get a term representing the
*** parse tree of the input. This term will then be transformed into terms of
*** other appropriate data types if necessary.

*** Future extensions to Full Maude will require extending the signature as
*** well. The addition of new commands, new module expressions, or additions
*** of any other kind will require adding new declarations to the present Full
*** Maude signature and defining the corresponding extensions to the data
*** types and functions to deal with the new cases introduced by the
*** extensions.

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

***
*** The Abstract Data Type \texttt{View}
***

*** In this section we present the data type \texttt{View} for views.
*** Basically, the data elements of sort \texttt{View} are composed by the
*** name of the view, the names of the source and target units, and a set of
*** maps representing the maps asserting how the given target unit is claimed
*** to satisfy the source theory (see Section~\ref{Views}).

*** Internally, renaming maps are considered to be a particular case of view
*** maps. The sort \texttt{ViewMap} is declared as a supersort of
*** \texttt{Map}. The only kind of maps in sort \texttt{ViewMap} not in sort
*** \texttt{Map} are maps of operators going to derived operators. We start
*** introducing the declarations for renaming maps and sTS of renaming maps
*** in Section~\ref{renaming-maps}, we then introduce view maps and sTS of
*** view maps in Section~\ref{view-maps}, and finally we introduce the sort
*** \texttt{View}, its constructor, and some operations on it in
*** Section~\ref{viewADT}.

***
*** View Maps
***

*** In addition to the maps of sort \texttt{Renaming},
*** in views there can also be maps from operators to derived
*** operators, that is, terms with variables (see Section~\ref{Views}). Maps
*** of this kind are given with the constructor \texttt{op_to`term_}, which, in
*** addition to the source and target terms, takes the set of variable
*** declarations for the variables used in the map. The source term must be of
*** the form $\texttt{F(X}_1\texttt{,}\ldots,\texttt{X}_n\texttt{)}$, where
*** \texttt{F} is an operator name declared with $n$ arguments of sorts in the
*** connected components of the variables $\texttt{X}_1\ldots\texttt{X}_n$,
*** respectively. We will see in Section~\ref{view-processing} how in the
*** initial processing of a view the variables declared in it are associated
*** to each of the maps in which they are used.


***
*** Views
***

*** The \texttt{View} sort is introduced in the following module
*** \texttt{VIEW}.  In addition to the constructor for views (\texttt{view}),
*** selector functions are added for each of the components of a
*** view (\texttt{name}, \texttt{source}, \texttt{target}, and
*** \texttt{mapSet}), and a constant \texttt{emptyView}, which is identified
*** in an equation with the empty view, is defined.

*** Although the declaration of the constructor for views includes an argument
*** for the list of parameters, parameterized views are not handled yet, so at
*** present this argument must be set to the \texttt{nil}.

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod EXT-RENAMING is
  pr META-MODULE .

  op op_to term_ : Term Term -> Renaming .
endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod VIEW is
  ex META-VIEW .
  pr FM-VIEW-EXPR .
  inc FM-FMAP .

  *** mappings
  op class_to_. : Sort Sort -> SortMapping .
  op attr_._to_. : Qid Sort Qid -> OpMapping .
  op msg_to_. : Qid Qid -> OpMapping .
  op msg_:_->_to_. : Qid TypeList Sort Qid -> OpMapping .

  op strat_to`expr_. : Term Term -> StratMapping . ---- PreMapping

  subsort ViewExpression < Header .

  op null : -> View [ctor] .
  op viewError : QidList -> [View] [ctor format (r o)] .

  eq VE{(nil).ParameterDeclList} = VE .

  vars A A' F F' Q Q' : Qid .
  var QIL : QidList .
  var VH : Header .
  var VE : ViewExpression .
  vars PDL PDL' : ParameterDeclList .
  vars ME ME' ME'' : ModuleExpression .
  vars SMS SMS' : SortMappingSet .
  vars OMS OMS' : OpMappingSet .
  vars TMS TMS' : StratMappingSet .
  vars S S' C : Sort .
  var  Ty : Type .
  var  TyL : TypeList .
  vars T T' : Term .
  var  CS : CallStrategy .
  var  Strat : Strategy .

  op maps2rens : SortMappingSet -> RenamingSet .
  op maps2rens : OpMappingSet -> RenamingSet .
  op maps2rens : StratMappingSet -> RenamingSet .

  eq maps2rens(sort S to S' . SMS) = sort S to S', maps2rens(SMS) .
  eq maps2rens(class S to S' . SMS) = class S to S', maps2rens(SMS) .
  eq maps2rens((none).SortMappingSet) = none .

  eq maps2rens(op F to F' . OMS) = op F to F' [none], maps2rens(OMS) .
  eq maps2rens(op F : TyL -> Ty to F' . OMS) = op F : TyL -> Ty to F' [none], maps2rens(OMS) .
  eq maps2rens(op T to term T' . OMS) = op T to term T', maps2rens(OMS) .
  eq maps2rens(msg F to F' . OMS) = msg F to F' [none], maps2rens(OMS) .
  eq maps2rens(msg F : TyL -> Ty to F' . OMS) = msg F : TyL -> Ty to F' [none], maps2rens(OMS) .
  eq maps2rens(attr A . C to A' . OMS) = attr A . C to A', maps2rens(OMS) .
  eq maps2rens((none).OpMappingSet) = none .

  eq maps2rens(strat F to F' . TMS) = strat F to F', maps2rens(TMS) .
  eq maps2rens(strat F : TyL @ Ty to F' . TMS) = strat F : TyL @ Ty to F', maps2rens(TMS) .
  eq maps2rens(strat CS to expr Strat . TMS) = strat CS to expr Strat, maps2rens(TMS) .
  eq maps2rens((none).StratMappingSet) = none .

*** projection functions
----  op getName : View -> Qid .
----  eq getName(view VE from ME to ME' is SMS OMS TMS endv) = VE [owise] .
----  eq getName(view VE{PDL} from ME to ME' is SMS OMS TMS endv) = VE .

  op getPars : [View] -> ParameterDeclList .
  eq getPars(view VE from ME to ME' is SMS OMS TMS endv) = nil [owise] .
  eq getPars(view VE{PDL} from ME to ME' is SMS OMS TMS endv) = PDL .
  eq getPars(viewError(QIL)) = nil .

  eq getFrom(view VH from ME to ME' is SMS OMS TMS endv) = ME .
  eq getTo(view VH from ME to ME' is SMS OMS TMS endv) = ME' .
  eq getSortMappings(view VH from ME to ME' is SMS OMS TMS endv) = SMS .
  eq getOpMappings(view VH from ME to ME' is SMS OMS TMS endv) = OMS .

*** injection functions
  op setName : View Qid -> View .
  eq setName(view Q from ME to ME' is SMS OMS TMS endv, Q')
    = view Q' from ME to ME' is SMS OMS TMS endv .
  eq setName(view Q{PDL} from ME to ME' is SMS OMS TMS endv, VH) = view VH{PDL} from ME to ME' is SMS OMS TMS endv .
  eq setName(viewError(QIL), VE) = viewError(QIL) .

  op setPars : [View] ParameterDeclList -> [View] .
  eq setPars(view VH from ME to ME' is SMS OMS TMS endv, PDL)
    = view VH{PDL} from ME to ME' is SMS OMS TMS endv [owise] .
  eq setPars(view VH{PDL} from ME to ME' is SMS OMS TMS endv, PDL') = view VH{PDL'} from ME to ME' is SMS OMS TMS endv .
  eq setPars(viewError(QIL), PDL) = viewError(QIL) .

  op setFrom : View ModuleExpression -> View .
  eq setFrom(view VH from ME to ME' is SMS OMS TMS endv, ME'')
    = view VH from ME'' to ME' is SMS OMS TMS endv .
  eq setFrom(viewError(QIL), ME) = viewError(QIL) .

  op setTo : View ModuleExpression -> View .
  eq setTo(view VH from ME to ME' is SMS OMS TMS endv, ME'')
    = view VH from ME to ME'' is SMS OMS TMS endv .
  eq setTo(viewError(QIL), ME) = viewError(QIL) .

  op setSortMappings : View SortMappingSet -> View .
  eq setSortMappings(view VH from ME to ME' is SMS OMS TMS endv, SMS')
    = view VH from ME to ME' is SMS' OMS TMS endv .
  eq setSortMappings(viewError(QIL), SMS') = viewError(QIL) .

  op setOpMappings : View OpMappingSet -> View .
  eq setOpMappings(view VH from ME to ME' is SMS OMS TMS endv, OMS')
    = view VH from ME to ME' is SMS OMS' TMS endv .
  eq setOpMappings(viewError(QIL), OMS') = viewError(QIL) .

  op emptyView : Qid ModuleExpression ModuleExpression -> View .
  eq emptyView(VH, ME, ME') = view VH from ME to ME' is none none none endv .
endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

***
*** The Abstract Data Type \texttt{Database}
***

*** In this section we present the data type \texttt{Database}, which will be
*** used to store information about the units and views in the system. Before
*** discussing this data type in Section~\ref{databaseADT}, we present the
*** predefined units added in Full Maude to those already available in Core
*** Maude.

***
*** Non-Built-In Predefined Modules
***

*** As we shall see in the following section, except for the
*** \texttt{LOOP-MODE} module, all the predefined modules that are available
*** in Core Maude are also available in Full Maude. In addition to these Core
*** Maude predefined modules, in Full Maude there are some additional
*** predefined units. In the present system, the only units with which the
*** database is initialized are the functional theory \texttt{TRIV}, the
*** module \texttt{CONFIGURATION}, and the module \texttt{UP}, which will be
*** used to evaluate the \texttt{up} functions. We shall see in
*** Section~\ref{main-module} how new predefined modules can be added to the
*** initial database.

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod PREDEF-UNITS is
  pr FM-UNIT .

*** The following module \texttt{UP} contains the necessary declarations to
*** be able to parse the \texttt{up} functions presented in
*** Section~\ref{structured-specifications}. We shall see in
*** Section~\ref{evaluation} how a declaration importing the following module
*** \texttt{UP} is added to all the modules importing the predefined module
*** \texttt{META-LEVEL}. With this declaration, it is possible to parse the
*** \texttt{up} commands in the bubbles of such modules or in commands being
*** evaluated in such modules. We shall see in Section~\ref{bubble-parsing}
*** how these commands are then evaluated.

  op #UP# : -> FModule [memo] .
  eq #UP#
    = (fmod '#UP# is
        including 'QID-LIST .
        including 'FM-MOD-EXPR .
        sorts none .
        none
        op 'upTerm : '@ModExp@ '@Bubble@ -> 'Term [none] .
        op 'upModule : '@ModExp@ -> 'Module [none] .
        op '`[_`] : '@Token@ -> 'Module [none] .
        op 'token : 'Qid -> '@Token@
             [special(
               (id-hook('Bubble, '1 '1)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)))] .
        op 'viewToken : 'Qid -> '@ViewToken@
             [special(
               (id-hook('Bubble, '1 '1)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)))] .
        op 'sortToken : 'Qid -> '@SortToken@
             [special(
               (id-hook('Bubble, '1 '1)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)
                id-hook('Exclude, '`[ '`] '< 'to '`, '. '`( '`) '`{ '`} ':
                                  'ditto 'precedence 'prec 'gather
                                  'assoc 'associative 'comm 'commutative
                                  'ctor 'constructor 'id: 'strat 'strategy
                                  'poly 'memo 'memoization 'iter 'frozen
                                  'config 'object 'msg 'metadata 'nonexec 'variant)))] .
        op 'neTokenList : 'QidList -> '@NeTokenList@
             [special(
               (id-hook('Bubble, '1 '-1 '`( '`))
                op-hook('qidListSymbol, '__, 'QidList 'QidList, 'QidList)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)
                id-hook('Exclude, '. ':)))] .
        op 'bubble : 'QidList -> '@Bubble@
             [special(
               (id-hook('Bubble, '1 '-1 '`( '`))
                op-hook('qidListSymbol, '__, 'QidList 'QidList, 'QidList)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)
                id-hook('Exclude, 'eq 'ceq 'rl 'crl 'mb 'cmb 'sd 'csd
                                  'var 'vars 'strat 'endm
                                  'endfm 'endsm 'sorts 'subsort 'subsorts
                                  'subclass 'subclasses 'op 'ops
                                  'protecting 'pr 'including 'inc 'extending
                                  'ctor 'assoc 'comm '==)))] .
        op 'ububble : 'QidList -> '@UBubble@
             [special(
               (id-hook('Bubble, '1 '-1 '`( '`))
                op-hook('qidListSymbol, '__, 'QidList 'QidList, 'QidList)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)))] .
        op 'stbubble : 'QidList -> '@StBubble@
             [special(
               (id-hook('Bubble, '1 '-1 '`( '`))
                op-hook('qidListSymbol, '__, 'QidList 'QidList, 'QidList)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)
                id-hook('Exclude, 'using)))] .
        op 'eqlbubble : 'QidList -> '@EqLBubble@
             [special(
               (id-hook('Bubble, '1 '-1 '`( '`))
                op-hook('qidListSymbol, '__, 'QidList 'QidList, 'QidList)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)
                id-hook('Exclude, '=)))] .
        op 'rllbubble : 'QidList -> '@RlLBubble@
             [special(
               (id-hook('Bubble, '1 '-1 '`( '`))
                op-hook('qidListSymbol, '__, 'QidList 'QidList, 'QidList)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)
                id-hook('Exclude, '=>)))] .
        op 'sdlbubble : 'QidList -> '@SdLBubble@
             [special(
               (id-hook('Bubble, '1 '-1 '`( '`))
                op-hook('qidListSymbol, '__, 'QidList 'QidList, 'QidList)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)
                id-hook('Exclude, ':=)))] .
        op 'rcbubble : 'QidList -> '@RCBubble@
             [special(
               (id-hook('Bubble, '1 '-1 '`( '`))
                op-hook('qidListSymbol, '__, 'QidList 'QidList, 'QidList)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)
                id-hook('Exclude, 'if)))] .
        op 'rbubble : 'QidList -> '@RBubble@
             [special(
               (id-hook('Bubble, '1 '-1 '`( '`))
                op-hook('qidListSymbol, '__, 'QidList 'QidList, 'QidList)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)
                id-hook('Exclude, '.)))] .
        none
        none
     endfm) .
endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

***
*** 7 The Evaluation of Views
***

*** Before being entered into the database, besides containing bubbles, views
*** have a somewhat different structure from that of the views given in
*** Section~\ref{viewADT}. We introduce in the following module a sort
*** \texttt{PreView} with constructor \texttt{view}, which is declared as the
*** constructor for views of sort \texttt{View}, but with an additional
*** argument, namely, a set of variable declarations to hold the declarations
*** of variables in the view. During the processing of views (see
*** Section~\ref{view-processing}), which takes place once the parsing process
*** has concluded, these variables are associated with the corresponding maps
*** where they are used, generating a term of sort \texttt{View}.

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod PRE-VIEW is
  pr VIEW .

  sort PreView .
  op preview_from_to_is____endpv : Header ModuleExpression ModuleExpression
       VariableSet SortMappingSet OpMappingSet StratMappingSet -> PreView
       [ctor format (nir! o r! o r! o r! o o o o r! o)] .
  op null : -> PreView .

  op getName : PreView -> ViewExpression .
  op getPars : PreView -> ParameterDeclList .
  op getFrom : PreView -> ModuleExpression .
  op getTo : PreView -> ModuleExpression .
  op getVars : PreView -> VariableSet .
  op getSortMappings : PreView -> SortMappingSet .
  op getOpMappings : PreView -> OpMappingSet .
  op getStratMappings : PreView -> StratMappingSet .

  var  QI : Qid .
  vars ME ME' : ModuleExpression .
  var  VE : ViewExpression .
  var  VH : Header .
  vars PDL PDL' : ParameterDeclList .
  vars VDS VDS' : VariableSet .
  vars SMS SMS' : SortMappingSet .
  vars OMS OMS' : OpMappingSet .
  vars TMS TMS' : StratMappingSet .

  eq getName(preview VE from ME to ME' is VDS SMS OMS TMS endpv) = VE .
  eq getName(preview VE{PDL} from ME to ME' is VDS SMS OMS TMS endpv) = VE .
  eq getPars(preview VE from ME to ME' is VDS SMS OMS TMS endpv) = nil .
  eq getPars(preview VE{PDL} from ME to ME' is VDS SMS OMS TMS endpv) = PDL .
  eq getFrom(preview VH from ME to ME' is VDS SMS OMS TMS endpv) = ME .
  eq getTo(preview VH from ME to ME' is VDS SMS OMS TMS endpv) = ME' .
  eq getVars(preview VH from ME to ME' is VDS SMS OMS TMS endpv) = VDS .
  eq getSortMappings(preview VH from ME to ME' is VDS SMS OMS TMS endpv) = SMS .
  eq getOpMappings(preview VH from ME to ME' is VDS SMS OMS TMS endpv) = OMS .
  eq getStratMappings(preview VH from ME to ME' is VDS SMS OMS TMS endpv) = TMS .

*** The following functions can be used to add new declarations to the set of
*** declarations already in a preview.

  op addMaps : SortMappingSet PreView -> PreView .
  op addMaps : OpMappingSet PreView -> PreView .
  op addMaps : StratMappingSet PreView -> PreView .
  op addVars : VariableSet PreView -> PreView .

  eq addMaps(SMS, preview VH from ME to ME' is VDS SMS' OMS TMS endpv)
    = preview VH from ME to ME' is VDS (SMS SMS') OMS TMS endpv .
  eq addMaps(OMS, preview VH from ME to ME' is VDS SMS OMS' TMS endpv)
    = preview VH from ME to ME' is VDS SMS (OMS OMS') TMS endpv .
  eq addMaps(TMS, preview VH from ME to ME' is VDS SMS OMS TMS' endpv)
    = preview VH from ME to ME' is VDS SMS OMS (TMS TMS') endpv .

  eq addVars(VDS, preview VH from ME to ME' is VDS' SMS OMS TMS endpv)
    = preview VH from ME to ME' is (VDS ; VDS') SMS OMS TMS endpv .

  op setPars : PreView ParameterDeclList -> PreView .
  eq setPars(preview VE from ME to ME' is VDS SMS OMS TMS endpv, PDL)
    = preview VE{PDL} from ME to ME' is VDS SMS OMS TMS endpv
    [owise] .
  eq setPars(preview VE{PDL} from ME to ME' is VDS SMS OMS TMS endpv, PDL')
    = preview VE{PDL'} from ME to ME' is VDS SMS OMS TMS endpv .

  op emptyPreView : Qid ModuleExpression ModuleExpression -> PreView .
  eq emptyPreView(QI, ME, ME')
    = preview QI from ME to ME' is none none none none endpv .
endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

***
*** The Database
***

*** In order to be able to refer to modules by name, which is extremely useful
*** for module definition purposes at the user level, the evaluation of module
*** expressions takes place in the context of a database, in which we keep
*** information about the modules already introduced in the system, and also
*** about those modules generated internally.  This information is stored as
*** a set of elements of sort \texttt{ModuleInfo} and \texttt{ViewInfo}, in
*** which we hold, respectively, the information concerning units and views.
*** For each unit we save:
*** \begin{itemize}
*** \item Its original form, as introduced by the user, or, in case of an
***       internally generated unit, as generated from the original form of
***       some other unit.
*** \item Its internal representation, in which variables have been renamed
***       to avoid collisions with the names of variables in other units in
***       the same hierarchy.  In the case of object-oriented units, we store
***       its equivalent system module, that is, the result of transforming
***       it into a system module.
*** \item Its signature, which is given as a functional module of sort
***       \texttt{FModule} with no axioms, ready to be used in calls to
***       \texttt{metaParse}. There can only be importation declarations
***       including built-in modules in this module. These are the only
***       inclusions handled by the Core Maude engine.
*** \item Its flattened version, for which, as for signatures, only the
***       importation of built-in modules is left unevaluated.
*** \end{itemize}
*** For each view we keep its name and the view itself.

*** As a simple mechanism to keep the database consistent, for each unit we
*** maintain the list of names of all the units and views ``depending'' on it.
*** Similarly, for each view we maintain the list of names of all the units
*** ``depending'' on it. The idea is that if a unit or view is redefined or
*** removed, all those units and/or views depending on it will also be
*** removed. This dependency does not only mean direct importation. For
*** example, the module resulting from the renaming of some module also
*** depends on the module being renamed; the instantiation of a parameterized
*** module also depends on the parameterized module and on all the views used
*** in its instantiation; a view depends on its source and target units, etc.
*** This dependency is transitive: if a module, theory, or view has to be
*** removed, all the units and/or views depending on them will be removed as
*** well. The dependencies derived from the module expressions themselves are
*** established by the function \texttt{setUpModExpDeps}. The function
*** \texttt{setUpModuleDeps} calls \texttt{setUpModExpDeps},
*** and then \texttt{setUpImportSetDeps} to add the \emph{back
*** references} in the modules being imported. The function
*** \texttt{setUpViewDeps} sTS up the back references for the views
*** being introduced.

*** In addition to this set of information cells for units and views, we also
*** keep lists with the names of all the units and views in the database, and
*** a list of quoted identifiers in which we store the messages generated
*** during the process of treatment of the inputs in order to simplify the
*** communication with the read-eval-print loop process.

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

view ModuleName from TRIV to MOD-NAME is
  sort Elt to ModuleName .
endv

view ViewExpression from TRIV to FM-VIEW-EXPR is
  sort Elt to ViewExpression .
endv

view ParameterDecl from TRIV to META-MODULE is
  sort Elt to ParameterDecl .
endv

fmod INFO is
  pr VIEW .
  pr DEFAULT-VALUE{Term} .
  pr (SET * (op _`,_ to _._,
             op empty to emptyModuleNameSet,
             op insert to insertModuleNameSet,
             op delete to deleteModuleNameSet,
             op _in_ to _inModuleNameSet_,
             op |_| to |_|ModuleNameSet,
             op $card to $cardModuleNameSet,
             op union to unionModuleNameSet,
             op intersection to intersectionModuleNameSet,
             op $intersect to $intersectModuleNameSet,
             op _\_ to _\ModuleNameSet_,
             op $diff to $diffModuleNameSet,
             op _subset_ to _subsetModuleNameSet_,
             op _psubset_ to _psubsetModuleNameSet_)){ModuleName} .
  pr (SET * (op _`,_ to _#_,
             op empty to emptyViewExpressionSet,
             op insert to insertViewExpressionSet,
             op delete to deleteViewExpressionSet,
             op _in_ to _inViewExpressionSet_,
             op |_| to |_|ViewExpressionrSet,
             op $card to $cardViewExpressionrSet,
             op union to unionViewExpressionrSet,
             op intersection to intersectionViewExpressionrSet,
             op $intersect to $intersectViewExpressionrSet,
             op _\_ to _\ViewExpressionrSet_,
             op $diff to $diffViewExpressionrSet,
             op _subset_ to _subsetViewExpressionrSet_,
             op _psubset_ to _psubsetViewExpressionrSet_)){ViewExpression} .
  pr (SET * (op _`,_ to _._)){ParameterDecl} .

  var  MN : ModuleName .
  var  MNS : Set{ModuleName} .

  op remove : Set{ModuleName} ModuleName -> Set{ModuleName} .
  eq remove(MN . MNS, MN) = remove(MNS, MN) .
  eq remove(MNS, MN) = MNS [owise] .

  sort ModuleInfo .
  op <_;_;_;_;_;_;_;_> : ModuleName Default{Term} Module Module Module
       VariableSet Set{ModuleName} Set{ViewExpression} -> ModuleInfo
     [ctor
      format
        (nig o g n+++io g nio g nio g nio g nio g nio g nio n---ig o)] .
  op <_;_;_;_;_;_;_;_> : ModuleName Module Module Module Module
       VariableSet Set{ModuleName} Set{ViewExpression} -> ModuleInfo
     [ctor
      format
      (nig ur! g n+++io g nio g nio g nio g nio g nio g nio n---ig o)] .

  *** - Modules can be introduced by the user or can be generated internally.
  ***   When introduced by the user the 2nd arg. keeps the term representation
  ***   of the module as given, so that it can be recompiled later. If the
  ***   module is generated internally as the result of the evaluation of a
  ***   module expression, then this second arg. will be null, the default
  ***   term value. The user can also enter modules with the procModule
  ***   function, providing then the metarepresentation of a module, which
  ***   is directly stored in the database as the 2nd arg. of one of these
  ***   ModuleInfo units of the second kind. This is useful for the ITP for
  ***   example, where the interaction with the database takes place at the
  ***   metalevel and the modules given by the "user" are already at the
  ***   metalevel but still wants the same treatment.
  *** - The sixth arg. stores the variables (corresponding ops.) in the top
  ***   module.

  sort ViewInfo .
  op <_;_;_;_;_> : ViewExpression Default{Term} View Set{ModuleName}
       Set{ViewExpression} -> ViewInfo
       [ctor format (nig o g n+++io g nio g nio g nio n---ig o)] .
  op <_;_;_;_;_> :
       ViewExpression View View Set{ModuleName} Set{ViewExpression} -> ViewInfo
       [ctor format (nig o g n+++io g nio g nio g nio n---ig o)] .

endfm

view ModuleInfo from TRIV to INFO is
  sort Elt to ModuleInfo .
endv

view ViewInfo from TRIV to INFO is
  sort Elt to ViewInfo .
endv

fmod DATABASE-DECLS is
  pr (SET * (op _`,_ to __, op empty to emptyInfoSet)){ModuleInfo} .
  pr (SET * (op _`,_ to __, op empty to emptyInfoSet)){ViewInfo} .

  sort Database .
  op db :
     Set{ModuleInfo}  *** module info tuples
     Set{ModuleName}  *** names of the modules in the database
     Set{ViewInfo}    *** view info tuples
     Set{ViewExpression}     *** names of the views in the db
     Set{ModuleName}  *** modules with set protect on (by default empty)
     Set{ModuleName}  *** modules with set extend on (by default empty)
     Set{ModuleName}  *** modules with set include on (by default empty)
     QidList
       -> Database
     [ctor
      format (nib i++o)] .

  ops getDefPrs getDefExs getDefIncs : Database -> Set{ModuleName} .
  eq getDefPrs(
        db(MIS:Set{ModuleInfo}, MNS:Set{ModuleName}, VIS:Set{ViewInfo},
           VES:Set{ViewExpression}, MNS':Set{ModuleName}, MNS'':Set{ModuleName},
           MNS3:Set{ModuleName}, QIL:QidList))
    = MNS':Set{ModuleName} .
  eq getDefExs(
        db(MIS:Set{ModuleInfo}, MNS:Set{ModuleName}, VIS:Set{ViewInfo},
           VES:Set{ViewExpression}, MNS':Set{ModuleName}, MNS'':Set{ModuleName},
           MNS3:Set{ModuleName}, QIL:QidList))
    = MNS'':Set{ModuleName} .
  eq getDefIncs(
        db(MIS:Set{ModuleInfo}, MNS:Set{ModuleName}, VIS:Set{ViewInfo},
           VES:Set{ViewExpression}, MNS':Set{ModuleName}, MNS'':Set{ModuleName},
           MNS3:Set{ModuleName}, QIL:QidList))
    = MNS3:Set{ModuleName} .
endfm

view Database from TRIV to DATABASE-DECLS is
  sort Elt to Database .
endv

view ModuleExpression from TRIV to META-MODULE is
  sort Elt to ModuleExpression .
endv

fmod DATABASE is
  pr (2TUPLE * (op `(_`,_`) to <_;_>,
                op p1_ to database,
                op p2_ to modExp)) {Database, ModuleExpression} .
  pr PRE-VIEW .
  pr FM-UNIT .
  pr FM-VIEW-EXPR-TO-QID .

  op evalModule : Module VariableSet Database -> Database .
  *** its definition is in the module FM-EVALUATION

  op procModule : Qid Database -> Database .
  op procView : Qid Database -> Database .
  op procView : View Database -> Database .
  *** their definitions are in the modules UNIT-PROCESSING and VIEW-PROCESSING

  op evalModExp : ModuleExpression Database -> Tuple{Database, ModuleExpression} .
  *** its definition is in the module MOD-EXPR-EVAL

  vars QI X Y F : Qid .
  vars QIL QIL' : QidList .
  vars NQIL NQIL' : NeQidList .
  vars VE VE' VE'' : ViewExpression .
  vars VES VES' VES'' VES3 : Set{ViewExpression} .
  vars MIS MIS' : Set{ModuleInfo} .
  var  VIS : Set{ViewInfo} .
  vars MNS MNS' MNS'' MNS3 MNS4 MNS5 MNS6 : Set{ModuleName} .
  vars PL PL' : ParameterList .
  vars PDS PDS' PDS'' : Set{ParameterDecl} .
  var  PDL : ParameterDeclList .
  var  PD : ParameterDecl .
  vars ME ME' : ModuleExpression .
  vars VI VI' : View .
  var  SMS : SortMappingSet .
  var  OMS : OpMappingSet .
  var  TMS : StratMappingSet .
  vars PU PU' U U' U'' U3 U4 : Module .
  var  M : Module .
  var  DB : Database .
  vars IL IL' : ImportList .
  var  VIf : ViewInfo .
  var  UIf : ModuleInfo .
  vars OPDS : OpDeclSet .
  vars VDS VDS' : VariableSet .
  var  PV : PreView .
  vars T T' : Term .
  var  DT : Default{Term} .
  var  NL : IntList .
  var  TyL : TypeList .
  var  Ty : Type .
  var  AtS : AttrSet .
  var  B : Bool .
  var  I : Import .
  var  MN MN' : ModuleName .

  ops dincluded : ModuleExpression ImportList -> Bool .

  eq dincluded(ME, IL (protecting ME .) IL') = true .
  eq dincluded(ME, IL (extending ME .) IL') = true .
  eq dincluded(ME, IL (including ME .) IL') = true .
  eq dincluded(ME, IL) = false [owise] .

  ops included includedAux : ModuleExpression ImportList Database -> Bool .

  eq included(ME, IL (protecting ME .) IL', DB) = true .
  eq included(ME, IL (extending ME .) IL', DB) = true .
  eq included(ME, IL (including ME .) IL', DB) = true .
  eq included(ME, nil, DB) = false .
  eq included(ME, IL, DB) = includedAux(ME, IL, DB) [owise] .

  eq includedAux(ME, I IL, DB)
    = included(ME, getImports(getTopModule(moduleName(I), DB)), DB)
      or-else includedAux(ME, IL, DB) .
  eq includedAux(ME, nil, DB) = false .

  op defImports : Module Database -> ImportList .
  op defImports : ImportList ImportList Set{ModuleName} Set{ModuleName}
       Set{ModuleName} -> ImportList .

  eq defImports(M, DB)
    = if theory(M)
      then nil
      else defImports(getImports(M), nil,
             getDefPrs(DB), getDefExs(DB), getDefIncs(DB))
      fi .

  eq defImports(IL, IL', MN . MNS, MNS', MNS'')
    = if dincluded(MN, IL IL')
      then defImports(IL, IL', MNS, MNS', MNS'')
      else defImports(IL, IL' (protecting MN .), MNS, MNS', MNS'')
      fi .
  eq defImports(IL, IL', MNS, MN . MNS', MNS'')
    = if dincluded(MN, IL IL')
      then defImports(IL, IL', MNS, MNS', MNS'')
      else defImports(IL, IL' (extending MN .), MNS, MNS', MNS'')
      fi .
  eq defImports(IL, IL', MNS, MNS', MN . MNS'')
    = if dincluded(MN, IL IL')
      then defImports(IL, IL', MNS, MNS', MNS'')
      else defImports(IL, IL' (including MN .), MNS, MNS', MNS'')
      fi .
  eq defImports(IL, IL',
       emptyModuleNameSet, emptyModuleNameSet, emptyModuleNameSet)
    = IL' .

*** The constant \texttt{emptyDatabase} denotes the empty database, and there
*** are predicates \texttt{viewInDatabase} and \texttt{unitInDb} to check,
*** respectively, whether a view and a unit are in a database or not.

  op emptyDatabase : -> Database .
  eq emptyDatabase
    = db(emptyInfoSet, emptyModuleNameSet, emptyInfoSet, emptyViewExpressionSet,
         emptyModuleNameSet, emptyModuleNameSet, 'BOOL, nil) .

  op unitInDb : ModuleName Database -> Bool .
  eq unitInDb(MN, db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, QIL))
    = MN inModuleNameSet MNS .

  op viewInDb : ViewExpression Database -> Bool .
  eq viewInDb(VE, db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, QIL))
    = VE inViewExpressionSet VES .

  op includeBOOL : Database -> Bool .
  eq includeBOOL(db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, QIL))
    = 'BOOL inModuleNameSet MNS' .

*** If a module, theory, or view is being redefined, that is, if there was
*** already in the database a module, theory, or view with the same name,
*** then all the units and/or views depending on it are removed using the
*** functions \texttt{delModules} and \texttt{delViews}. Removing a view
*** or a unit from the database means removing its info cell from the set of
*** cells in the database. Those entered by the user are not completely
*** removed, their term form is saved so that it can be recompiled later.

  op delModules : Set{ModuleName} Database -> Database .
  op delViews : Set{ViewExpression} Database -> Database .

  eq delModules((MN . MNS),
       db(< MN ; T ; U ; U' ; U'' ; VDS ; MNS' ; VES > MIS,
          MN . MNS'', VIS, VES', MNS3, MNS4, MNS5, QIL))
    = delModules((MNS . MNS'),
          delViews(VES,
            db(< MN ; T ; noModule ; noModule ; noModule ; VDS ;
                 emptyModuleNameSet ; emptyViewExpressionSet > MIS,
               MN . MNS'', VIS, VES', MNS3, MNS4, MNS5, QIL))) .
  eq delModules((MN . MNS),
       db(< MN ; U ; U' ; U'' ; U3 ; VDS ; MNS' ; VES > MIS,
          MN . MNS'', VIS, VES', MNS3, MNS4, MNS5, QIL))
    = delModules((MNS . MNS'),
          delViews(VES,
            db(< MN ; U ; noModule ; noModule ; noModule ; VDS ;
                 emptyModuleNameSet ; emptyViewExpressionSet > MIS,
               MN . MNS'', VIS, VES', MNS3, MNS4, MNS5, QIL))) .
  eq delModules((MN . MNS),
       db(< MN ; null ; U ; U' ; U'' ; VDS ; MNS' ; VES > MIS,
          MN . MNS'', VIS, VES', MNS3, MNS4, MNS5, QIL))
    = delModules((MNS . MNS'),
        delViews(VES,
            db(MIS, MNS'', VIS, VES', MNS3, MNS4, MNS5, QIL))) .
  eq delModules(emptyModuleNameSet, DB) = DB .
  eq delModules((MN . MNS), DB) = delModules(MNS, DB) [owise] .

  eq delViews(VE # VES,
       db(MIS, MNS, < VE ; T ; VI ; MNS' ; VES' > VIS, VE # VES'',
          MNS'', MNS3, MNS4, QIL))
    = delViews(VES # VES',
        delModules(MNS',
          db(MIS, MNS,
             < VE ; T ; null ; emptyModuleNameSet ; emptyViewExpressionSet > VIS,
             VE # VES'', MNS'', MNS3, MNS4, QIL))) .
  eq delViews(VE # VES,
       db(MIS, MNS,
          < VE ; (null).Default{Term} ; VI ; MNS' ; VES' > VIS, VE # VES'',
          MNS'', MNS3, MNS4, QIL))
    = delViews(VES # VES',
        delModules(MNS',
          db(MIS, MNS, VIS, VES'', MNS'', MNS3, MNS4, QIL))) .
  eq delViews(VE # VES,
       db(MIS, MNS, < VE ; VI ; VI' ; MNS' ; VES' > VIS, VE # VES'',
          MNS'', MNS3, MNS4, QIL))
    = delViews(VES # VES',
        delModules(MNS',
          db(MIS, MNS,
             < VE ; VI ; null ; emptyModuleNameSet ; emptyViewExpressionSet > VIS,
             VE # VES'', MNS'', MNS3, MNS4, QIL))) .
  eq delViews(emptyViewExpressionSet, DB) = DB .
  eq delViews(VE # VES, DB) = delViews(VES, DB) [owise] .

*** The \texttt{warning} function allows us to place messages (warning, error,
*** or any other kind of messages) in the last argument of the database
*** constructor. These messages are given in the form of quoted identifier
*** lists, and will be passed to the third argument of the read-eval-print
*** loop, to be printed in the terminal.

  op warning : Database QidList -> Database .
  eq warning(db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, nil), QIL)
    = db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, QIL) .
  eq warning(db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, NQIL), QIL)
    = db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, NQIL QIL) .

  op getMsg : Database -> QidList .
  eq getMsg(db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, QIL)) = QIL .

*** Core Maude built-in modules are handled in a special way in the current
*** version of the system. They are not explicitly defined in the Full Maude
*** database; their importation is directly handled by Core Maude. This has
*** some drawbacks: Core Maude built-in modules cannot be renamed; they cannot
*** be directly used with built-in functions, such as \texttt{metaReduce} or
*** \texttt{sameComponent}, although they can be imported in modules being
*** used in the calls to these functions; and, in general, any function taking
*** as argument or returning as result the metarepresentation of a module
*** cannot take one of these built-in modules as argument. This is the case,
*** for example, for the \texttt{up} function presented in
*** Section~\ref{changing-levels}, or for functions or commands in which the
*** name of a module has to be specified, as the \texttt{select} or
*** \texttt{down} commands, or the \texttt{up} function presented in
*** Section~\ref{structured-specifications}. Nevertheless, there are also
*** some advantages: The flattening of the built-in part of the structure is
*** accomplished more efficiently, and, since these modules do not have to be
*** stored in the database of Full Maude, the size of the database is reduced.

*** Our plan is to have in the future a hybrid solution. Once we have some way
*** of storing the modules entered to Full Maude in Core Maude's database, it
*** will be enough to keep in the Full Maude database just the original form
*** of the top of all the modules, including built-ins, leaving all the
*** importation declarations to be resolved by the engine. The structures will
*** be normalized as they are now, so that the engine will have to deal just
*** with inclusions, but it will be possible to use the predefined modules as
*** any other module. Moreover, the Full Maude database will be relatively
*** smaller and the flattening will be computed more efficiently.

*** When a new module or theory is entered, the names of all the modules,
*** theories, and views depending on it are included in its lists of
*** dependencies with functions \texttt{setUpModuleDeps} and
*** \texttt{setUpViewDeps}. Notice that if new module expressions are
*** defined, the function \texttt{setUpModExpDeps} will have to be
*** extended accordingly.

  op setUpModuleDeps : Module Database -> Database .
  op setUpModExpDeps : ModuleName Database -> Database .
  op setUpModExpDeps : ModuleName Header Database -> Database .
  op setUpModExpDeps : ModuleName ViewExpression Database -> Database .
  op setUpImportDeps : ModuleName ImportList Database -> Database .

  eq setUpModuleDeps(U, DB)
    = setUpImportDeps(getHeader(U), getImports(U),
        setUpModExpDeps(getHeader(U), DB)) .

  eq setUpModExpDeps(QI, DB) = DB .

  eq setUpModExpDeps(pd(X :: ME),
       db(< ME ; DT ; U ; U' ; U'' ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = db(< ME ; DT ; U ; U' ; U'' ; VDS ; (MNS . pd(X :: ME)) ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL) .
  eq setUpModExpDeps(pd(X :: ME),
       db(< ME ; U ; U' ; U'' ; U3 ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = db(< ME ; U ; U' ; U'' ; U3 ; VDS ; (MNS . pd(X :: ME)) ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL) .
  eq setUpModExpDeps(pd(X :: ME), DB)
    = warning(DB, ('\r 'Error: '\o 'Module header2QidList(ME) 'not 'in 'database. '\n))
    [owise] .

---- This could be a bug in Core Maude.
---- It should work if the next 6 equations are replaced by this single equation.
----  ceq setUpImportDeps(MN, (I IL),
----       db((< MN' ; U ; U' ; U'' ; U3 ; VDS ; MNS ; VES > MIS),
----          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
----    = setUpImportDeps(MN, IL,
----        db((< MN' ; U ; U' ; U'' ; U3 ; VDS ; MN . MNS ; VES > MIS),
----           MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
----    if MN' := moduleName(I) .
  eq setUpImportDeps(MN, ((including MN' .) IL),
       db((< MN' ; DT ; U ; U' ; U'' ; VDS ; MNS ; VES > MIS), MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = setUpImportDeps(MN, IL,
        db((< MN' ; DT ; U ; U' ; U'' ; VDS ; MN . MNS ; VES > MIS), MNS', VIS, VES', MNS'', MNS3, MNS4, QIL)) .
  eq setUpImportDeps(MN, ((including MN' .) IL),
       db((< MN' ; U ; U' ; U'' ; U3 ; VDS ; MNS ; VES > MIS), MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = setUpImportDeps(MN, IL,
        db((< MN' ; U ; U' ; U'' ; U3 ; VDS ; MN . MNS ; VES > MIS), MNS', VIS, VES', MNS'', MNS3, MNS4, QIL)) .
  eq setUpImportDeps(MN, ((extending MN' .) IL),
       db((< MN' ; DT ; U ; U' ; U'' ; VDS ; MNS ; VES > MIS), MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = setUpImportDeps(MN, IL,
        db((< MN' ; DT ; U ; U' ; U'' ; VDS ; MN . MNS ; VES > MIS), MNS', VIS, VES', MNS'', MNS3, MNS4, QIL)) .
  eq setUpImportDeps(MN, ((extending MN' .) IL),
       db((< MN' ; U ; U' ; U'' ; U3 ; VDS ; MNS ; VES > MIS), MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = setUpImportDeps(MN, IL,
        db((< MN' ; U ; U' ; U'' ; U3 ; VDS ; MN . MNS ; VES > MIS), MNS', VIS, VES', MNS'', MNS3, MNS4, QIL)) .
  eq setUpImportDeps(MN, ((protecting MN' .) IL),
       db((< MN' ; DT ; U ; U' ; U'' ; VDS ; MNS ; VES > MIS), MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = setUpImportDeps(MN, IL,
        db((< MN' ; DT ; U ; U' ; U'' ; VDS ; MN . MNS ; VES > MIS), MNS', VIS, VES', MNS'', MNS3, MNS4, QIL)) .
  eq setUpImportDeps(MN, ((protecting MN' .) IL),
       db((< MN' ; U ; U' ; U'' ; U3 ; VDS ; MNS ; VES > MIS), MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = setUpImportDeps(MN, IL,
        db((< MN' ; U ; U' ; U'' ; U3 ; VDS ; MN . MNS ; VES > MIS), MNS', VIS, VES', MNS'', MNS3, MNS4, QIL)) .
  eq setUpImportDeps(MN, I IL, DB)
    = warning(DB, '\r 'Error: '\o 'Module header2QidList(moduleName(I)) 'not 'in 'database. '\n)
    [owise] .
  eq setUpImportDeps(MN, nil, DB) = DB .

  op setUpViewDeps : ModuleExpression ViewExpression Database -> Database .
  op setUpViewExpressionDeps : ViewExpression Database -> Database .
  op setUpViewExpressionDeps : ViewExpression ParameterList Database -> Database .

  eq setUpViewDeps(ME, VE,
       db((< ME ; DT ; U ; U' ; U'' ; VDS ; MNS ; VES > MIS), MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = db((< ME ; DT ; U ; U' ; U'' ; VDS ; MNS ; VE # VES > MIS), MNS', VIS, VES', MNS'', MNS3, MNS4, QIL) .
  eq setUpViewDeps(ME, VE,
       db((< ME ; U ; U' ; U'' ; U3 ; VDS ; MNS ; VES > MIS), MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = db((< ME ; U ; U' ; U'' ; U3 ; VDS ; MNS ; VE # VES > MIS), MNS', VIS, VES', MNS'', MNS3, MNS4, QIL) .
  eq setUpViewDeps(ME, VE, DB)
    = warning(DB, '\r 'Error: '\o 'Module header2QidList(ME) 'not 'in 'database. '\n)
    [owise] .

  eq setUpViewExpressionDeps(QI, DB) = DB .
  eq setUpViewExpressionDeps(QI{PL}, DB) = setUpViewExpressionDeps(QI{PL}, PL, DB) .

  eq setUpViewExpressionDeps(VE, (QI, PL),
       db(MIS, MNS, < QI ; DT ; VI ; MNS' ; VES > VIS, VES', MNS'', MNS3, MNS4, QIL))
    = setUpViewExpressionDeps(VE, PL,
        db(MIS, MNS, < QI ; DT ; VI ; MNS' ; VE # VES > VIS, VES', MNS'', MNS3, MNS4, QIL)) .
  eq setUpViewExpressionDeps(VE, (QI, PL),
       db(MIS, MNS, < QI ; VI ; VI' ; MNS' ; VES > VIS, VES', MNS'', MNS3, MNS4, QIL))
    = setUpViewExpressionDeps(VE, PL,
        db(MIS, MNS, < QI ; VI ; VI' ; MNS' ; VE # VES > VIS, VES', MNS'', MNS3, MNS4, QIL)) .
  eq setUpViewExpressionDeps(QI{PL}, PL',
       db(MIS, MNS, < QI ; DT ; VI ; MNS' ; VES > VIS, VES', MNS'', MNS3, MNS4, QIL))
    = db(MIS, MNS, < QI ; DT ; VI ; MNS' ; QI{PL} # VES > VIS, VES', MNS'', MNS3, MNS4, QIL)
    [owise] .
  eq setUpViewExpressionDeps(QI{PL}, PL',
       db(MIS, MNS, < QI ; VI ; VI' ; MNS' ; VES > VIS, VES', MNS'', MNS3, MNS4, QIL))
    = db(MIS, MNS, < QI ; VI ; VI' ; MNS' ; QI{PL} # VES > VIS, VES', MNS'', MNS3, MNS4, QIL)
    [owise] .

  eq setUpViewExpressionDeps(VE, (QI{PL}, PL'),
       db(MIS, MNS, < QI{PL} ; DT ; VI ; MNS' ; VES > VIS, VES', MNS'', MNS3, MNS4, QIL))
    = setUpViewExpressionDeps(VE, PL',
        db(MIS, MNS, < QI{PL} ; DT ; VI ; MNS' ; VE # VES > VIS, VES', MNS'', MNS3, MNS4, QIL)) .
  eq setUpViewExpressionDeps(VE, (QI{PL}, PL'),
       db(MIS, MNS, < QI{PL} ; VI ; VI' ; MNS' ; VES > VIS, VES', MNS'', MNS3, MNS4, QIL))
    = setUpViewExpressionDeps(VE, PL',
        db(MIS, MNS, < QI{PL} ; VI ; VI' ; MNS' ; VE # VES > VIS, VES', MNS'', MNS3, MNS4, QIL)) .
  eq setUpViewExpressionDeps(VE, (QI{PL}, PL'), DB)
    = setUpViewExpressionDeps(VE, PL', DB)
    [owise] .
  eq setUpViewExpressionDeps(VE, empty, DB) = DB .

  op compiledModule : ModuleExpression Database -> Bool .
  op compiledModule : ParameterDecl Database -> Bool .
  op compiledView : ViewExpression Database -> Bool .

  eq compiledView(VE,
       db(MIS, MNS, < VE ; DT ; VI ; MNS' ; VES > VIS, VES', MNS'', MNS3, MNS4, QIL))
    = VI =/= null .
  eq compiledView(ME, DB) = false [owise] .

  eq compiledModule(MN,
       db(< MN ; DT ; U ; U' ; U'' ; VDS ; MNS ; VES > MIS, MNS',
          VIS, VES', MNS'', MNS3, MNS4, QIL))
    = U'' =/= noModule .
  eq compiledModule(MN,
       db(< MN ; U ; U' ; U'' ; U3 ; VDS ; MNS ; VES > MIS, MNS',
          VIS, VES', MNS'', MNS3, MNS4, QIL))
    = U3 =/= noModule .
  eq compiledModule(MN, DB) = false [owise] .

  op insertTermView : ViewExpression Term Database -> Database .
  op insertView : View Database -> Database .
  op getTermView : ViewExpression Database -> Default{Term} .
  op getView : ViewExpression Database -> View .

  eq insertTermView(VE, T,
       db(MIS, MNS, < VE ; DT ; VI ; MNS' ; VES > VIS, VES',
          MNS'', MNS3, MNS4, QIL))
    = delViews(VES,
        delModules(MNS',
          db(MIS, MNS,
            < VE ; T ; null ; emptyModuleNameSet ; emptyViewExpressionSet > VIS, VES',
            MNS'', MNS3, MNS4,
            QIL
            '\g 'Advisory: '\o 'View viewExp2QidList(VE) 'redefined. '\n))) .
  eq insertTermView(VE, T,
       db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, QIL))
    = db(MIS, MNS,
         < VE ; T ; null ; emptyModuleNameSet ; emptyViewExpressionSet > VIS,
         (VE # VES), MNS', MNS'', MNS3, QIL)
    [owise] .

  eq insertView(view VE from ME to ME' is SMS OMS TMS endv,
       db(MIS, MNS, < VE ; DT ; VI ; MNS' ; VES > VIS, VES', MNS'', MNS3, MNS4, QIL))
    = setUpViewExpressionDeps(VE,
        setUpViewDeps(ME, VE,
          setUpViewDeps(ME', VE,
            db(MIS, MNS,
               < VE ; DT ;
                 view VE from ME to ME' is SMS OMS TMS endv ;
                 MNS' ; VES > VIS,
                 VES', MNS'', MNS3, MNS4, QIL)))) .
  eq insertView(view VE{PDL} from ME to ME' is SMS OMS TMS endv,
       db(MIS, MNS, < VE ; DT ; VI ; MNS' ; VES > VIS, VES', MNS'', MNS3, MNS4, QIL))
    = setUpViewExpressionDeps(VE,
        setUpViewDeps(ME, VE,
          setUpViewDeps(ME', VE,
            db(MIS, MNS,
               < VE ; DT ;
                 view VE{PDL} from ME to ME' is SMS OMS TMS endv ;
                 MNS' ; VES > VIS,
                 VES', MNS'', MNS3, MNS4, QIL)))) .
  eq insertView(view VE from ME to ME' is SMS OMS TMS endv,
       db(MIS, MNS, VIS, VES', MNS'', MNS3, MNS4, QIL))
    = setUpViewExpressionDeps(VE,
        setUpViewDeps(ME, VE,
          setUpViewDeps(ME', VE,
            db(MIS, MNS,
               < VE ; (null).Default{Term} ;
                 view VE from ME to ME' is SMS OMS TMS endv ;
                 emptyModuleNameSet ; emptyViewExpressionSet > VIS,
                 VE # VES', MNS'', MNS3, MNS4, QIL))))
    [owise] .
  eq insertView(view VE{PDL} from ME to ME' is SMS OMS TMS endv, db(MIS, MNS, VIS, VES', MNS'', MNS3, MNS4, QIL))
    = setUpViewExpressionDeps(VE,
        setUpViewDeps(ME, VE,
          setUpViewDeps(ME', VE,
            db(MIS, MNS,
               < VE ; (null).Default{Term} ;
                 view VE{PDL} from ME to ME' is SMS OMS TMS endv ;
                 emptyModuleNameSet ; emptyViewExpressionSet > VIS,
                 VE # VES', MNS'', MNS3, MNS4, QIL))))
    [owise] .
  eq insertView(viewError(QIL), DB) = warning(DB, QIL) .
  ceq insertView(view VE:[ViewExpression] from ME:[ModuleExpression] to ME':[ModuleExpression] is SMS:[SortMappingSet] OMS:[OpMappingSet] TMS:[StratMappingSet] endv, DB)
    = warning(DB, 'The 'view QIL QI if QI == '`) then '\s else nil fi 'contains 'errors.)
    if not view VE:[ViewExpression] from ME:[ModuleExpression] to ME':[ModuleExpression] is SMS:[SortMappingSet] OMS:[OpMappingSet] TMS:[StratMappingSet] endv :: View
    /\ QIL QI := eMetaPrettyPrint(VE:[ViewExpression])
    [owise] .
  ceq insertView(view VE:[ViewExpression]{PDL:[ParameterDeclList]} from ME:[ModuleExpression] to ME':[ModuleExpression] is SMS:[SortMappingSet] OMS:[OpMappingSet] TMS:[StratMappingSet] endv, DB)
    = warning(DB, 'The 'view QIL QI if QI == '`) then '\s else nil fi 'contains 'errors.)
    if not view VE:[ViewExpression]{PDL:[ParameterDeclList]} from ME:[ModuleExpression] to ME':[ModuleExpression] is SMS:[SortMappingSet] OMS:[OpMappingSet] TMS:[StratMappingSet] endv :: View
    /\ QIL QI := eMetaPrettyPrint(VE:[ViewExpression])
    [owise] .

  eq getTermView(VE,
       db(MIS, MNS, (< VE ; DT ; VI ; MNS' ; VES > VIS), VES', MNS'', MNS3, MNS4, QIL))
    = DT .
  eq getTermView(VE, db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, QIL))
    = qidError('\r 'Error: '\o 'View viewExp2QidList(VE) 'not 'in 'database. '\n)
    [owise] .

  eq getView(VE,
       db(MIS, MNS, < VE ; DT ; VI ; MNS' ; VES > VIS, VES', MNS'', MNS3, MNS4, QIL))
    = VI .
  eq getView(VE,
       db(MIS, MNS, < VE ; VI ; VI' ; MNS' ; VES > VIS, VES', MNS'', MNS3, MNS4, QIL))
    = VI' .
  eq getView(VE, db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, QIL))
    = viewError('\r 'Error: '\o 'View viewExp2QidList(VE) 'not 'in 'database. '\n)
    [owise] .

*** There are functions to insert the different versions of a unit, and to
*** extract them.  We only give here the equations for the insertion of top
*** units to illustrate the way in which the consistency of the database is
*** maintained.  We assume that when the internal version, the signature, or
*** the flat version of a module is entered in the database, its corresponding
*** top module is already present in it.

  pr 3TUPLE{Term,VariableSet,Module} * (op ((_,_,_)) to <_;_;_>) .

*** extended variable set
  op variableSetError : QidList -> [VariableSet] [ctor format (r o)] .
  eq variableSetError(QIL) variableSetError(QIL') = variableSetError(QIL QIL') .


----  sort Tuple{Term,OpDeclSet,Module} .
----  op <_;_;_> : Default{Term} OpDeclSet Module -> Tuple{Term,OpDeclSet,Module} .
  op error : QidList -> [Tuple{Term,VariableSet,Module}] .

  op insTermModule : ModuleName Module Database -> Database .
  op insTermModule : ModuleName Term Database -> Database .
  op insertTopModule : ModuleExpression [Module] Database -> Database .
  op insertInternalModule : ModuleExpression [Module] Database -> Database .
  op insertFlatModule : ModuleExpression [Module] Database -> Database .
  op insertVars : ModuleExpression [VariableSet] Database -> Database .
  op getTermModule : ModuleExpression Database -> [Tuple{Term,VariableSet,Module}] .
  op getTopModule : ModuleExpression Database -> [Module] .
  op getInternalModule : ModuleExpression Database -> [Module] .
  op getFlatModule : ModuleExpression Database -> [Module] .
  op getFlatModuleNeg : ModuleExpression Database -> [Module] .
  op getVars : ModuleExpression Database -> [VariableSet] .
  op insertTopModule : ParameterDecl [Module] Database -> Database .
  op insertInternalModule : ParameterDecl [Module] Database -> Database .
  op insertFlatModule : ParameterDecl [Module] Database -> Database .
  op insertVars : ParameterDecl [OpDeclSet] Database -> Database .
  op getTermModule : ParameterDecl Database -> [Tuple{Term,VariableSet,Module}] .
  op getTopModule : ParameterDecl Database -> [Module] .
  op getInternalModule : ParameterDecl Database -> [Module] .
  op getFlatModule : ParameterDecl Database -> [Module] .
  op getFlatModuleNeg : ParameterDecl Database -> [Module] .
  op getVars : ParameterDecl Database -> [VariableSet] .

  eq insTermModule(MN, T,
       db(< MN ; DT ; U ; U' ; U'' ; VDS ; MNS ; VES > MIS, MNS',
          VIS, VES', MNS'', MNS3, MNS4, QIL))
    = delModules(MNS,
          delViews(VES,
            db(< MN ; T ; noModule ; noModule ; noModule ; none ;
                 emptyModuleNameSet ; emptyViewExpressionSet > MIS,
               MNS', VIS, VES', MNS'', MNS3, MNS4,
               QIL
               '\g 'Advisory: '\o 'Module header2QidList(MN) 'redefined. '\n))).
  eq insTermModule(MN, T,
       db(< MN ; U ; U' ; U'' ; U3 ; VDS ; MNS ; VES > MIS, MNS',
          VIS, VES', MNS'', MNS3, MNS4, QIL))
    = delModules(MNS,
          delViews(VES,
            db(< MN ; T ; noModule ; noModule ; noModule ; none ;
                 emptyModuleNameSet ; emptyViewExpressionSet > MIS,
               MNS', VIS, VES', MNS'', MNS3, MNS4,
               QIL
               '\g 'Advisory: '\o 'Module header2QidList(MN) 'redefined. '\n))).
  eq insTermModule(MN, T,
       db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, QIL))
    = db(< MN ; T ; noModule ; noModule ; noModule ; none ;
           emptyModuleNameSet ; emptyViewExpressionSet > MIS,
         MN . MNS, VIS, VES, MNS', MNS'', MNS3, QIL)
    [owise] .
  eq insTermModule(MN, qidError(QIL), DB) = warning(DB, QIL) .
  eq insTermModule(MN, unitError(QIL), DB) = warning(DB, QIL) .

  eq insTermModule(MN, U,
       db(< MN ; DT ; U' ; U'' ; U3 ; VDS ; MNS ; VES > MIS, MNS',
          VIS, VES', MNS'', MNS3, MNS4, QIL))
    = delModules(MNS,
          delViews(VES,
            db(< MN ; U ; noModule ; noModule ; noModule ; none ;
                 emptyModuleNameSet ; emptyViewExpressionSet > MIS,
               MNS', VIS, VES', MNS'', MNS3, MNS4,
               QIL
               '\g 'Advisory:
               '\o 'Module header2QidList(MN) 'redefined. '\n))).
  eq insTermModule(MN, U,
       db(< MN ; U' ; U'' ; U3 ; U4 ; VDS ; MNS ; VES > MIS, MNS',
          VIS, VES', MNS'', MNS3, MNS4, QIL))
    = delModules(MNS,
          delViews(VES,
            db(< MN ; U ; noModule ; noModule ; noModule ; none ;
                 emptyModuleNameSet ; emptyViewExpressionSet > MIS,
               MNS', VIS, VES', MNS'', MNS3, MNS4,
               QIL
               '\g 'Advisory:
               '\o 'Module header2QidList(MN) 'redefined. '\n))).
  eq insTermModule(MN, U,
       db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, QIL))
    = db(< MN ; U ; noModule ; noModule ; noModule ; none ;
           emptyModuleNameSet ; emptyViewExpressionSet > MIS,
         MN . MNS, VIS, VES, MNS', MNS'', MNS3, QIL)
    [owise] .
  eq insTermModule(MN, qidError(QIL), DB) = warning(DB, QIL) .
  eq insTermModule(MN, unitError(QIL), DB) = warning(DB, QIL) .

  eq insertTopModule(MN, U,
       db(< MN ; null ; U' ; U'' ; U3 ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = db(< MN ; null ; U ; noModule ; noModule ; VDS ; MNS ; VES > MIS,
         MNS', VIS, VES', MNS'', MNS3, MNS4,
         QIL
         '\r 'Advisory: '\o
         'Internally 'generated 'module header2QidList(MN) 'redefined. '\n) .
  eq insertTopModule(MN, U,
       db(< MN ; T ; U' ; U'' ; U3 ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = setUpModuleDeps(U,
        db(< MN ; T ; U ; noModule ; noModule ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL)) .
  eq insertTopModule(MN, U,
       db(< MN ; U' ; U'' ; U3 ; U4 ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = setUpModuleDeps(U,
        db(< MN ; U' ; U ; noModule ; noModule ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL)) .
  eq insertTopModule(MN, U,
       db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, QIL))
    = setUpModuleDeps(U,
        db(< MN ; null ; U ; noModule ; noModule ;
              none ; emptyModuleNameSet ; emptyViewExpressionSet > MIS,
           MN . MNS, VIS, VES, MNS', MNS'', MNS3, QIL))
    [owise] .
  eq insertTopModule(MN, unitError(QIL), DB) = warning(DB, QIL) .

  eq insertInternalModule(MN, U,
       db(< MN ; DT ; U' ; U'' ; U3 ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = db(< MN ; DT ; U' ; U ; U3 ; VDS ; MNS ; VES > MIS,
         MNS', VIS, VES', MNS'', MNS3, MNS4, QIL) .
  eq insertInternalModule(MN, U,
       db(< MN ; U' ; U'' ; U3 ; U4 ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = db(< MN ; U' ; U'' ; U ; U4 ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL) .
  eq insertInternalModule(MN, unitError(QIL), DB) = warning(DB, QIL) .

  eq insertFlatModule(MN, U,
       db(< MN ; DT ; U' ; U'' ; U3 ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = db(< MN ; DT ; U' ; U'' ; U ; VDS ; MNS ; VES > MIS,
         MNS', VIS, VES', MNS'', MNS3, MNS4, QIL) .
  eq insertFlatModule(MN, U,
       db(< MN ; U' ; U'' ; U3 ; U4 ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = db(< MN ; U' ; U'' ; U3 ; U ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL) .
  eq insertFlatModule(MN, unitError(QIL), DB) = warning(DB, QIL) .

  eq insertVars(MN, VDS,
       db(< MN ; DT ; U' ; U'' ; U3 ; VDS' ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = db(< MN ; DT ; U' ; U'' ; U3 ; VDS ; MNS ; VES > MIS,
         MNS', VIS, VES', MNS'', MNS3, MNS4, QIL) .
  eq insertVars(MN, VDS,
       db(< MN ; U' ; U'' ; U3 ; U4 ; VDS' ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = db(< MN ; U' ; U'' ; U3 ; U4 ; VDS ; MNS ; VES > MIS,
         MNS', VIS, VES', MNS'', MNS3, MNS4, QIL) .
  eq insertVars(MN, variableSetError(QIL), DB) = warning(DB, QIL) .

  eq getTermModule(MN,
       db(< MN ; null ; U ; U' ; U'' ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = error('\r 'Error: '\o header2QidList(MN) 'is 'an 'internal 'module. '\n) .
  eq getTermModule(MN,
       db(< MN ; DT ; U ; U' ; U'' ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = < DT ; none ; noModule > .
  eq getTermModule(MN,
       db(< MN ; U ; U' ; U'' ; U3 ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = < null ; VDS ; U > .
  eq getTermModule(MN, DB)
    = error('\r 'Error: '\o 'Module header2QidList(MN)  '\n)
    [owise] .

  eq getTopModule(MN,
      db(< MN ; DT ; U ; U' ; U'' ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = U .
  eq getTopModule(MN,
       db(< MN ; U ; U' ; U'' ; U3 ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = U' .
  eq getTopModule(MN, DB)
    = unitError('\r 'Error: '\o 'Module header2QidList(MN) 'not 'in 'database. '\n)
    [owise] .

  eq getInternalModule(MN,
       db(< MN ; DT ; U ; U' ; U'' ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = U' .
  eq getInternalModule(MN,
       db(< MN ; U ; U' ; U'' ; U3 ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = U'' .
  eq getInternalModule(MN, DB)
    = unitError('\r 'Error: '\o 'Module header2QidList(MN) 'not 'in 'database. '\n)
    [owise] .

  eq getVars(MN,
       db(< MN ; DT ; U ; U' ; M ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = VDS .
  eq getVars(MN,
       db(< MN ; U ; U' ; U'' ; M ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = VDS .
  eq getVars(MN, DB) = none [owise] .

*** The name of the signature and the flattened module is not the
*** module expression used as the name of the module but the result of
*** converting it into a quoted identifier.

  eq getFlatModule(MN,
       db(< MN ; DT ; U ; U' ; M ; VDS ; MNS ; VES > MIS, MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = if M == noModule
      then unitError('\r 'Error: '\o 'Module header2QidList(MN) 'not 'compiled. '\n)
      else remNegAnns(M)
      fi .
  eq getFlatModule(MN,
       db(< MN ; U ; U' ; U'' ; M ; VDS ; MNS ; VES > MIS, MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = if M == noModule
      then unitError('\r 'Error: '\o 'Module header2QidList(MN) 'not 'compiled. '\n)
      else remNegAnns(M)
      fi .
  eq getFlatModule(MN, DB)
    = unitError('\r 'Error: '\o 'Module header2QidList(MN) 'not 'in 'database. '\n)
    [owise] .

  *** Handling of negative annotations (by Santiago Escobar)

  eq getFlatModuleNeg(MN,
       db(< MN ; DT ; U ; U' ; M ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = M .
  eq getFlatModuleNeg(MN,
       db(< MN ; U ; U' ; U'' ; M ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = M .
  eq getFlatModuleNeg(MN,
       db(< MN ; DT ; U ; U' ; noModule ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = unitError('\r 'Error: '\o
                'Module header2QidList(MN) 'not 'compiled. '\n) .
  eq getFlatModuleNeg(MN,
      db(< MN ; U ; U' ; U'' ; noModule ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = unitError('\r 'Error: '\o
                'Module header2QidList(MN) 'not 'compiled. '\n) .
  eq getFlatModuleNeg(MN, DB)
    = unitError('\r 'Error: '\o 'Module header2QidList(MN) 'not 'in 'database. '\n)
    [owise] .

  *** removeNegAnnotations
  op remNegAnns : Module -> Module .
  op remNegAnns : OpDeclSet -> OpDeclSet .
  op remNegAnns : AttrSet -> AttrSet .
  op remNegAnns : IntList -> IntList .

  eq remNegAnns(M) = setOps(M, remNegAnns(getOps(M))) .

  eq remNegAnns(op F : TyL -> Ty [AtS] . OPDS)
    = op F : TyL -> Ty [remNegAnns(AtS)] . remNegAnns(OPDS) .
  eq remNegAnns((none).OpDeclSet) = (none).OpDeclSet .

  eq remNegAnns(strat(NL:NatList) AtS) = strat(NL:NatList) AtS .
  eq remNegAnns(strat(IL:IntList) AtS) = AtS [owise] .
  eq remNegAnns(AtS) = AtS [owise] .

endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

***
*** The Evaluation of Modules
***

*** The general principle for the evaluation of units in our design consists in
*** first evaluating any module expression, reducing it to a canonical form in
*** which only unit inclusions appear, that is, to a unit hierarchy, which can
*** be seen as a partial order of unit inclusions. The design of the Full Maude
*** system has been based upon the principle of evaluating all module
*** expressions to irreducible structured units, and on using the flat version
*** of the units only for execution purposes. We have then two different
*** processes clearly distinguished: a first step in which the structured unit
*** is evaluated and reduced to its normal form, and a second step in which
*** this normal form is flattened.

*** As explained in Section~\ref{execution-environment}, the process of
*** evaluation to normal form is also responsible for the parsing of the
*** bubbles in the premodules, which is accomplished once the signature has
*** been built. The parsing of bubbles is discussed in
*** Section~\ref{bubble-parsing}. To be able to handle the \texttt{up}
*** function and the \texttt{down} command presented in
*** Section~\ref{structured-specifications}, it is necessary to be able to
*** move terms and modules from one level of reflection to another. The
*** functionality to move between levels is presented in
*** Section~\ref{changing-levels}, where functions \texttt{up} and
*** \texttt{down} on sorts \texttt{Module} and \texttt{Term} are defined. The
*** transformation of object-oriented modules into system modules in discussed
*** in Section~\ref{omod2modfunction}. The evaluation of module expressions is
*** discussed in Sections~\ref{evalModExp}, \ref{application-of-maps},
*** \ref{instantiation}, and~\ref{renaming}.

***
*** Changing Levels
***

*** Moving terms of sorts \texttt{Term} and \texttt{Module} from one
*** level of reflection to another is possible thanks to the
*** \texttt{up} and \texttt{down} functions, which are defined,
*** respectively, in the following modules \texttt{MOVE-UP} and
*** \texttt{MOVE-DOWN}.

***
*** The \texttt{up} Function
***

*** Given a term of sort \texttt{Module} or \texttt{Term}, the
*** \texttt{up} function, defined in the following module
*** \texttt{MOVE-UP}, returns the term metarepresenting it. The
*** function is just call the \texttt{upTerm} predefined function.

*** We shall see in Section~\ref{bubble-parsing} how the \texttt{up} function
*** is used to evaluate the homonymous function discussed in
*** Section~\ref{structured-specifications}. In Section~\ref{instantiation} we
*** shall discuss how the \texttt{up} function is used to evaluate the
*** \texttt{META-LEVEL} module expression (see
*** Section~\ref{structured-specifications}).

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod MOVE-UP is
---  pr META-LEVEL + PRE-VARIANT .
  pr META-LEVEL .
  pr CONVERSION .
  op up : Module -> Term .
  op up : Term -> Term .
  op up : EquationSet -> Term .

  eq up(M:Module) = upTerm(M:Module) .
  eq up(T:Term) = upTerm(T:Term) .
  eq up(EqS:EquationSet) = upTerm(EqS:EquationSet) .

endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

***
*** The \texttt{down} Function
***

*** Given a term of sort \texttt{Term} metarepresenting a term of sort
*** \texttt{Term} or \texttt{Module}, the \texttt{down} function can be seen
*** as the inverse of the \texttt{up} function discussed in the previous
*** section, that is, it returns the original term that had been
*** metarepresented. There are also \texttt{down} functions for terms
*** metarepresenting terms in other sorts. We present here only some of them.

*** We assume that the \texttt{down} functions are called with valid
*** metarepresentations. In fact, these functions should be declared as
*** partial functions going to error sorts when their arguments are invalid.

*** The main application of the \texttt{down} functions is in the evaluation
*** of the \texttt{down} command (see
*** Section~\ref{structured-specifications}).  However, they are also used in
*** other tasks, as for example in the parsing of some inputs.

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod MOVE-DOWN is
  pr FM-UNIT .
  pr CONVERSION .
  pr FM-INT-LIST .

  op downTerm : Term -> [Term] .
  op downModule : Term -> [Module] .
  op downQid : Term -> [Qid] [memo] .
  op downQidList : Term -> [QidList] .
  op downTypes : Term -> [TypeList] .
  op downSorts : Term -> [SortSet] .
  op downSort : Term -> [Sort] .
  op downModExp : Term -> [ModuleExpression] .
  op downParList : Term -> [NeParameterList] .
  op downNat : Term -> [Int] .
  op downString : Term -> [String] .

  op downResultPair : Term -> [ResultPair] .
  op downTerm : TermList -> [Term] .
  op downImports : TermList -> [ImportList] .
  op downSubsorts : TermList -> [SubsortDeclSet] .
  op downOps : TermList -> [OpDeclSet] .
  op downEqCond : TermList -> [EqCondition] .
  op downCond : TermList -> [Condition] .
  op downMbs : TermList -> [MembAxSet] .
  op downEqs : TermList -> [EquationSet] .
  op downRls : TermList -> [RuleSet] .
  op downAttrs : TermList -> [AttrSet] .
  op downAttr : Term -> [Attr] .
  op downHooks : TermList -> [HookList] .
  op downMetaNat : Term -> [Term] .
  op downNat : TermList -> [IntList] .

  op downClasses : TermList -> [ClassDeclSet] .
  op downMsgs : TermList -> [MsgDeclSet] .
  op downSubclasses : TermList -> [SubclassDeclSet] .
  op downClassAttrs : TermList -> [AttrDeclSet] .

  op downStratDcls : TermList -> [StratDeclSet] .
  op downStratDefs : TermList -> [StratDefSet] .

  vars T T' T'' T''' T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 : Term .
  vars TL TL' : TermList .
  vars NTL NTL' : NeTermList .
  vars QI QI' F V L : Qid .
  var  Ct : Constant .
  var  M : Module .
  var  Tp : Type .

  eq downResultPair('`{_`,_`}[T, T']) = {downTerm(T), downTerm(T')} .

  eq downModule('fmod_is_sorts_.____endfm[T1, T2, T3, T4, T5, T6, T7])
    = (fmod downModExp(T1) is
         downImports(T2)
         sorts downSorts(T3) .
         downSubsorts(T4)
         downOps(T5)
         downMbs(T6)
         downEqs(T7)
       endfm) .
  eq downModule('mod_is_sorts_._____endm[T1, T2, T3, T4, T5, T6, T7, T8])
    = (mod downModExp(T1) is
         downImports(T2)
         sorts downSorts(T3) .
         downSubsorts(T4)
         downOps(T5)
         downMbs(T6)
         downEqs(T7)
         downRls(T8)
       endm) .
  eq downModule('omod_is_sorts_.________endom[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11])
    = (omod downModExp(T1) is
         downImports(T2)
         sorts downSorts(T3) .
         downSubsorts(T4)
         downClasses(T5)
         downSubclasses(T6)
         downOps(T7)
         downMsgs(T8)
         downMbs(T9)
         downEqs(T10)
         downRls(T11)
       endom) .
   eq downModule('smod_is_sorts_._____endm[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10])
     = (smod downModExp(T1) is
          downImports(T2)
          sorts downSorts(T3) .
          downSubsorts(T4)
          downOps(T5)
          downMbs(T6)
          downEqs(T7)
          downRls(T8)
          downStratDcls(T9)
          downStratDefs(T10)
        endsm) .

  ----  op _{_} : ModuleExpression NeParameterList -> ModuleExpression [ctor ditto] .
  ----  op _+_ : ModuleExpression ModuleExpression -> ModuleExpression [ctor assoc comm] .
  ----  op _*(_) : ModuleExpression RenamingSet -> ModuleExpression
  eq downModExp(Ct) = downQid(Ct) .
  eq downModExp('_`{_`}[T, T']) = downModExp(T) { downParList(T') } .

  eq downParList(Ct) = downQid(Ct) .
  eq downParList('_`,_[T, T']) = downParList(T), downParList(T') .

  eq downImports('nil.ImportList) = nil .
  eq downImports('__[TL]) = downImports(TL) .
  eq downImports('including_.[T]) = (including downModExp(T) .) .
  eq downImports('extending_.[T]) = (extending downModExp(T) .) .
  eq downImports('protecting_.[T]) = (protecting downModExp(T) .) .
  eq downImports((NTL, NTL')) = (downImports(NTL) downImports(NTL')) .

  eq downSubsorts('none.SubsortDeclSet) = none .
  eq downSubsorts('__[TL]) = downSubsorts(TL) .
  eq downSubsorts('subsort_<_.[T, T']) = (subsort downQid(T) < downQid(T') .) .
  eq downSubsorts((NTL, NTL')) = (downSubsorts(NTL) downSubsorts(NTL')) .

  eq downOps('none.OpDeclSet) = none .
  eq downOps('__[TL]) = downOps(TL) .
  eq downOps('op_:_->_`[_`].[Ct, T, T', T''])
    = (op downQid(Ct) : downTypes(T) -> downQid(T') [downAttrs(T'')] .) .
  eq downOps((NTL, NTL')) = (downOps(NTL) downOps(NTL')) .

  eq downAttrs('none.AttrSet) = none .
  eq downAttrs('__[TL]) = downAttrs(TL) .
  ceq downAttrs((TL, TL')) = (downAttr(TL) downAttrs(TL')) if TL =/= empty /\ TL' =/= empty .
  eq downAttrs(T) = downAttr(T) [owise].

  eq downAttr('assoc.Attr) = assoc .
  eq downAttr('comm.Attr) = comm .
  eq downAttr('idem.Attr) = idem .
  eq downAttr('id[T]) = id(downTerm(T)) .
  eq downAttr('left-id[T]) = left-id(downTerm(T)) .
  eq downAttr('right-id[T]) = right-id(downTerm(T)) .
  eq downAttr('poly[T]) = poly(downNat(T)) .
  eq downAttr('strat[T]) = strat(downNat(T)) .
  eq downAttr('memo.Attr) = memo .
  eq downAttr('prec[T]) = prec(downNat(T)) .
  eq downAttr('gather[T]) = gather(downQidList(T)) .
  eq downAttr('ctor.Attr) = ctor .
  eq downAttr('special[T]) = special(downHooks(T)) .
  eq downAttr('iter.Attr) = iter .
  eq downAttr('frozen[T]) = frozen(downNat(T)) .
  eq downAttr('label[T]) = label(downQid(T)) .
  eq downAttr('config.Attr) = config .
  eq downAttr('object.Attr) = object .
  eq downAttr('msg.Attr) = msg .
  eq downAttr('nonexec.Attr) = nonexec .
  eq downAttr('variant.Attr) = variant .
----  eq downAttr('metadata`(_`)['token[T]]) = metadata(downString(downQid(T))) .
  eq downAttr('owise.Attr) = owise .
  eq downAttr('metadata[T]) = metadata(substr(string(T), 1, find(string(T), "\".String", 0) + (- 1))) .
  eq downAttr('format[T]) = format(downQidList(T)) .

  eq downHooks('__[TL]) = downHooks(TL) .
  eq downHooks('id-hook[T, T']) = id-hook(downQid(T), downQidList(T')) .
  eq downHooks('op-hook[T, T', T'', T3])
    = op-hook(downQid(T), downQid(T'), downQidList(T''), downQid(T3)) .
  eq downHooks('term-hook[T, T']) = term-hook(downQid(T), downTerm(T')) .
  eq downHooks((NTL, NTL')) = downHooks(NTL) downHooks(NTL') .

----  eq downTerm(T) = downTerm(T, qidError('\r 'Error: '\o 'Incorrect 'term. '\n)) .
  eq downTerm(QI) = downQid(QI) .
  eq downTerm('_`[_`][T, T']) = downQid(T)[downTerm(T')] .
  eq downTerm('_`,_[T, TL]) = (downTerm(T), downTerm(TL)) .
  eq downTerm((T, NTL)) = (downTerm(T), downTerm(NTL)) .
  eq downTerm(F[TL])
    = qidError('\r 'Error: '\o 'Incorrect 'term. '\n) [owise] .

  eq downEqCond('_/\_[TL]) = downEqCond(TL) .
  eq downEqCond('_=_[T, T']) = downTerm(T) = downTerm(T') .
  eq downEqCond('_:_[T, T']) = downTerm(T) : downSort(T') .
  eq downEqCond('_:=_[T, T']) = downTerm(T) := downTerm(T') .
  eq downEqCond((NTL, NTL')) = downEqCond(NTL) /\ downEqCond(NTL') .

  eq downCond('_/\_[TL]) = downCond(TL) .
  eq downCond('_=_[T, T']) = downEqCond('_=_[T, T']) .
  eq downCond('_:_[T, T']) = downEqCond('_:_[T, T']) .
  eq downCond('_:=_[T, T']) = downEqCond('_:=_[T, T']) .
  eq downCond('_=>_[T, T']) = downTerm(T) => downTerm(T') .
  eq downCond((NTL, NTL')) = downCond(NTL) /\ downCond(NTL') .

  eq downMbs('none.MembAxSet) = none .
  eq downMbs('__[TL]) = downMbs(TL) .
  eq downMbs('mb_:_`[_`].[T, T', T''])
    = (mb downTerm(T) : downSort(T') [downAttrs(T'')] .) .
  eq downMbs('cmb_:_if_`[_`].[T, T', T'', T3])
    = (cmb downTerm(T) : downSort(T') if downEqCond(T'') [downAttrs(T3)] .) .
  eq downMbs((NTL, NTL')) = (downMbs(NTL) downMbs(NTL')) .

  eq downEqs('none.EquationSet) = none .
  eq downEqs('__[TL]) = downEqs(TL) .
  eq downEqs('eq_=_`[_`].[T, T', T''])
    = (eq downTerm(T) = downTerm(T') [downAttrs(T'')] .) .
  eq downEqs('ceq_=_if_`[_`].[T, T', T'', T3])
    = (ceq downTerm(T) = downTerm(T') if downEqCond(T'') [downAttrs(T3)] .) .
  eq downEqs((NTL, NTL')) = (downEqs(NTL) downEqs(NTL')) .

  eq downRls('none.RuleSet) = none .
  eq downRls('__[TL]) = downRls(TL) .
  eq downRls('rl_=>_`[_`].[T, T', T''])
    = (rl downTerm(T) => downTerm(T') [downAttrs(T'')] .) .
  eq downRls('crl_=>_if_`[_`].[T, T', T'', T3])
    = (crl downTerm(T) => downTerm(T') if downCond(T'') [downAttrs(T3)] .) .
  eq downRls((NTL, NTL')) = (downRls(NTL) downRls(NTL')) .

  eq downSorts('none.EmptyTypeSet) = none .
  eq downSorts(('_;_[TL], TL')) = (downSorts(TL) ; downSorts(TL')) .
  eq downSorts((QI, TL)) = (downSort(QI) ; downSorts(TL)) .
  eq downSorts(empty) = none .

  eq downSort(Ct) = downQid(Ct) .

  eq downTypes('nil.TypeList) = nil .
  eq downTypes(('__[TL], TL')) = (downTypes(TL) downTypes(TL')) .
  eq downTypes((QI, TL)) = (downSort(QI) downTypes(TL)) .
  eq downTypes(empty) = nil .

  eq downQidList('nil.TypeList) = nil .
  eq downQidList(('__[TL], TL')) = (downQidList(TL) downQidList(TL')) .
  eq downQidList((QI, TL)) = (downQid(QI) downQidList(TL)) .
  eq downQidList(empty) = nil .

  eq downQid(Ct)
    = qid(substr(string(getName(Ct)), 1, length(string(getName(Ct))))) .

  eq downMetaNat(QI)
    = qid(substr(string(getName(QI)), 1, length(string(getName(QI))))
          + ".Nat") .

----  eq downNat(T) = downTerm(T, numberError('Error: 'non 'valid 'metaterm)) .
  ceq downNat(QI)
    = trunc(rat(string(getName(QI)), 10))
    if getType(QI) == 'Nat or getType(QI) == 'NzNat .
  ceq downNat(QI)
    = if substr(string(getName(QI)), 0 ,1) == "-"
      then - trunc(rat(substr(string(getName(QI)), 1,
                            length(string(getName(QI)))), 10))
      else trunc(rat(string(getName(QI)), 10))
      fi
    if getType(QI) == 'Int or getType(QI) == 'NzInt .
  eq downNat('0.Zero) = 0 .
  eq downNat('s_['0.Zero]) = 1 .
  ceq downNat(F['0.Zero])
    = trunc(rat(substr(string(F), 3, 2), 10))
    if substr(string(F), 0, 3) = "s_^" .

  eq downString(QI) = substr(string(QI), 1, _-_(length(string(QI)), 2)) .

  eq downNat('__[TL]) = downNat(TL) .
  ceq downNat((TL, TL')) = (downNat(TL) downNat(TL')) if TL =/= empty /\ TL' =/= empty .

  eq downClasses('none.ClassDeclSet) = none .
  eq downClasses('__[TL]) = downClasses(TL) .
  ceq downClasses((TL, TL')) = (downClasses(TL) downClasses(TL')) if TL =/= empty /\ TL' =/= empty .
  eq downClasses('class_|_.[T, T']) = (class downSort(T) | downClassAttrs(T') .) .

  eq downClassAttrs('none.AttrDeclSet) = none .
  eq downClassAttrs('_`,_[TL]) = downClassAttrs(TL) .
  ceq downClassAttrs((TL, TL')) = (downClassAttrs(TL), downClassAttrs(TL')) if TL =/= empty /\ TL' =/= empty .
  eq downClassAttrs('attr_:_[T, T']) = (attr downQid(T) : downSort(T')) .

  eq downSubclasses('none.SubclassDeclSet) = none .
  eq downSubclasses('__[TL]) = downSubclasses(TL) .
  ceq downSubclasses((TL, TL')) = (downSubclasses(TL) downSubclasses(TL')) if TL =/= empty /\ TL' =/= empty .
  eq downSubclasses('subclass_<_.[T, T']) = (subclass downQid(T) < downQid(T') .) .

  eq downMsgs('none.MsgDeclSet) = none .
  eq downMsgs('__[TL]) = downMsgs(TL) .
 ceq downMsgs((TL, TL')) = (downMsgs(TL) downMsgs(TL')) if TL =/= empty /\ TL' =/= empty .
  eq downMsgs('msg_:_->_.[Ct, T, T'])
    = (msg downQid(Ct) : downTypes(T) -> downQid(T') .) .

  eq downStratDcls('none.StratDeclSet) = none .
  eq downStratDcls('__[TL]) = downStratDcls(TL) .
 ceq downStratDcls((TL, TL')) = (downStratDcls(TL) downStratDcls(TL')) if TL =/= empty /\ TL' =/= empty .
  eq downStratDcls('strat_:_@_`[_`].[Ct, T, T', T''])
    = (strat downQid(Ct) : downTypes(T) @ downQid(T') [downAttrs(T'')] .) .

  eq downStratDefs('none.StratDefSet) = none .
  eq downStratDefs('__[TL]) = downStratDefs(TL) .
 ceq downStratDefs((TL, TL')) = (downStratDefs(TL) downStratDefs(TL')) if TL =/= empty /\ TL' =/= empty .
  eq downStratDefs('sd_:=_`[_`].[T, T', T''])
   = (sd downStrategy(T) := downStrategy(T') [downAttrs(T'')] .) .
  eq downStratDefs('csd_:=_if_`[_`].[T, T', T'', T'''])
   = (csd downStrategy(T) := downStrategy(T') if downCond(T'') [downAttrs(T''')] .) .

  op downStrategy : TermList -> Strategy .
  eq downStrategy('empty.StrategyList) = empty .
  eq downStrategy('_`,_[T, T']) = downStrategy(T'), downStrategy(T') .
 ceq downStrategy((TL, TL')) = (downStrategy(TL), downStrategy(TL')) if TL =/= empty /\ TL' =/= empty .
  eq downStrategy('fail.Strategy) = fail .
  eq downStrategy('idle.Strategy) = idle .
  eq downStrategy('all.Strategy) = all .
  eq downStrategy('_`[_`]`{_`}[T, T', T''])
    = downQid(T) [ downSubstitution(T') ]{ downStrategy(T'') } .
  eq downStrategy('top[T]) = top( downStrategy(T) ) .
  eq downStrategy('match_s.t._[T, T']) = match downTerm(T) s.t. downCond(T') .
  eq downStrategy('xmatch_s.t._[T, T']) = xmatch downTerm(T) s.t. downCond(T') .
  eq downStrategy('amatch_s.t._[T, T']) = amatch downTerm(T) s.t. downCond(T') .
  eq downStrategy('_|_[T, T']) = downStrategy(T) | downStrategy(T') .
  eq downStrategy('_;_[T, T']) = downStrategy(T) ; downStrategy(T') .
  eq downStrategy('_or-else_[T, T']) = downStrategy(T) or-else downStrategy(T') .
  eq downStrategy('_+[T]) = downStrategy(T) + .
  eq downStrategy('_?_:_[T, T', T'']) = downStrategy(T) ? downStrategy(T') : downStrategy(T'') .
  eq downStrategy('matchrew_s.t._by_[T, T', T''])
    = matchrew downTerm(T) s.t. downCond(T') by downUsingPairSet(T'') .
  eq downStrategy('xmatchrew_s.t._by_[T, T', T''])
    = matchrew downTerm(T) s.t. downCond(T') by downUsingPairSet(T'') .
  eq downStrategy('amatchrew_s.t._by_[T, T', T''])
    = matchrew downTerm(T) s.t. downCond(T') by downUsingPairSet(T'') .
  eq downStrategy('one[T]) = one( downStrategy(T) ) .
  eq downStrategy('_*[T]) = downStrategy(T) * .
  eq downStrategy('_![T]) = downStrategy(T) ! .
  eq downStrategy('not[T]) = not(downStrategy(T)) .
  eq downStrategy('test[T]) = test(downStrategy(T)) .
  eq downStrategy('try[T]) = try(downStrategy(T)) .

  op downCallStrategy : TermList -> CallStrategy .
  eq downCallStrategy('_`[`[_`]`][T, T']) = downQid(T) [[ downTerm(T') ]] .

  op downUsingPairSet : TermList -> UsingPairSet .
  eq downUsingPairSet('_`,_[TL]) = downUsingPairSet(TL) .
 ceq downUsingPairSet((TL, TL'))
    = (downUsingPairSet(TL), downUsingPairSet(TL'))
    if TL =/= empty /\ TL' =/= empty .
  eq downUsingPairSet('_using_[T, T']) = downQid(T) using downStrategy(T') .

  op downSubstitution : TermList -> Substitution .
  eq downSubstitution('none.Substitution) = none .
  eq downSubstitution('_;_[T, T']) = downSubstitution(T) ; downSubstitution(T') .
 ceq downSubstitution((TL, TL'))
    = (downSubstitution(TL) ; downSubstitution(TL'))
    if TL =/= empty /\ TL' =/= empty .
  eq downSubstitution('_<-_[T, T']) = downQid(T) <- downTerm(T') .
endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

***
*** Parsing of Bubbles
***

*** As discussed in Section~\ref{implementation-introduction}, in Full Maude,
*** the parsing process is split into two phases. In a first stage, the input
*** is parsed using the top-level grammar for Full Maude modules, theories,
*** views, and commands. Once this first stage is completed, we get a term
*** with bubbles in it, which is converted into a module, theory, or view.
*** This unit or view may still have the bubbles in it. We say that a module
*** with bubbles is a premodule, a view with bubbles a preview, and so on. The
*** second stage of the process consists in taking this preunit or preview and
*** converting the bubbles in it into terms by parsing them in the appropriate
*** signatures, obtaining a `valid' unit or view out of it, or otherwise a
*** parsing error. In the case of commands, if they contain any bubble, the
*** same will have to be done. All bubbles have to be parsed in the
*** appropriate signature before any further processing can be done with the
*** module, view, or command in which they appear.

***
*** Parsing of Module Expressions
***

*** Before introducing the \texttt{parseDecl} function, we present some
*** auxiliary functions. For example, the following functions
*** \texttt{parseType}, \texttt{parseSortSet}, and \texttt{parseTypeList}
*** return, respectively, the sort, set of sorts, and list of sorts
*** represented by the term given as argument. Note that these functions, as
*** most of the functions in this module, are partial functions. We assume
*** that the term given as argument is in fact the representation of, for
*** example, a valid sort, or set of sorts, etc. In the case of
*** \texttt{parseDecl} we assume that the term is the representation of a
*** predeclaration.

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod FM-MOD-EXP-PARSING is
  pr MOVE-DOWN .
  pr FM-INT-LIST .
  pr FM-VIEW-EXPR-TO-QID .

  vars T T' T'' T3 T4 : Term .
  vars T? T?' : [Term] .
  var  TL TL' : TermList .
  var  QIL  : QidList .
  var  Ct : Constant .
  var  AtS : AttrSet .
  vars QI F : Qid .
  var  CD? : [Condition] .
  vars S S' : Sort .
  var  TyL : TypeList .

  op parseSort : Term ~> Sort .
  op parseType : Term ~> Type .
  op parseSortSet : Term ~> SortSet .
  op parseTypeList : Term ~> TypeList .
  op parseViewExpression : Term ~> ViewExpression .
  op parseParameterList : Term ~> ParameterList .

  eq parseSort('sortToken[T])
    = if downQid(T) :: Type
      then downQid(T)
      else qidError('\r 'Warning: '\o downQid(T) 'is 'not 'a 'valid 'sort. '\n)
      fi .
  eq parseSort('_`{_`}[T, T'])
    = qid(string(parseSort(T))
          + "{" + string(parameterList2Qid(parseParameterList(T'))) + "}") .
  eq parseSort(T) = qidError('\r 'Warning: '\o 'invalid 'sort. '\n) [owise] .

  eq parseType('`[_`][T])
    ---- = kind(parseSort(T)) .
    = qid("[" + string(parseSort(T)) + "]") .
  eq parseType(T) = parseSort(T) [owise] .

  eq parseSortSet('__[T, T']) = (parseSort(T) ; parseSortSet(T')) .
  eq parseSortSet(T) = parseSort(T) [owise].

  eq parseTypeList('__[T, T']) = (parseType(T) parseTypeList(T')) .
  eq parseTypeList(T) = parseType(T) [owise] .

  eq parseViewExpression('viewToken[T])
    = if downQid(T) :: Sort
      then downQid(T)
      else qidError('\r 'Warning: '\o downQid(T) 'is 'not 'a 'valid 'sort. '\n)
      fi .
  eq parseViewExpression('_`{_`}[T, T'])
    = parseViewExpression(T){parseParameterList(T')} .
  eq parseViewExpression(T)
    = qidError('\r 'Warning: '\o 'invalid 'view 'expression. '\n)
    [owise] .

  eq parseParameterList('_`,_[T, T'])
    = parseViewExpression(T), parseParameterList(T') .
  eq parseParameterList(T) = parseViewExpression(T) [owise] .

*** The function \texttt{parseModExp} takes a term representing a
*** module expression and returns the corresponding term in sort
*** \texttt{ModuleExpression}. In case of adding new constructors for module
*** expressions, as it will be done in Section~\ref{extension}, new equations d
*** efining the semantics of the function on them will have to be given.

  op parseModExp : Term -> ModuleExpression .
  op parseMaps : Term -> RenamingSet .

  op parseAttrs : Term -> AttrSet .

  eq parseModExp('token[T]) = downQid(T) .
  eq parseModExp('`(_`)[T]) = parseModExp(T) .
  eq parseModExp('_`{_`}[T, T'])
    = _`{_`}(parseModExp(T), parseParameterList(T')) .
  eq parseModExp('_*`(_`)[T, T']) = _*`(_`)(parseModExp(T), parseMaps(T')) .
  eq parseModExp('_+_[T, T']) = parseModExp(T) + parseModExp(T') .
  eq parseModExp('TUPLE`[_`]['token[T]]) = TUPLE[parseNat(T)] .
  eq parseModExp('POWER`[_`]['token[T]]) = POWER[parseNat(T)] .

  eq parseMaps('_`,_[T, T']) = (parseMaps(T), parseMaps(T')) .

  eq parseMaps('sort_to_[T, T']) = (sort parseType(T) to parseType(T')) .
  eq parseMaps('label_to_['token[T], 'token[T']])
    = (label downQid(T) to downQid(T')) .
  eq parseMaps('class_to_[T, T']) = (class parseType(T) to parseType(T')) .
  eq parseMaps('attr_._to_[T, 'token[T'], 'token[T'']])
    = (attr downQid(T') . parseType(T) to downQid(T'')) .
  eq parseMaps('msg_to_['token[T], 'token[T']])
    = (msg downQid(T) to downQid(T')) .
  eq parseMaps('msg_:_->_to_['token[T], T', T'', 'token[T3]])
    = (msg downQid(T) : parseTypeList(T') -> parseType(T'') to downQid(T3)) .
  eq parseMaps('msg_:`->_to_['token[T], T', 'token[T'']])
    = (msg downQid(T) : nil -> parseType(T') to downQid(T'')) .
  eq parseMaps('op_to_`[_`]['token[T], 'token[T'], T''])
    = (op downQid(T) to downQid(T') [parseAttrs(T'')]) .
  eq parseMaps('op_:_->_to_`[_`]['token[T], T', T'', 'token[T3], T4])
    = (op downQid(T) : parseTypeList(T') -> parseType(T'') to downQid(T3)
            [parseAttrs(T4)]) .
  eq parseMaps('op_:`->_to_`[_`]['token[T], T', 'token[T''], T3])
    = (op downQid(T) : nil -> parseType(T') to downQid(T'')
          [parseAttrs(T3)]) .
  eq parseMaps('op_:_~>_to_`[_`]['token[T], T', T'', 'token[T3], T4])
    = (op downQid(T) : kind(parseTypeList(T')) -> kind(parseType(T''))
            to downQid(T3) [parseAttrs(T4)]) .
  eq parseMaps('op_:`~>_to_`[_`]['token[T], T', 'token[T''], T3])
    = (op downQid(T) : nil -> kind(parseType(T')) to downQid(T'')
          [parseAttrs(T3)]) .
  eq parseMaps('op_to_['token[T], 'token[T']])
    = (op downQid(T) to downQid(T') [none]) .
  eq parseMaps('op_:_->_to_['token[T], T', T'', 'token[T3]])
    = (op downQid(T) : parseTypeList(T') -> parseType(T'') to downQid(T3)
          [none]) .
  eq parseMaps('op_:`->_to_['token[T], T', 'token[T'']])
    = (op downQid(T) : nil -> parseType(T') to downQid(T'') [none]) .
  eq parseMaps('op_:_~>_to_['token[T], T', T'', 'token[T3]])
    = (op downQid(T) : kind(parseTypeList(T')) -> kind(parseType(T''))
          to downQid(T3) [none]) .
  eq parseMaps('op_:`~>_to_['token[T], T', 'token[T'']])
    = (op downQid(T) : nil -> kind(parseType(T')) to downQid(T'') [none]) .
  eq parseMaps('strat_to_['token[T], 'token[T']])
    = (strat downQid(T) to downQid(T')) .
  eq parseMaps('strat_:_@_to_['token[T], T', T'', 'token[T3]])
    = (strat downQid(T) : parseTypeList(T') @ parseType(T'') to downQid(T3)) .
  eq parseMaps('strat_@_to_['token[T], T', 'token[T'']])
    = (strat downQid(T) : nil @ parseType(T') to downQid(T'')) .

  eq parseAttrs('__[T, T']) = (parseAttrs(T) parseAttrs(T')) .
  eq parseAttrs('assoc.@Attr@) = assoc .
  eq parseAttrs('associative.@Attr@) = assoc .
  eq parseAttrs('comm.@Attr@) = comm .
  eq parseAttrs('commutative.@Attr@) = comm .
  eq parseAttrs('idem.@Attr@) = idem .
  eq parseAttrs('idempotent.@Attr@) = idem .
  eq parseAttrs('id:_[T]) = none .
  eq parseAttrs('identity:_[T]) = none .
  eq parseAttrs('left`id:_[T]) = none .
  eq parseAttrs('left`identity:_[T]) = none .
  eq parseAttrs('right`id:_[T]) = none .
  eq parseAttrs('right`identity:_[T]) = none .
  eq parseAttrs('poly`(_`)[T]) = poly(parseInt(T)) .
  eq parseAttrs('strat`(_`)[T]) = none .
  eq parseAttrs('strategy`(_`)[T]) = none .
  eq parseAttrs('memo.@Attr@) = none .
  eq parseAttrs('memoization.@Attr@) = none .
  eq parseAttrs('prec_['token[T]]) = prec(parseNat(T)) .
  eq parseAttrs('precedence_['token[T]]) = prec(parseNat(T)) .
  eq parseAttrs('prec_['`(_`)['token[T]]]) = prec(parseNat(T)) .
  eq parseAttrs('precedence_['`(_`)['token[T]]]) = prec(parseNat(T)) .
  eq parseAttrs('gather`(_`)['neTokenList[T]]) = gather(downQidList(T)) .
  eq parseAttrs('gathering`(_`)['neTokenList[T]]) = gather(downQidList(T)) .
  eq parseAttrs('format`(_`)['neTokenList[T]]) = none .
  eq parseAttrs('ctor.@Attr@) = ctor .
  eq parseAttrs('constructor.@Attr@) = ctor .
  eq parseAttrs('frozen.@Attr@) = none .
  eq parseAttrs('frozen`(_`)[T]) = none .
  eq parseAttrs('iter.@Attr@) = iter .
  eq parseAttrs('ditto.@Attr@) = ditto .
  eq parseAttrs('special`(_`)[T]) = parseSpecial(parseHookList(T)) .
  eq parseAttrs('config.@Attr@) = config .
  eq parseAttrs('object.@Attr@) = object .
  eq parseAttrs('msg.@Attr@) = msg .
  eq parseAttrs('message.@Attr@) = msg .
  eq parseAttrs('metadata_['token[T]]) = metadata(downString(downQid(T))) .
  eq parseAttrs('variant.@Attr@) = variant .
  eq parseAttrs('nonexec.@Attr@) = nonexec .

  op parseSpecial : Set<Hook> -> Attr .
  op parseHookList : Term -> Set<Hook> .
  op hookList : Set<Hook> -> HookList .
  sort Set<Hook> .
  subsort Hook < Set<Hook> .
  op none : -> Set<Hook> .
  op _._ : Set<Hook> Set<Hook> -> Set<Hook> [assoc comm id: none] .
  var  SH : Set<Hook> .
  var  H : Hook .

  eq parseSpecial(none) = none .
  eq parseSpecial(SH) = special(hookList(SH)) [owise] .

  eq parseHookList('__[T, TL]) = parseHookList(T) . parseHookList(TL) .
  eq parseHookList('id-hook_['token[T]]) = id-hook(downQid(T), nil) .
  eq parseHookList('id-hook_`(_`)['token[T], 'neTokenList[T']])
    = id-hook(downQid(T), downQidList(T')) .
  eq parseHookList(
       'op-hook_`(_:_->_`)[
          'token[T], 'token[T'], 'neTokenList[T''], 'token[T3]])
    = op-hook(downQid(T), downQid(T'), downTypes(T''), downQid(T3)) .
  eq parseHookList('op-hook_`(_:`->_`)['token[T], 'token[T'], 'token[T'']])
    = op-hook(downQid(T), downQid(T'), nil, downQid(T'')) .
  eq parseHookList(
       'op-hook_`(_:_~>_`)[
          'token[T], 'token[T'], 'neTokenList[T''], 'token[T3]])
    = op-hook(downQid(T), downQid(T'), downTypes(T''), downQid(T3)) .
  eq parseHookList('op-hook_`(_:`~>_`)['token[T], 'token[T'], 'token[T'']])
    = op-hook(downQid(T), downQid(T'), nil, downQid(T'')) .
  eq parseHookList('term-hook_`(_`)['token[T], T']) = none .

  eq hookList(H) = H .
  eq hookList(H . SH) = H hookList(SH) [owise] .

*** Given a term representing a machine integer, the function
*** \texttt{parseInt} returns the corresponding integer.

  op parseNat : Term -> Nat .

  op parseInt : Term -> Int .
  op parseInt : TermList -> IntList .

  eq parseInt(('neTokenList['__[TL]], TL')) = parseInt(TL) parseInt(TL') .
  eq parseInt(('neTokenList[QI], TL)) = parseInt(QI) parseInt(TL) .
  eq parseInt(empty) = nil .

  eq parseInt((T, TL)) = parseInt(T) parseInt(TL) [owise] .
  eq parseInt(nil) = nil .

  eq parseInt(Ct)
    = downNat(
        qid(substr(string(getName(Ct)), 1, length(string(getName(Ct))))
            + ".Int")) .

  eq parseNat(Ct)
    = downNat(
        qid(substr(string(getName(Ct)), 1, length(string(getName(Ct))))
            + ".Nat")) .

endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

***
*** Parsing of Bubbles
***

*** In the following module \texttt{BUBBLE-PARSING}, the definitions for the
*** basic processing of bubbles are introduced. In it we declare a function
*** \texttt{solveBubbles} which takes a bubble and some other arguments and
*** returns the term resulting from parsing it.


-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod BUBBLE-PARSING is
  pr DATABASE .
  pr MOVE-UP .
  pr MOVE-DOWN .
  pr FM-MOD-EXP-PARSING .
  pr FM-PRINT-SYNTAX-ERROR .

  vars T T' : Term .
  vars M M' : Module .
  var  B : Bool .
  var  QIL : QidList .
  vars DB DB' : Database .
  var  TL : TermList .
  var  S : Sort .
  var  QI QI' F : Qid .
  var  OPDS : OpDeclSet .
  var  VDS : VariableSet .
  var  C : Constant .
  var  V : Variable .
  var  N : Nat .
  var  Tp : Type .
  var  RP : [ResultPair] .
  var  MN : ModuleName .
  var  ME : ModuleExpression .
  var  U : Module .
  var  Cond : Condition .

  op resultPairError : QidList -> [ResultPair] [ctor] .

*** As we shall see in Section~\ref{evaluation}, a declaration importing the
*** predefined module \texttt{UP} (see Section~\ref{non-built-in-predefined})
*** is added to all modules importing the \texttt{META-LEVEL} module. The
*** \texttt{solveBubbles} function is called with a `flag' indicating whether
*** the module can contain calls to the \texttt{up} function or not. Thus,
*** when we call \texttt{metaParse} with some bubble and the module in which
*** such bubble has to be parsed, if there are occurrences of the function
*** \texttt{up} in it, they will be of the form \verb~'token[T]]~ or
*** \verb~'up['token[T], 'bubble[T']]~ for terms \texttt{T} and \texttt{T'}.
*** The function \texttt{solveUps} will evaluate them.

  op solveBubbles : Term Module Bool VariableSet Database -> [Term] .
  op solveUps : TermList Database -> [TermList] .
  op solveUpsCondition : Condition Database -> Condition .
  op solveUpsModExp : TermList Database -> [TermList] .

  eq solveBubbles('ububble[T], M, true, VDS, DB)
    = solveBubbles('bubble[T], M, true, VDS, DB) .
  ceq solveBubbles('bubble[T], M, true, VDS, DB)
    *** if META-LEVEL is a submodule the ups need to be solved
    = if RP :: ResultPair
      then solveUps(getTerm(RP), DB)
      else qidError('\r 'Warning: '\o printSyntaxError(RP, QIL) '\n
                    '\r 'Error: '\o 'no 'parse 'for QIL '\n)
      fi
    if QIL := downQidList(T)
    /\ RP := metaParse(M, VDS, QIL, anyType) .

  eq solveBubbles('ububble[T], M, false, VDS, DB)
    = solveBubbles('bubble[T], M, false, VDS, DB) .
  ceq solveBubbles('bubble[T], M, false, VDS, DB)
    = if RP :: ResultPair
      then getTerm(RP)
      else qidError('\r 'Warning: '\o printSyntaxError(RP, QIL) '\n
                    '\r 'Error: '\o 'no 'parse 'for QIL '\n)
      fi
    if QIL := downQidList(T)
    /\ RP := metaParse(M, VDS, QIL, anyType) .

*** The \texttt{solveBubbles1} function is in charge of calling the function
*** \texttt{metaParse}. The flag indicating the inclusion of the module
*** \texttt{META-LEVEL} in the module in which the term appears decides
*** whether the function \texttt{solveUps} is called or not, so the extra
*** price of searching for calls to the \texttt{up} function is paid only
*** when an occurrence of the function is possible. This function takes care
*** of the occurrences of the \texttt{up} function that may exist in such
*** bubbles.

*** The function \texttt{solveUps} goes through the term looking for a term
*** with \texttt{'up} as top operator and \texttt{'token} as top operator of
*** its unique argument if there is only one argument, or with \texttt{'token}
*** and \texttt{'bubble} as top operators of its first and second arguments,
*** respectively, if there are two. If a term of the form
*** \mbox{\texttt{'up['token[T]]}} is reached, it is replaced by the
*** metarepresentation of the flat version of the module in the database with
*** the name given by the token. If a term of form
*** \mbox{\texttt{'up['token[T], 'bubble[T']]}} is reached, the
*** metarepresentation of the result of parsing the bubble in the signature
*** of the module with the name given by the token, after solving possible
*** nested calls to the \texttt{up} function, is returned.

  eq solveUps(QI, DB) = QI .
  eq solveUps(F[TL], DB) = F[solveUps(TL, DB)] [owise] .
  ceq solveUps((T, TL), DB)
    = (solveUps(T, DB), solveUps(TL, DB))
    if TL =/= empty .

  eq solveUps('upModule['token[T]], DB)
    = solveUpsModExp('upModule['token[T]], DB) .
  eq solveUps('upModule['`(_`)[T]], DB)
    = solveUpsModExp('upModule['`(_`)[T]], DB) .
  eq solveUps('upModule['_`{_`}[T, T']], DB)
    = solveUpsModExp('upModule['_`{_`}[T, T']], DB) .
  eq solveUps('upModule['_*`(_`)[T, T']], DB)
    = solveUpsModExp('upModule['_*`(_`)[T, T']], DB) .
  eq solveUps('upModule['_+_[T, T']], DB)
    = solveUpsModExp('upModule['_+_[T, T']], DB) .
  eq solveUps('upModule['TUPLE`[_`]['token[T]]], DB)
    = solveUpsModExp('upModule['TUPLE`[_`]['token[T]]], DB) .
  eq solveUps('upModule['POWER`[_`]['token[T]]], DB)
    = solveUpsModExp('upModule['POWER`[_`]['token[T]]], DB) .

  eq solveUpsCondition(T = T' /\ Cond, DB)
    = solveUps(T, DB) = solveUps(T', DB) /\ solveUpsCondition(Cond, DB) .
  eq solveUpsCondition(T : S /\ Cond, DB)
    = solveUps(T, DB) : S /\ solveUpsCondition(Cond, DB) .
  eq solveUpsCondition(T := T' /\ Cond, DB)
    = T := solveUps(T', DB) /\ solveUpsCondition(Cond, DB) .
  eq solveUpsCondition(T => T' /\ Cond, DB)
    = solveUps(T, DB) => solveUps(T', DB) /\ solveUpsCondition(Cond, DB) .
  eq solveUpsCondition(nil, DB) = nil .

  ceq solveUpsModExp('upModule[T], DB)
    = up(getFlatModule(MN, DB'))
    if < DB' ; MN > := evalModExp(parseModExp(T), DB)
    /\ unitInDb(MN, DB') .
  ceq solveUpsModExp('upModule[T], DB)
    = qidError('\r 'Error: '\o 'Module header2QidList(MN) 'not 'in 'database. '\n)
    if MN := parseModExp(T)
    [owise] .

  eq solveUps('upTerm[T, 'ububble[T']], DB)
    = solveUps('upTerm[T, 'bubble[T']], DB) .
  eq solveUps('upTerm['token[T], 'bubble[T']], DB)
    = solveUpsModExp('upTerm['token[T], 'bubble[T']], DB) .
  eq solveUps('upTerm['`(_`)[T], 'bubble[T']], DB)
    = solveUpsModExp('upTerm['`(_`)[T], 'bubble[T']], DB) .
  eq solveUps('upTerm['_`{_`}[T, T'], 'bubble[T']], DB)
    = solveUpsModExp('upTerm['_`{_`}[T, T'], 'bubble[T']], DB) .
  eq solveUps('upTerm['_*`(_`)[T, T'], 'bubble[T']], DB)
    = solveUpsModExp('upTerm['_*`(_`)[T, T'], 'bubble[T']], DB) .
  eq solveUps('upTerm['_+_[T, T'], 'bubble[T']], DB)
    = solveUpsModExp('upTerm['_+_[T, T'], 'bubble[T']], DB) .
  eq solveUps('upTerm['TUPLE`[_`]['token[T]], 'bubble[T']], DB)
    = solveUpsModExp('upTerm['TUPLE`[_`]['token[T]], 'bubble[T']], DB) .
  eq solveUps('upTerm['POWER`[_`]['token[T]], 'bubble[T']], DB)
    = solveUpsModExp('upTerm['POWER`[_`]['token[T]], 'bubble[T']], DB) .

  eq solveUpsModExp('upTerm[T, 'ububble[T']], DB)
    = solveUpsModExp('upTerm[T, 'bubble[T']], DB) .
  ceq solveUpsModExp('upTerm[T, 'bubble[T']], DB)
    = if included('META-MODULE, getImports(getInternalModule(MN, DB')), DB')
      then if metaParse(U, VDS, QIL, anyType) :: ResultPair
           then up(solveUps(getTerm(metaParse(U, VDS, QIL, anyType)), DB'))
           else qidError('\r 'Warning: '\o
                  'No 'parse 'for 'argument 'of 'up
                  printSyntaxError(metaParse(U, VDS, QIL, anyType), QIL)
                  '\n)
           fi
      else if metaParse(U, VDS, QIL, anyType) :: ResultPair
           then up(getTerm(metaParse(U, VDS, QIL, anyType)))
           else qidError('\r 'Warning: '\o
                  'No 'parse 'for 'argument 'of 'up
                  printSyntaxError(metaParse(U, VDS, QIL, anyType), QIL)
                  '\n)
           fi
      fi
    if < DB' ; MN > := evalModExp(parseModExp(T), DB)
    /\ U := getFlatModule(MN, DB')
    /\ VDS := getVars(MN, DB')
    /\ QIL := downQidList(T').
  ceq solveUpsModExp('upTerm[T, 'bubble[T']], DB)
    = qidError('\r 'Error: 'op '\o 'Module header2QidList(ME) 'not 'in 'database. '\n)
    if ME := parseModExp(T)
    [owise] .

  eq solveUps('`[_`][QI], DB) = '`[_`][QI] .
  ceq solveUps('`[_`]['token[T]], DB)
    = up(getFlatModule(QI, database(evalModExp(QI, DB))))
    if QI := downQid(T) .
  eq solveUps('`[_`][F[TL]], DB) = '`[_`][F[solveUps(TL, DB)]] [owise] .

endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

***
*** Parsing the Bubbles in a Module
***

*** The \texttt{solveBubbles} function defined in the
*** \texttt{UNIT-BUBBLE-PARSING} module takes a term of sort \texttt{Module} (a
*** preunit in fact) and a signature, and returns the unit resulting from the
*** evaluation (parsing) of all the bubbles in it.

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

view AttrSet from TRIV to META-LEVEL is
  sort Elt to AttrSet .
endv


fmod UNIT-BUBBLE-PARSING is
  pr BUBBLE-PARSING .
  pr DATABASE .
  pr MOVE-UP .
  pr MOVE-DOWN .
  pr FM-PRINT-SYNTAX-ERROR .
  pr FM-PARSE-STRATEGY .

  vars T T' T'' T1 T2 T3 T4 : Term .
  vars T? T?' : [Term] .
  vars TL TL' TL'' : TermList .
  vars TL? TL?' : [TermList] .
  var  B : Bool .
  vars M M' M'' : Module .
  var  DB : Database .
  vars PU U U' : Module .
  var  K : Kind .
  var  KS : KindSet .
  vars S S' : Sort .
  var  SS : SortSet .
  var  VE : ViewExpression .
  vars Ty Ty' Tp : Type .
  vars TyL TyL' : TypeList .
  var  At : Attr .
  vars AtS AtS' AtS'' AtS1 AtS2 : AttrSet .
  var  NL : IntList .
  vars Q QI QI' QI'' QI3 QI4 QI5 V F L : Qid .
  vars QIL QIL' QIL1 QIL2 QIL3 : QidList .
  var  Vs : QidSet .
  var  I : Nat .
  var  Hk : Hook .
  var  HkL : HookList .
  var  MAS : MembAxSet .
  var  Eq : Equation .
  var  EqS : EquationSet .
  var  Rl : Rule .
  var  RlS Rls : RuleSet .
  var  OPD : OpDecl .
  vars OPDS OPDS' OPDS'' : OpDeclSet .
  var  VDS : VariableSet .
  var  CD? : [Condition] .
  var  Ct : Constant .
  var  RP : [ResultPair] .
  var  St : String .
  var  SDfs : StratDefSet .
  var  SDcs StratDecls : StratDeclSet .
  var  Strat : Strategy .
  vars Strat? Strat1? Strat2? : Strategy? .

*** In the parsing of bubbles themselves, we consider three different cases:
*** The case of having one single bubble in which no context is
*** considered (used to parse bubbles in term maps in views and in the
*** special attributes of operators); the case of two bubbles to be parsed in
*** the same connected component (used for bubbles in equations and rules),
*** and the case of one bubble to be parsed in a specific sort (used for the
*** bubbles appearing in the identity element attributes in the declarations
*** of operators, and in membership axioms). These three cases are reduced to
*** the case of one single bubble without context, which is handled by the
*** function \texttt{solveBubbles3}.

  op solveBubblesEq : Term Term Module Bool VariableSet Database -> Term .
  op solveBubblesCEq : Term Term Module Bool VariableSet Database -> Term .
  op solveBubblesRl : Term Term Module Bool VariableSet Database -> Term .
  op solveBubblesCRl : Term Term Module Bool VariableSet Database -> Term .
  op solveBubbles2 : Term [Type] Module Bool VariableSet Database -> Term .
  op solveBubblesCond : Term Module Module Bool VariableSet Database -> [Condition] .

  op conditionError : QidList -> [Condition] [ctor format (r o)] .

*** The case of two bubbles, generated in the case of equations and rules, is
*** reduced to the case with one single bubble using the polymorphic operator
*** \verb~_==_~ and enclosing each of the bubbles in parentheses. Below, we
*** shall see how after calling this function the terms corresponding to each
*** of the bubbles is extracted.

  ceq solveBubblesEq(T, T', M, B, VDS, DB)
    = if RP :: ResultPair
      then if B
           then solveUps(getTerm(RP), DB)
           else getTerm(RP)
           fi
      else qidError('\r 'Warning:
                 '\o printSyntaxError(RP, QIL '= QIL') '\n
                 '\r 'Error: '\o 'no 'parse 'for 'eq QIL '\s '= '\s QIL' '\n)
      fi
    if M' := addOps(op 'eq_=_. : 'Universal 'Universal -> '@@@ [poly(1 2) gather('& '&)] .,
               addSorts('@@@, M))
       /\ QIL := downQidList(T)
       /\ QIL' := downQidList(T')
       /\ RP := metaParse(M', VDS, 'eq QIL '= QIL' '., '@@@) .

  ceq solveBubblesCEq(T, T', M, B, VDS, DB)
    = if RP :: ResultPair
      then if B
           then solveUps(getTerm(RP), DB)
           else getTerm(RP)
           fi
      else qidError('\r 'Warning:
                 '\o printSyntaxError(RP, '`( QIL '`) '= '`( QIL' '`)) '\n
                 '\r 'Error: '\o 'no 'parse 'for 'ceq QIL '\s '= '\s QIL' '\n)
      fi
    if M' := addOps(op 'eq_=_. : 'Universal 'Universal -> '@@@ [poly(1 2) gather('& '&)] .,
               addSorts('@@@, M))
       /\ QIL := downQidList(T)
       /\ QIL' := downQidList(T')
       /\ RP := metaParse(M', VDS, 'eq QIL '= QIL' '., '@@@) .

  eq solveBubblesRl('ububble[T], 'ububble[T'], M, B, VDS, DB)
    = solveBubblesRl(T, T', M, B, VDS, DB) .
  ceq solveBubblesRl(T, T', M, B, VDS, DB)
    = if RP :: ResultPair
      then if B
           then solveUps(getTerm(RP), DB)
           else getTerm(RP)
           fi
      else qidError('\r 'Warning:
                 '\o printSyntaxError(RP, QIL '=> QIL') '\n
                 '\r 'Error: '\o 'no 'parse 'for 'rl QIL '\s '=> '\s QIL' '\n)
      fi
    if M' := addOps(op 'rl_=>_. : 'Universal 'Universal -> '@@@ [poly(1 2) gather('& '&)] .,
               addSorts('@@@, M))
       /\ QIL := downQidList(T)
       /\ QIL' := downQidList(T')
       /\ RP := metaParse(M', VDS, 'rl QIL '=> QIL' '., '@@@)
    [owise] .
  ceq solveBubblesCRl(T, T', M, B, VDS, DB)
    = if RP :: ResultPair
      then if B
           then solveUps(getTerm(RP), DB)
           else getTerm(RP)
           fi
      else qidError('\r 'Warning:
                 '\o printSyntaxError(RP, QIL '=> QIL') '\n
                 '\r 'Error: '\o 'no 'parse 'for 'crl QIL '\s '=> '\s QIL' '\n)
      fi
    if M' := addOps(op 'rl_=>_. : 'Universal 'Universal -> '@@@ [poly(1 2) gather('& '&)] .,
               addSorts('@@@, M))
       /\ QIL := downQidList(T)
       /\ QIL' := downQidList(T')
       /\ RP := metaParse(M', VDS, 'rl QIL '=> QIL' '., '@@@)
    [owise] .

  ceq solveBubbles2(T, T?:Type?, M, true, VDS, DB)
    = if RP :: ResultPair
      then solveUps(getTerm(RP), DB)
      else qidError('\r 'Warning:
                 '\o printSyntaxError(RP, QIL) '\n
                 '\r 'Error: 'No 'parse 'for QIL '\n)
      fi
    if QIL := downQidList(T)
       /\ RP := metaParse(M, VDS, QIL, T?:Type?) .
  ceq solveBubbles2(T, T?:Type?, M, false, VDS, DB)
    = if RP :: ResultPair
      then getTerm(RP)
      else qidError('\r 'Warning: '\o printSyntaxError(RP, QIL) '\n
                 '\r 'Error: 'No 'parse 'for QIL '\n)
      fi
    if QIL := downQidList(T)
       /\ RP := metaParse(M, VDS, QIL, T?:Type?) .

  op addInfoConds : Module -> [Module] .
  op addInfoConds : Module SortSet -> Module .

  eq addInfoConds(M) = addInfoConds(M, getAllSorts(M)) .

  eq addInfoConds(M, '@Token@ ; SS) = addInfoConds(M, SS) .
  eq addInfoConds(M, '@Bubble@ ; SS) = addInfoConds(M, SS) .
  eq addInfoConds(M, '@UBubble@ ; SS) = addInfoConds(M, SS) .
  eq addInfoConds(M, '@StBubble@ ; SS) = addInfoConds(M, SS) .
  eq addInfoConds(M, '@EqLBubble@ ; SS) = addInfoConds(M, SS) .
  eq addInfoConds(M, '@RlLBubble@ ; SS) = addInfoConds(M, SS) .
  eq addInfoConds(M, '@SdLBubble@ ; SS) = addInfoConds(M, SS) .
  eq addInfoConds(M, '@RCBubble@ ; SS) = addInfoConds(M, SS) .
  eq addInfoConds(M, '@RBubble@ ; SS) = addInfoConds(M, SS) .
  eq addInfoConds(M, S ; SS)
    = addInfoConds(
        addOps(op qid(string(S)) : nil -> '@Sort@ [ctor] .
               op '_:_ : S '@Sort@ -> '@Condition@ [ctor prec(71)] ., M),
        SS)
    [owise] .
  eq addInfoConds(M, none)
    = addOps(op '_/\_ : '@Condition@ '@Condition@ -> '@Condition@
                               [ctor assoc prec(73)] .
             op '_=_  : 'Universal 'Universal -> '@Condition@
                               [ctor poly(1 2) gather('& '&) prec(71)] .
             op '_:=_ : 'Universal 'Universal -> '@Condition@
                               [ctor poly(1 2) gather('& '&) prec(71)] .
             op '_=>_ : 'Universal 'Universal -> '@Condition@
                               [ctor poly(1 2) gather('& '&) prec(71)] .,
        addSorts('@Condition@ ; '@Sort@,
          if 'Bool in getSorts(M)
          then addSubsorts(subsort 'Bool < '@Condition@ ., M)
          else M
          fi)) .

  ceq solveBubblesCond(T, M, M', B, VDS, DB)
    = if 'Bool in getSorts(M)
         and-then metaParse(M, VDS, QIL, 'Bool) :: ResultPair
      then if B
           then solveUps(getTerm(metaParse(M, VDS, QIL, 'Bool)), DB) = 'true.Bool
           else getTerm(metaParse(M, VDS, QIL, 'Bool)) = 'true.Bool
           fi
      else if metaParse(M', VDS, QIL, '@Condition@) :: ResultPair
           then if B
                then solveUpsCondition(parseCond(getTerm(metaParse(M', VDS, QIL, '@Condition@))), DB)
                else parseCond(getTerm(metaParse(M', VDS, QIL, '@Condition@)))
                fi
           else conditionError('\r 'Warning: '\o
                  printSyntaxError(metaParse(M', VDS, QIL, '@Condition@), QIL) '\n)
           fi
      fi
    if QIL := downQidList(T) .

  op parseCond : Term -> Condition .

  eq parseCond('_/\_[T, T']) = parseCond(T) /\ parseCond(T') .
  eq parseCond('_=_[T, T']) = T = T' .
  eq parseCond('_:_[T, T']) = T : getName(T') .
  eq parseCond('_:=_[T, T']) = T := T' .
  eq parseCond('_=>_[T, T']) = T => T' .
  eq parseCond(T) = T = 'true.Bool [owise] .

*** Since bubbles can only appear in the identity or special attributes in the
*** declaration of operators, in equations, membership axioms, and rules, the
*** evaluation of bubbles on a preunit is reduced to calls to the
*** \texttt{solveBubbles} functions on each of these sTS of declarations.

  op solveBubblesMod : Module OpDeclSet RuleSet Module Bool VariableSet Database -> Module .
  op solveBubblesModAux : Module RuleSet Module Module Bool VariableSet Database -> Module .

  op solveBubbles : EquationSet Module [Module] Bool VariableSet Database -> EquationSet .
  op solveBubbles : RuleSet Module [Module] Bool VariableSet Database -> RuleSet .
  op solveBubbles : MembAxSet Module [Module] Bool VariableSet Database -> MembAxSet .
  op solveBubbles : StratDefSet Module [Module] Bool VariableSet Database -> StratDefSet .
  op solveBubbles : Condition Module Bool VariableSet Database -> Condition .
  op solveBubblesOps : OpDeclSet OpDeclSet Module Module -> OpDeclSet .
  op solveBubblesOps : OpDeclSet OpDeclSet Module -> OpDeclSet .
  op solveBubblesOpsAux : OpDeclSet Module -> OpDeclSet .
  op solveBubblesAts : AttrSet TypeList Type Module -> AttrSet .
  op solveBubblesHooks : HookList Type Module -> HookList .

  ceq solveBubblesMod(PU, OPDS, Rls, M, B, VDS, DB)
    = solveBubblesModAux( ---- we need to parse rls before solving strategies' bubbles
        setOps(
          setEqs(
            setMbs(
              setRls(PU,
                solveBubbles(getRls(PU), M, M'', B, VDS, DB)),
              solveBubbles(getMbs(PU), M, M'', B, VDS, DB)),
            solveBubbles(getEqs(PU), M, M'', B, VDS, DB)),
          solveBubblesOps(getOps(PU), OPDS, M)),
        Rls, M, M'', B, VDS, DB)
    if M'' := addInfoConds(M) .

  eq solveBubblesModAux(PU, Rls, M, M', B, VDS, DB)
    = setStratDefs(PU,
        solveBubbles(
          getStratDefs(PU),
          setRls(addStratDcls(getStratDcls(PU), M), Rls getRls(PU)),
          M', B, VDS, DB)) .
  eq solveBubblesModAux(unitError(QIL), Rls, M, M', B, VDS, DB)
    = unitError(QIL) .

*** To avoid the parsing ambiguities in the identity elements we add the sort
*** of the operator to be used as context in which doing the parsing. We
*** assume that the term given as identity element of an operator is in the
*** kind of the sort of such operator.

  eq solveBubblesOps(OPDS, OPDS', M)
    = solveBubblesOps(OPDS, OPDS',
        setSubsorts(
          setSorts(emptyFModule('DUMMY), getSorts(M)), getSubsorts(M)), M) .

  ceq solveBubblesOps(op F : TyL -> Ty [ditto AtS] . op F : TyL' -> Ty' [AtS'] . OPDS, OPDS', M, M')
    = solveBubblesOps(
        op F : TyL -> Ty [AtS removeCtorMetadata(AtS'')] . op F : TyL' -> Ty' [AtS''] . OPDS,
        OPDS', M, M')
    if not ditto in AtS'
    /\ sameKind(M, TyL Ty, TyL' Ty')
    /\ AtS'' := AtS' .
  ceq solveBubblesOps(op F : TyL -> Ty [ditto AtS] . OPDS, op F : TyL' -> Ty' [AtS'] . OPDS', M, M')
    = solveBubblesOps(op F : TyL -> Ty [AtS removeCtorMetadata(AtS')] . OPDS, op F : TyL' -> Ty' [AtS'] . OPDS', M, M')
    if not ditto in AtS'
    /\ sameKind(M, TyL Ty, TyL' Ty') .
  eq solveBubblesOps(OPDS, OPDS', M, M')
    = solveBubblesOpsAux(OPDS, M')
    [owise] .

  op removeCtorMetadata : AttrSet -> AttrSet .
  eq removeCtorMetadata(ctor AtS) = removeCtorMetadata(AtS) .
  eq removeCtorMetadata(metadata(St) AtS) = removeCtorMetadata(AtS) .
  eq removeCtorMetadata(AtS) = AtS [owise] .

  eq solveBubblesOpsAux(op F : TyL -> Ty [AtS] . OPDS, M)
    = op F : TyL -> Ty [solveBubblesAts(AtS, TyL, Ty, M)] .
      solveBubblesOpsAux(OPDS, M) .
  eq solveBubblesOpsAux(none, M) = none .

  eq solveBubblesAts(id('bubble[T]) AtS, TyL, Ty, M)
    = (id(solveBubbles2(T, Ty, M, false, none, emptyDatabase))
       solveBubblesAts(AtS, TyL, Ty, M)) .
  eq solveBubblesAts(left-id('bubble[T]) AtS, Ty TyL, Ty', M)
    = (left-id(solveBubbles2(T, Ty, M, false, none, emptyDatabase))
       solveBubblesAts(AtS, Ty TyL, Ty', M)) .
  eq solveBubblesAts(right-id('bubble[T]) AtS, TyL Ty, Ty', M)
    = (right-id(solveBubbles2(T, Ty, M, false, none, emptyDatabase))
       solveBubblesAts(AtS, TyL Ty, Ty', M)) .
  eq solveBubblesAts(special(HkL) AtS, TyL, Ty, M)
    = (special(solveBubblesHooks(HkL, Ty, M))
       solveBubblesAts(AtS, TyL, Ty, M)) .
  eq solveBubblesAts(AtS, TyL, Ty, M) = AtS [owise] .

  eq solveBubblesHooks(term-hook(QI, 'bubble[T]) HkL, Ty, M)
    = term-hook(QI,
        solveBubbles2('bubble[T], anyType, M, false, none, emptyDatabase))
      solveBubblesHooks(HkL, Ty, M) .
  eq solveBubblesHooks(Hk HkL, Ty, M)
    = Hk solveBubblesHooks(HkL, Ty, M)
    [owise] .
  eq solveBubblesHooks(nil, Ty, M) = nil .

*** Since both sides of any equation or rule have to be in the same connected
*** component of sorts, we parse the two bubbles together using the
*** polymorphic operator \verb~_==_~\footnote{Note that if including
*** \texttt{BOOL} the operator \texttt{\_\,==\_\,} is added for each kind.}.
*** That is, given for example an equation as \verb~eq T = T' .~, we parse
*** \verb~T == T'~, forcing them to be parsed in the same connected component,
*** if possible. We add functions \texttt{lhs} and \texttt{rhs} to extract,
*** respectively, the lefthand and righthand side terms from the result. Note
*** that these are partial functions.

  pr 2TUPLE{Term,AttrSet}
       * (op p1_ to term, op p2_ to attrSet,
          op `(_`,_`) : Term AttrSet -> Tuple{Term,AttrSet} to `{_`,_`}) .

  op pullStmtAttrOut : Term VariableSet -> [Tuple{Term,AttrSet}] .
  op pullStmtAttrOutAux : Term TermList AttrSet VariableSet -> [Tuple{Term,AttrSet}] .
  op pullLabelOut : Term -> [Tuple{Term,AttrSet}] .

  eq pullStmtAttrOut(QI, VDS) = {QI, none} .
  eq pullStmtAttrOut('__[QI, QI'], VDS) = {'__[QI, QI'], none} .
  eq pullStmtAttrOut('__[QI, QI', QI''], VDS) = {'__[QI, QI', QI''], none} .
  eq pullStmtAttrOut('__[QI, QI', TL, QI''], VDS)
    = if QI'' =/= ''`].Qid
      then {'__[QI, QI', TL, QI''], none}
      else pullStmtAttrOutAux('__[QI, QI', TL, QI''], (QI, QI', TL), none, VDS)
      fi .

  eq pullStmtAttrOutAux(T, (TL, ''`[.Qid), AtS, VDS)
    = if AtS =/= none
      then {'__[TL], AtS}
      else {T, none}
      fi .
  eq pullStmtAttrOutAux(T, (TL, QI, ''nonexec.Qid), AtS, VDS)
    = pullStmtAttrOutAux(T, (TL, QI), AtS nonexec, VDS) .
  eq pullStmtAttrOutAux(T, (TL, QI, ''variant.Qid), AtS, VDS)
    = pullStmtAttrOutAux(T, (TL, QI), AtS variant, VDS) .
  eq pullStmtAttrOutAux(T, (TL, QI, ''owise.Qid), AtS, VDS)
    = pullStmtAttrOutAux(T, (TL, QI), AtS owise, VDS) .
  eq pullStmtAttrOutAux(T, (TL, QI, ''otherwise.Qid), AtS, VDS)
    = pullStmtAttrOutAux(T, (TL, QI), AtS owise, VDS) .
  eq pullStmtAttrOutAux(T, (TL, QI, ''label.Qid, QI'), AtS, VDS)
    = if downQid(QI') :: Qid
      then pullStmtAttrOutAux(T, (TL, QI), AtS label(downQid(QI')), VDS)
      else {T, none}
      fi .
  eq pullStmtAttrOutAux(T, (TL, QI, ''metadata.Qid, QI'), AtS, VDS)
    = if downString(downQid(QI')) :: String
      then pullStmtAttrOutAux(T, (TL, QI), AtS metadata(downString(downQid(QI'))), VDS)
      else {T, none}
      fi .
  ceq pullStmtAttrOutAux(T, (TL, QI, ''`[.Qid, TL',  ''print.Qid, TL''), AtS, VDS)
    = pullStmtAttrOutAux(T, (TL, QI, ''`[.Qid, TL'), AtS print(printArg(TL'', VDS)), VDS)
    if printArg(TL'', VDS) : QidList .
  eq pullStmtAttrOutAux(T, TL, AtS, VDS) = {T, none} [owise] .

  op printArg : TermList VariableSet ~> QidList .
  ceq printArg((T, TL), V ; VDS)
    = qid(string(downQid(T)) + ":" + string(getType(V))) printArg(TL, VDS)
    if getName(V) = downQid(T) .
  ceq printArg((T, TL), VDS)
    = downQid(T) printArg(TL, VDS)
    if downString(downQid(T)) : String .
  eq printArg(empty, VDS) = nil .

  eq pullLabelOut(QI) = {QI, none} .
  eq pullLabelOut('__[QI, QI']) = {'__[QI, QI'], none} .
  eq pullLabelOut('__[QI, QI', QI'']) = {'__[QI, QI', QI''], none} .
  eq pullLabelOut('__[QI, QI', QI'', QI3]) = {'__[QI, QI', QI'', QI3], none} .
  eq pullLabelOut('__[QI, QI', QI'', QI3, TL])
    = if QI == ''`[.Qid and-then (QI'' == ''`].Qid and-then QI3 == '':.Qid)
      then {'__[TL], label(downQid(QI'))}
      else {'__[QI, QI', QI'', QI3, TL], none}
      fi .

  ops lhs rhs : Term -> Term .
  eq lhs(F[T, T']) = T .
  eq lhs(F[T, T']) = T .
  eq rhs(F[T, T']) = T' .
  eq rhs(F[T, T']) = T' .
  eq lhs(qidError(QIL)) = qidError(QIL) .
  eq rhs(qidError(QIL)) = qidError(QIL) .

  eq solveBubbles(EqS, M, unitError(QIL), B, VDS, DB) = equationError(QIL) .
  eq solveBubbles(RlS, M, unitError(QIL), B, VDS, DB) = ruleError(QIL) .
  eq solveBubbles(MAS, M, unitError(QIL), B, VDS, DB) = membAxError(QIL) .
  eq solveBubbles(SDfs, M, unitError(QIL), B, VDS, DB) = stratDefError(QIL) .

  eq solveBubbles(eq 'eqlbubble[T] = 'rbubble[T'] [AtS] . EqS, M, M', B, VDS, DB)
    = ((eq lhs(solveBubblesEq(term(pullLabelOut(T)), term(pullStmtAttrOut(T', VDS)),
                 M, B, VDS, DB))
          = rhs(solveBubblesEq(term(pullLabelOut(T)), term(pullStmtAttrOut(T', VDS)),
                  M, B, VDS, DB))
            [attrSet(pullLabelOut(T)) attrSet(pullStmtAttrOut(T', VDS)) AtS] .)
       solveBubbles(EqS, M, M', B, VDS, DB)) .
  eq solveBubbles(ceq 'eqlbubble[T] = 'rcbubble[T'] if 'rbubble[T''] = 'true.Bool [AtS] . EqS,
       M, M', B, VDS, DB)
    = (ceq lhs(solveBubblesCEq(term(pullLabelOut(T)), T', M, B, VDS, DB))
          = rhs(solveBubblesCEq(term(pullLabelOut(T)), T', M, B, VDS, DB))
          if solveBubblesCond(term(pullStmtAttrOut(T'', VDS)), M, M', B, VDS, DB)
          [attrSet(pullLabelOut(T)) attrSet(pullStmtAttrOut(T'', VDS)) AtS] .
       solveBubbles(EqS, M, M', B, VDS, DB)) .
  eq solveBubbles((none).EquationSet, M, M', B, VDS, DB) = none .

  eq solveBubbles(rl 'rllbubble[T] => 'rbubble[T'] [AtS] . RlS, M, M', B, VDS, DB)
    = ((rl lhs(solveBubblesRl(term(pullLabelOut(T)),
                 term(pullStmtAttrOut(T', VDS)), M, B, VDS, DB))
        => rhs(solveBubblesRl(term(pullLabelOut(T)),
                 term(pullStmtAttrOut(T', VDS)), M, B, VDS, DB))
             [attrSet(pullLabelOut(T)) attrSet(pullStmtAttrOut(T', VDS)) AtS] .)
       solveBubbles(RlS, M, M', B, VDS, DB)) .
  eq solveBubbles(crl 'rllbubble[T] => 'rcbubble[T'] if 'rbubble[T''] = 'true.Bool [AtS] . RlS,
       M, M', B, VDS, DB)
    = (crl lhs(solveBubblesCRl(term(pullLabelOut(T)), T', M, B, VDS, DB))
          => rhs(solveBubblesCRl(term(pullLabelOut(T)), T', M, B, VDS, DB))
          if solveBubblesCond(term(pullStmtAttrOut(T'', VDS)), M, M', B, VDS, DB)
          [attrSet(pullLabelOut(T)) attrSet(pullStmtAttrOut(T'', VDS)) AtS] .
       solveBubbles(RlS, M, M', B, VDS, DB)) .
  eq solveBubbles((none).RuleSet, M, M', B, VDS, DB) = none .

*** In the call to solve the bubbles in membership axioms we add the sort to
*** which it is constrained to be used as context.

  eq solveBubbles(mb T : S [AtS] . MAS, M, M', B, VDS, DB)
    = ((mb solveBubbles2(term(pullLabelOut(T)), S, M, B, VDS, DB) : S
          [attrSet(pullLabelOut(T)) AtS] .)
       solveBubbles(MAS, M, M', B, VDS, DB)) .
  eq solveBubbles(cmb T : S if T' = 'true.Bool [AtS] . MAS, M, M', B, VDS, DB)
    = ((cmb solveBubbles2(term(pullLabelOut(T)), S, M, B, VDS, DB) : S
          if solveBubblesCond(T', M, M', B, VDS, DB)
          [attrSet(pullLabelOut(T)) AtS] .)
       solveBubbles(MAS, M, M', B, VDS, DB)) .
  eq solveBubbles((none).MembAxSet, M, M', B, VDS, DB) = none .

 ceq solveBubbles(sd 'sdlbubble[T] := 'rbubble[T'] [AtS] . SDfs, M, M', B, VDS, DB)
    = if Strat1? :: CallStrategy
      then if Strat2? :: Strategy
           then sd Strat1? := Strat2? [AtS1 AtS2 AtS] .
           else stratDefError('\r 'Warning:
                      '\o printSyntaxError(Strat2?, QIL2) '\n
                      '\r 'Error: '\o 'no 'parse 'for 'sd QIL1 '\s ':= '\s QIL2 '\n)
           fi
      else stratDefError('\r 'Warning:
                 '\o printSyntaxError(Strat2?, QIL1) '\n
                 '\r 'Error: '\o 'no 'parse 'for 'sd QIL1 '\s ':= '\s QIL2 '\n)
      fi
      solveBubbles(SDfs, M, M', B, VDS, DB)
    if {T1, AtS1} := pullLabelOut(T)
    /\ {T2, AtS2} := pullStmtAttrOut(T', VDS)
    /\ QIL1 := downQidList(T1)
    /\ QIL2 := downQidList(T2)
    /\ Strat1? := metaParseCallStrategy(M, VDS, QIL1)
    /\ Strat2? := metaParseStrategy(M, VDS, QIL2) .
 ceq solveBubbles(csd 'sdlbubble[T] := 'rcbubble[T'] if 'rbubble[T''] = 'true.Bool [AtS] . SDfs,
       M, M', B, VDS, DB)
    = if Strat1? :: CallStrategy
      then if Strat2? :: Strategy
           then csd Strat1? := Strat2?
                  if solveBubblesCond(T3, M, M', B, VDS, DB)
                  [AtS1 AtS2 AtS] .
           else stratDefError('\r 'Warning:
                         '\o printSyntaxError(Strat2?, QIL2) '\n
                         '\r 'Error: '\o 'no 'parse 'for 'sd QIL1 '\s ':= '\s QIL2 '\n)
           fi
      else stratDefError('\r 'Warning:
                    '\o printSyntaxError(Strat1?, QIL1) '\n
                    '\r 'Error: '\o 'no 'parse 'for 'sd QIL1 '\s ':= '\s QIL2 '\n)
      fi
      solveBubbles(SDfs, M, M', B, VDS, DB)
    if {T1, AtS1} := pullLabelOut(T)
    /\ {T3, AtS2} := pullStmtAttrOut(T'', VDS)
    /\ QIL1 := downQidList(T1)
    /\ QIL2 := downQidList(T')
    /\ Strat1? := metaParseStrategy(M, VDS, QIL1)
    /\ Strat2? := metaParseStrategy(M, VDS, QIL2) .
  eq solveBubbles((none).StratDefSet, M, M', B, VDS, DB) = none .

  op metaParseCallStrategy : Module QidSet QidList -> CallStrategy .
  eq metaParseCallStrategy(M, Vs, QIL1)
   = metaParseStrategy(M, Vs, QIL1) .

*** The parsing process may generate error terms. Since in the
*** current version of the system Core Maude is generating the appropriate
*** error messages, we just have to worry about the elimination of these
*** terms. The effect is the same one as introducing a module at the object
*** level of Core Maude: If there is any term in an identity attribute in an
*** operator declaration, equation, rule, or membership axiom with a parsing
*** error a message is generated and the axiom is eliminated.

  eq (op F : TyL -> Ty [id(qidError(QIL)) AtS] .) = opDeclError(QIL) .
  eq (op F : TyL -> Ty [left-id(qidError(QIL)) AtS] .) = opDeclError(QIL) .
  eq (op F : TyL -> Ty [right-id(qidError(QIL)) AtS] .) = opDeclError(QIL) .

  eq (conditionError(QIL) /\ T = T' /\ CD?) = conditionError(QIL) .
  eq (conditionError(QIL) /\ T : S /\ CD?) = conditionError(QIL) .
  eq (conditionError(QIL) /\ T := T' /\ CD?) = conditionError(QIL) .
  eq (conditionError(QIL) /\ T => T' /\ CD?) = conditionError(QIL) .

  eq (eq qidError(QIL) = T? [AtS] .) = equationError(QIL) .
  eq (eq T? = qidError(QIL) [AtS] .) = equationError(QIL) .
  eq (ceq qidError(QIL) = T? if CD? [AtS] .) = equationError(QIL) .
  eq (ceq T? = qidError(QIL) if CD? [AtS] .) = equationError(QIL) .
  eq (ceq T? = T?' if conditionError(QIL) [AtS] .) = equationError(QIL) .

  eq (mb qidError(QIL) : S [AtS] .) = membAxError(QIL) .
  eq (cmb qidError(QIL) : S if CD? [AtS] .) = membAxError(QIL) .
  eq (cmb T? : S if conditionError(QIL) [AtS] .) = membAxError(QIL) .

  eq (rl qidError(QIL) => T? [AtS] .) = ruleError(QIL) .
  eq (rl T? => qidError(QIL) [AtS] .) = ruleError(QIL) .
  eq (crl qidError(QIL) => T? if CD? [AtS] .) = ruleError(QIL) .
  eq (crl T? => qidError(QIL) if CD? [AtS] .) = ruleError(QIL) .
  eq (crl T? => T?' if conditionError(QIL) [AtS] .) = ruleError(QIL) .

  eq F[qidError(QIL), TL?] = qidError(QIL) .
  eq F[TL?, qidError(QIL)] = qidError(QIL) .
  eq F[TL?, qidError(QIL), TL?'] = qidError(QIL) .
endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

*** The function \texttt{solveBubbles} defined in the following
*** \texttt{VIEW-BUBBLE-PARSING} module parses the bubbles in a set of preview
*** maps. It takes two modules, the signature of the view's source theory,
*** with the variables declared in the view, to parse the source term in the
*** term maps, and the target theory, with the mappings of the variable
*** declarations in the view, to parse the target terms.

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod VIEW-BUBBLE-PARSING is
  pr BUBBLE-PARSING .
  pr PRE-VIEW .
  pr UNIT-BUBBLE-PARSING .

  var  OMS : OpMappingSet .
  var  TMS : StratMappingSet .
  vars T T' : Term .
  vars M M' : Module .
  var  U : Module .
  vars QIL QIL1 QIL2 : QidList .
  vars VDS VDS' : VariableSet .
  vars Strat1? Strat2? : [Strategy] .

  op solveBubbles : OpMappingSet VariableSet VariableSet Module Module -> OpMappingSet .
  op solveBubbles : StratMappingSet VariableSet VariableSet Module Module -> StratMappingSet .

  eq solveBubbles(OMS, VDS, VDS', U, unitError(QIL)) = none .
  eq solveBubbles(OMS, VDS, VDS', unitError(QIL), U) = none .
  eq solveBubbles((op_to`term_.(T, T') OMS), VDS, VDS', M, M')
    = (op_to`term_.(
         solveBubbles(T, M, false, VDS, emptyDatabase),
         solveBubbles(T', M', false, VDS', emptyDatabase))
      solveBubbles(OMS, VDS, VDS', M, M')) .
  eq solveBubbles(OMS, VDS, VDS', M, M') = OMS [owise] .

  eq solveBubbles(TMS, VDS, VDS', U, unitError(QIL)) = none .
  eq solveBubbles(TMS, VDS, VDS', unitError(QIL), U) = none .
 ceq solveBubbles(strat_to`expr_.('bubble[T], 'bubble[T']) TMS, VDS, VDS', M, M')
    = if Strat1? :: CallStrategy
      then if Strat2? :: Strategy
           then strat_to`expr_.(Strat1?, Strat2?)
           else none
           fi
      else none
      fi
      solveBubbles(TMS, VDS, VDS', M, M')
    if QIL1 := downQidList(T)
    /\ QIL2 := downQidList(T')
    /\ Strat1? := metaParseStrategy(M, VDS, QIL1)
    /\ Strat2? := metaParseStrategy(M', VDS', QIL2) .
  eq solveBubbles(TMS, VDS, VDS', M, M') = TMS [owise] .
endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

***
*** Module Expression Evaluation
***

*** So far we have not introduced more module expressions than those given by
*** simple quoted identifiers. We will introduce some later, but the scheme
*** followed for evaluating them is very simple and can be presented in a
*** generic way. Given a module expression and a database state, the
*** evaluation of a module expression results in the generation of a new
*** module, which is introduced in the database, with the module expression
*** as its name. The resulting database is then returned. If there is already
*** a module in the database with that name, the function returns the original
*** database without any change. The evaluation of a module expression may
*** produce the evaluation of other module expressions contained in the
*** modules involved in the process. This is the case, for example, for the
*** renaming of modules, in which not only the top module is renamed but,
*** perhaps, some of its submodules as well; it is also the case for the
*** instantiation of parameterized modules, where the module being
*** instantiated may contain submodules which are parameterized by some of
*** the parameter theories of the parameterized module in which are imported.
*** We shall discuss in more detail the renaming and instantiation of module
*** expressions in Sections~\ref{renaming} and~\ref{instantiation},
*** respectively.

*** We saw in Section~\ref{module-expressions} how it is possible to import a
*** module expression in which a parameterized module is instantiated by some
*** of the formal parameters of the parameterized module into which it is
*** imported. To be able to evaluate this kind of module expression, the list
*** of parameters of the module in which the module expression appears has to
*** be given.

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod MOD-EXPR-EVAL is
  pr DATABASE .

  *** decl. moved to module DATABASE
  *** op evalModExp : ModuleExpression Database -> Database .
  op evalModExp : ModuleExpression ParameterDeclList Database -> Tuple{Database, ModuleExpression} .
  op evalViewExpression : ViewExpression ParameterDeclList Database -> Database .
  op evalViewExpression : ParameterList ParameterDeclList Database -> Database .

  var  S : Sort .
  var  QI : Qid .
  var  ME : ModuleExpression .
  var  PDL : ParameterDeclList .
  var  DB : Database .
  vars VE VE' VE'' : ViewExpression .
  vars PL PL' : ParameterList .

  eq evalModExp(ME, DB) = evalModExp(ME, nil, DB) .

  eq evalModExp(ME, PDL, DB) = < DB ; ME > [owise] .

  eq evalModExp(QI, PDL, DB)
    = if unitInDb(QI, DB)
      then if compiledModule(QI, DB)
           then < DB ; QI >
           else < procModule(QI, DB) ; QI >
           fi
      else if upModule(QI, false) :: Module
           then < procModule(QI, insTermModule(QI, upModule(QI, false), DB)) ; QI >
           else < warning(DB, '\r 'Error: '\o 'Module QI 'not 'in 'database. '\n) ; QI >
           fi
      fi .

  eq evalViewExpression(QI, PDL, DB)
    = if labelInParameterDeclList(QI, PDL)
      then DB
      else if viewInDb(QI, DB)
           then if compiledView(QI, DB)
                then DB
                else procView(QI, DB)
                fi
           else if upView(QI) :: View
                then procView(upView(QI), DB)
                else warning(DB, ('\r 'Error: '\o 'View QI 'not 'in 'database. '\n))
                fi
           fi
      fi .
  eq evalViewExpression(S{PL}, PDL, DB)
    = if viewInDb(S{PL}, DB)
      then DB
      else viewInst(S, PL, PDL, evalViewExpression(S, PDL, evalViewExpression(PL, PDL, DB)))
      fi .
  ceq evalViewExpression(VE ;; VE', PDL, DB)
    = evalViewExpression(VE, PDL, evalViewExpression(VE', PDL, DB))
    if VE =/= mtViewExpression /\ VE' =/= mtViewExpression .
  eq evalViewExpression((S, PL), PDL, DB)
    = evalViewExpression(S, PDL, evalViewExpression(PL, PDL, DB))
    [owise] .
  eq evalViewExpression((S{PL}, PL'), PDL, DB)
    = evalViewExpression(S{PL}, PDL, evalViewExpression(PL', PDL, DB))
    [owise] .
  eq evalViewExpression(nil, PDL, DB) = DB .

  op viewInst : ViewExpression ViewExpression ParameterDeclList Database -> Database .

*******************************************************************************
*** The equations specifying its behavior are later, in FM-INST-EXPR-EVALUATION **
*******************************************************************************

endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

***
*** The Transformation of Object-Oriented Modules to System Modules
***

*** The transformation of object-oriented modules into system modules has
*** already been discussed in Section~\ref{omod2mod}, and also in
*** \cite{Meseguer93b,ClavelDuranEkerLincolnMarti-OlietMeseguerQuesada99}.
*** We focus here on the part of the process accomplished by each of the main

*** functions involved in the transformation. The transformation discussed
*** in~\cite{DuranMeseguer98} assumed that object-oriented modules were
*** flattened before being transformed into system modules. However, doing it
*** in this way, the transformations already made for the modules in the
*** structure were not reused. In the current system, the transformation is
*** done only for the module being introduced, the top of the structure, and
*** dusing the `internal' representations of the submodules stored in the
*** ddatabase for the rest of the structure.

*** This approach requires gathering all class and subclass relation
*** declarations in the structure before starting with the transformation
*** process itself. The function \texttt{prepClasses} collects all these
*** declarations in the structure, and completes all the declarations of
*** classes with the attributes inherited from their superclasses.
*** \begin{comment}
*** This function makes use of a `dummy' module, in which the classes are
*** introduced as sorts and the subclass relations as subsort relations to be
*** able to compute all the operations on the subclass relation using the
*** built-in functions on sorts.
*** \end{comment}

*** Once all the class declarations in the structure have been collected and
*** completed, the transformation is accomplished in two stages. First, the
*** function \texttt{omod2modAux} carries out the
*** following tasks:
*** \begin{itemize}
*** \item For each class declaration of the form
***       $\texttt{class }C\texttt{ | }a_1\texttt{:} S_1\texttt{,}
***       \ldots\texttt{,} a_n\texttt{:} S_n$, the following items are
***       introduced: a subsort $C$ of sort \texttt{Cid}, a constant
***       $C$ of sort $C$, and declarations of operations $a_i
***       \texttt{\ :\_} \texttt{ :\,\,} S_i \texttt{ -> Attribute}$
***       for each attribute $a_i$ (the function
***       \texttt{ops4Attr} creates these declarations).
*** \item For each subclass relation of the form
***       $\texttt{subclass\ }C\texttt{\ <\ }C'$, a subsort
***       declaration $\texttt{subsort\ }C\texttt{\ <\ }C'$ is
***       introduced.
*** \item For each message declaration of the form \verb~msg F : TyL
***       -> S~, an operator declaration \verb~op F : TyL -> S~ is added.
*** \end{itemize}
*** When this process has been completed, the function \texttt{prepAxs} is
***  called.  This function applies to the membership axioms, equations, and
*** rewriting rules in the module the transformations indicated in
*** Section~\ref{omod2mod}, so that they become applicable to all the objects
*** of the given class and of their subclasses. The set of attributes of the
*** objects appearing in the membership axioms, equations, and rewriting rules
*** are completed, so that the default convention of not having to
*** exhaustively mention the set of attributes of a class is supported.

*** Note that in Meseguer's paper~\cite{Meseguer93b} a parallel hierarchy of
*** sorts was defined to deal with objects in different classes, and membership
*** axioms constraining the objects to their corresponding sorts were added.
*** The transformation could be easily completed with sorts, subsort relations,
*** and membership constraints as indicated there. In fact, these declarations
*** were added in an initial version and were then removed because they were
*** computationally expensive. However, there are examples in which it would
*** be interesting to have them; when needed, these declarations can be
*** explicitly added by the user in the current version.

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod FM-EXT-TERMSET is
  protecting FM-TERMSET .
  op |_| : TermSet -> Nat .
  eq | X:Term | T:TermSet | = 1 + | T:TermSet | .
  eq | emptyTermSet | = 0 .
endfm

view TermSet from TRIV to FM-EXT-TERMSET is
  sort Elt to TermSet .
endv

fmod O-O-TO-SYSTEM-MOD-TRANSF is
  pr DATABASE .
  pr CONVERSION .
  pr FM-EXT-TERMSET .

  var  DB : Database .
  var  I : Nat .
  var  ME : Header .
  vars S S' S'' C C' : Sort .
  vars SS SS' SS'' : SortSet .
  var  Ty : Type .
  var  TyL : TypeList .
  vars T T' T'' T3 : Term .
  vars TL TL' : TermList .
  var  PL : ParameterList .
  vars IL IL' IL'' : ImportList .
  vars CDS CDS' : ClassDeclSet .
  vars ADS ADS' : AttrDeclSet .
  var  SSDS : SubsortDeclSet .
  vars SCDS SCDS' : SubclassDeclSet .
  var  OPDS : OpDeclSet .
  var  MDS : MsgDeclSet .
  vars MAS MAS' : MembAxSet .
  vars EqS EqS' : EquationSet .
  vars RlS RlS' : RuleSet .
  var  QIL : QidList .
  var  NQIL : NeQidList .
  vars O O' : Term .
  vars M U : Module .
  vars QI A A' L F : Qid .
  var  V V' : Variable .
  var  CD : ClassDecl .
  vars SCD SCD' : SubclassDecl .
  vars Ct Ct' Ct'' : Constant .
  var  Cond : Condition .
  var  AtS : AttrSet .
  var  H : Header .
  var  PD : ParameterDecl .
  var  PDL : ParameterDeclList .
  var  MN : ModuleName .
  var  CH : ClassHierarchy .
  var  C'' : Sort .
  vars TS TS' : TermSet .


  op newVar : Sort Nat -> Variable .
  eq newVar(S, I) = qid("V#" + string(I, 10) + ":" + string(S)) .

*** The function \texttt{prepClasses} completes all classes in the module with
*** all the attributes they inherit from their superclasses.

  op prepClasses : ClassDeclSet SubclassDeclSet ImportList ParameterDeclList
       Database -> ClassDeclSet .
  op prepClasses2 : ClassDeclSet SubclassDeclSet ImportList
       ImportList Database -> ClassDeclSet .
  op prepClasses3 : ClassDeclSet SubclassDeclSet -> ClassDeclSet .

  eq prepClasses(CDS, SCDS, IL, (PD, PDL), DB)
    = prepClasses(CDS, SCDS, (IL protecting pd(PD) .), PDL, DB) .
  eq prepClasses(CDS, SCDS, IL, nil, DB)
    = prepClasses2(CDS, SCDS, IL, nil, DB) .

  eq prepClasses2(CDS, SCDS, ((including MN .) IL), IL', DB)
    = if (including MN . ) in IL'
      then prepClasses2(CDS, SCDS, IL, IL', DB)
      else prepClasses2(
             (getClasses(getTopModule(MN, DB)) CDS),
             (getSubclasses(getTopModule(MN, DB)) SCDS),
             (getImports(getTopModule(MN, DB)) IL),
             ((including MN .) IL'), DB)
      fi .
  eq prepClasses2(CDS, SCDS, ((extending MN .) IL), IL', DB)
    = if (extending MN . ) in IL'
      then prepClasses2(CDS, SCDS, IL, IL', DB)
      else prepClasses2(
             (getClasses(getTopModule(MN, DB)) CDS),
             (getSubclasses(getTopModule(MN, DB)) SCDS),
             (getImports(getTopModule(MN, DB)) IL),
             ((extending MN .) IL'), DB)
      fi .
  eq prepClasses2(CDS, SCDS, ((protecting MN .) IL), IL', DB)
    = if (protecting MN . ) in IL'
      then prepClasses2(CDS, SCDS, IL, IL', DB)
      else prepClasses2(
             (getClasses(getTopModule(MN, DB)) CDS),
             (getSubclasses(getTopModule(MN, DB)) SCDS),
             (getImports(getTopModule(MN, DB)) IL),
             ((protecting MN .) IL'), DB)
      fi .
  eq prepClasses2(CDS, SCDS, nil, IL, DB) = prepClasses3(CDS, SCDS) .

  eq prepClasses3(CDS, SCDS)
    = addAttrs(buildHierarchy(CDS, SCDS, none, empty), SCDS) .

  sort ClassHierarchy ClassStruct .
  subsort ClassStruct < ClassHierarchy .

  op [_,_] : ClassDecl SortSet -> ClassStruct .

  op empty : -> ClassHierarchy .
  op __ : ClassHierarchy ClassHierarchy -> ClassHierarchy
       [assoc comm id: empty] .

  op buildHierarchy :
       ClassDeclSet SubclassDeclSet SortSet ClassHierarchy -> ClassHierarchy .
  op addAttrs : ClassHierarchy SubclassDeclSet -> ClassDeclSet .
  op addAttrsToItsSons :
       ClassDecl ClassHierarchy SubclassDeclSet -> ClassHierarchy .

  eq buildHierarchy(((class C | ADS .) CDS), SCDS, SS, CH)
    = if C in SS
      then buildHierarchy(CDS, SCDS, SS, CH)
      else buildHierarchy(CDS, SCDS, C ; SS, [(class C | ADS .), none] CH)
      fi .
  eq buildHierarchy(none, (subclass C < C' .) SCDS, SS,
       [(class C | ADS .), SS'] [(class C' | ADS' .), SS''] CH)
    = buildHierarchy(none, SCDS, SS,
        [(class C | ADS .), C' ; SS'] [(class C' | ADS' .), SS''] CH) .
  eq buildHierarchy(none, none, SS, CH) = CH .

  eq addAttrs([(class C | ADS .), none] CH, SCDS)
    = (class C | ADS .)
      addAttrs(addAttrsToItsSons((class C | ADS .), CH, SCDS), SCDS) .
  eq addAttrs(empty, SCDS) = none .

  eq addAttrsToItsSons((class C | ADS .), [(class C' | ADS' .), C ; SS] CH,
       (subclass C' < C .) SCDS)
    = addAttrsToItsSons((class C | ADS .), [(class C' | ADS, ADS' .), SS] CH,
        SCDS) .
  ceq addAttrsToItsSons((class C | ADS .), CH, (subclass C' < C'' .) SCDS)
    = addAttrsToItsSons((class C | ADS .), CH, SCDS)
    if C =/= C'' .
  eq addAttrsToItsSons((class C | ADS .), CH, none) = CH .

----  op inAttrDeclSet : Qid AttrDeclSet -> Bool .
----
----  eq inAttrDeclSet(A, ((attr A' : S), ADS))
----    = (A == A') or-else inAttrDeclSet(A, ADS) .
----  eq inAttrDeclSet(A, none) = false .

*** Given a set of attribute declarations, the \texttt{ops4Attr}
*** function returns a set of operator declarations as indicated above. That
*** is, for each attribute $a\texttt{:} S$, an operator of the form
*** $a \texttt{\ :\_} \texttt{ :\,\,} S \texttt{ -> Attribute}$ is declared.

  op ops4Attr : AttrDeclSet -> OpDeclSet .

  eq ops4Attr(((attr A : S), ADS))
    = ((op qid(string(A) + "`:_") : S -> 'Attribute [gather('&)] .)
       ops4Attr(ADS)) .
  eq ops4Attr(none) = none .

*** The function \texttt{prepLHS} takes the term in the lefthand side of a
*** rule, equation, or membership axiom, and replaces each object
***
***   $\texttt{<\ }O\texttt{\ :\ }C\texttt{\ |\ }ADS\texttt{\ >}$
***
*** in it---with $O$ of sort \texttt{Oid}, $C$ the name of a class, and $ADS$
*** a set of attributes with their corresponding values---by an object
***
***   $\texttt{<\ }O\texttt{\ :\ }V\texttt{\ |\ }ADS\ ADS'\ Atts\texttt{\ >}$
***
*** where the identifier of the class is replaced by a variable $V$ of sort
*** $C$, which is not used in the axiom, and where the set of attributes is
*** completed with attributes $ADS'$ as indicated in Section~\ref{omod2mod}, so
*** that each attribute declared in class $C$ or in any of its superclasses is
*** added with a new variable as value. $Atts$ is a new variable of sort
*** \texttt{AttributeSet}, which is used to range over the additional
*** attributes that may appear in objects of a subclass.

*** The function \texttt{prepLHS} takes as arguments a term (in the initial
*** call, the term in the lefthand side of a rule, equation, or membership
*** axiom), the set of variable declarations of those variables declared in the
*** module that are not used in the axiom---new variables are created only if
*** there are no variables in the module with the appropriate sort---the set of
*** attributes in the* occurrences of the objects---and an index---to make sure
*** that the variables being added have not occurrences of the objects---and an
*** index---to make sure that the variables being added have not been added
*** previously. In the initial call this index is set to zero. \texttt{prepLHS}
*** gives as result a tuple composed of the resulting term, the set of objects
*** in the term (so that the modification of the objects in the righthand side
*** of the rule is simplified), the set of variable declarations corresponding
*** to the new added variables, the set of variable declarations of the
*** variables in the module that have not been used, and the index for the
*** creation of new variables.

*** change (03/20/2002): a new variable is created everytime one is needed

*** The set of objects in the lefthand side will be given as a set of terms.

  pr 4TUPLE{TermList, TermSet, Nat, QidList}
       * (op p1_ to term, op p2_ to objects, op p3_ to index, op p4_ to messages,
          op ((_,_,_,_)) : TermList TermSet Nat QidList -> Tuple{TermList,TermSet,Nat,QidList} to <_;_;_;_>) .

  op prepLHS : TermList ClassDeclSet Nat -> Tuple{TermList, TermSet, Nat, QidList} .

  op crtObject : Term Sort AttrDeclSet Tuple{TermList, TermSet, Nat, QidList} -> Tuple{TermList, TermSet, Nat, QidList} .
  op crtObject2 : Term Variable TermList TermList AttrDeclSet TermSet Nat QidList -> Tuple{TermList, TermSet, Nat, QidList} .
  op crtObject3 : Term Qid TermList AttrDeclSet TermSet Nat QidList -> Tuple{TermList, TermSet, Nat, QidList} .

  eq prepLHS(qidError(QIL), CDS, I) = < qidError(QIL) ; emptyTermSet ; I ; nil > .
  eq prepLHS(F, CDS, I) = < F ; emptyTermSet ; I ; nil > .
  eq prepLHS(Ct, CDS, I) = < Ct ; emptyTermSet ; I ; nil > .

*** \texttt{prepLHS} on a list of terms $\texttt{(}T\texttt{,\ }TL\texttt{)}$,
*** with $T$ a term and $TL$ a list of terms, has to make a call to itself with
*** $T$ and with $TL$. The call with $TL$ has to be made with the result of
*** the call with $T$ so that the variables and the index are right.

  ceq prepLHS((T, TL), CDS, I)
    = < (term(prepLHS(T, CDS, I)),
         term(prepLHS(TL, CDS, index(prepLHS(T, CDS, I))))) ;
        _|_(objects(prepLHS(T, CDS, I)),
                objects(prepLHS(TL, CDS, index(prepLHS(T, CDS, I))))) ;
        index(prepLHS(TL, CDS, index(prepLHS(T, CDS, I)))) ;
        (messages(prepLHS(T, CDS, I))
         messages(prepLHS(TL, CDS, index(prepLHS(T, CDS, I))))) >
    if TL =/= empty .
  ceq prepLHS(F[TL], CDS, I)
    = < F[term(prepLHS(TL, CDS, I))] ;
        objects(prepLHS(TL, CDS, I)) ;
        index(prepLHS(TL, CDS, I)) ;
        messages(prepLHS(TL, CDS, I)) >
      if (F =/= '<_:_|_>) /\ (F =/= '<_:_|`>) .

  ceq prepLHS('<_:_|_>[O, Ct, T], ((class C | ADS .) CDS), I)
    = crtObject(O, C, ADS, prepLHS(T, ((class C | ADS .) CDS), I))
    if getName(Ct) == C .
  ceq prepLHS('<_:_|`>[O, Ct], ((class C | ADS .) CDS), I)
    = crtObject(O, C, ADS,
        prepLHS('none.AttributeSet, ((class C | ADS .) CDS), I))
    if getName(Ct) == C .
  eq prepLHS('<_:_|_>[O, V, T], CDS, I)
    = < '<_:_|_>[O, V, T] ; emptyTermSet ; I ; nil > .
                                                      *** is this eq necessary?
  eq prepLHS('<_:_|`>[O, T], CDS, I)
    = prepLHS('<_:_|_>[O, T, 'none.AttributeSet], CDS, I) .

  eq prepLHS('<_:_|_>[O, T, T'], none, I)
    = < qidError('Error: 'undefined 'class T '\n) ; emptyTermSet ; I ; nil > .

  eq crtObject(O, C, ADS, < T ; TS ; I ; QIL >)
    = crtObject2(O, newVar(C, I), T, 'none.AttributeSet, ADS, TS, (I + 1), QIL) .

*** The function \texttt{crtObject2} is called with the metarepresentation of
*** the list of attributes appearing in the current object (third argument)
*** and the set of attribute declarations of the class to which such object
*** belongs + all the attributes declared in its superclasses (fifth
*** argument). The function proceeds recursively removing the attribute
*** declarations from the set of declarations of attributes for those
*** attributes that appear in the object. Each time an attribute is found, it
*** is passed with its actual value to the fourth argument of
*** \texttt{crtObject2}, which initially has value \verb~'none.AttributeSet~,
*** composing a list of terms with them.

*** We assume that:
*** \begin{itemize}
*** \item The metarepresentation of a list of attributes is always given with
***       form \verb~'_`,_[F[T], T]~, \verb~F[T]~, or
***       \verb~'none.AttributeSet~, where \texttt{TL} is the
***       metarepresentation of a list of attributes with the same form (this
***       is ensured by the \verb~(e E)~ gathering pattern in the corresponding
***       declaration in the signature in which the parsing is done), and
*** \item that all the attributes appearing in an object have been declared in
***       the corresponding class declaration or in one of its superclasses.
*** \end{itemize}

  eq crtObject2(O, V, '_`,_[F[T], TL], TL', ADS, TS, I, QIL)
    = crtObject2(O, V, (F[T], TL), TL', ADS, TS, I, QIL) .

  ceq crtObject2(O, V, (F[T], TL), TL', ((attr A : S), ADS), TS, I, QIL)
    = crtObject2(O, V, TL, (F[T], TL'), ADS, TS, I, QIL)
    if qid(string(A) + "`:_") == F .
  eq crtObject2(O, V, (F[T], TL), TL', ADS, TS, I, QIL)
    = crtObject2(O, V, TL, TL', ADS, TS, I,
        (QIL '\r 'Warning: '\o 'Attribute F 'not 'valid '\n))
    [owise] .

  ceq crtObject2(O, V, F[T], TL, ((attr A : S), ADS), TS, I, QIL)
    = crtObject3(O, V, (F[T], TL), ADS, TS, I, QIL)
    if qid(string(A) + "`:_") == F .
  eq crtObject2(O, V, F[T], TL, ADS, TS, I, QIL)
    = crtObject3(O, V, TL, ADS, TS, I,
        (QIL '\r 'Warning: '\o 'Attribute F 'not 'valid '\n))
    [owise] .

  eq crtObject2(O, V, V', TL, ADS, TS, I, QIL)
    = crtObject3(O, V, TL, ADS, TS, I,
        QIL '\r 'Warning: '\o
            'Variables 'are 'not 'allowed 'in 'the 'set 'of 'attributes
            'of 'an 'object '`( V' '`) '\n) .

  eq crtObject2(O, V, 'none.AttributeSet, TL, ADS, TS, I, QIL)
    = crtObject3(O, V, TL, ADS, TS, I, QIL) .
  eq crtObject2(O, V, empty, TL, ADS, TS, I, QIL)
    = crtObject3(O, V, TL, ADS, TS, I, QIL) .

*** When the function \texttt{crtObject2} has gone through all the
*** attributes in the current object, the function \texttt{crtObject3} is
*** in charge of returning the metarepresentation of the current object
*** completed with the attributes that did not appear in it. These attributes
*** are added with new variables not used in the axiom as value.
*** \texttt{crtObject3} returns a pair composed by this resulting object,
*** and the set of terms representing all the objects in the lefthand
*** side (the current object is added to this set).

  eq crtObject3(O, V, TL, ((attr A : S), ADS), TS, I, QIL)
    = crtObject3(O, V, (qid(string(A) + "`:_")[newVar(S, I)], TL),
        ADS, TS, (I + 1), QIL) .

  eq crtObject3(O, V, TL, none, TS, I, QIL)
    = < '<_:_|_>[O, V, '_`,_[TL, newVar('AttributeSet, I)]] ;
        _|_('<_:_|_>[O, V, '_`,_[TL, newVar('AttributeSet, I)]], TS) ;
        (I + 1) ;
        QIL > .

*** Once the lefthand side of a rule or equation has been `prepared', the
*** function \texttt{prepRHS} is called with the set of objects returned by
*** \texttt{prepLHS} and the term in the righthand side of such rule or
*** equation. The function \texttt{prepRHS} proceeds recursively throughout the
*** term looking for objects. Each time an object is found, its set of
*** attributes is completed with those in the modified object of the lefthand
*** side which do not appear in it.

  op prepRHS : TermSet TermList -> TermList .
  op prepRHS : TermSet Condition -> Condition .

  op adjustObject : TermSet Term -> Term .

  op adjustObjectRHS : TermSet Term -> [Term] .
  op adjustAttrsObjectRHS : Term Term -> [Term] .
  op adjustAttrsObjectRHSAux : TermSet Term -> [Term] .

  op termAttrListToTermSet : TermList -> TermSet .
  op _attrInTermSet_ : Qid TermSet -> Bool .

  eq prepRHS(TS, T = T' /\ Cond)
    = prepRHS(TS, T) = prepRHS(TS, T') /\ prepRHS(TS, Cond) .
  eq prepRHS(TS, T : S /\ Cond)  = prepRHS(TS, T) : S /\ prepRHS(TS, Cond) .
  eq prepRHS(TS, T := T' /\ Cond)
    = prepRHS(TS, T) := prepRHS(TS, T') /\ prepRHS(TS, Cond) .
  eq prepRHS(TS, T => T' /\ Cond)
    = prepRHS(TS, T) => prepRHS(TS, T') /\ prepRHS(TS, Cond) .
  eq prepRHS(TS, (nil).Condition) = nil .

  eq prepRHS(TS, qidError(QIL)) = qidError(QIL) .
  eq prepRHS(TS, F) = F .
  eq prepRHS(TS, Ct) = Ct .
  ceq prepRHS(TS, F[TL])
    = F[prepRHS(TS, TL)]
    if (F =/= '<_:_|_>) and (F =/= '<_:_|`>) .
  eq prepRHS(TS, '<_:_|_>[O, Ct, T])
    = adjustObjectRHS(TS, '<_:_|_>[O, Ct, prepRHS(TS, T)]) .
  eq prepRHS(TS, '<_:_|_>[O, V, T]) = '<_:_|_>[O, V, prepRHS(TS, T)] .
  eq prepRHS(TS, '<_:_|`>[O, Ct])
    = adjustObjectRHS(TS, '<_:_|_>[O, Ct, prepRHS(TS, 'none.AttributeSet)]) .
  eq prepRHS(TS, '<_:_|`>[O, V])
    = '<_:_|_>[O, V, prepRHS(TS, 'none.AttributeSet)] .
  ceq prepRHS(TS, (T, TL))
    = (prepRHS(TS, T), prepRHS(TS, TL))
    if TL =/= empty .

  eq adjustObjectRHS(_|_('<_:_|_>[O, V, T], TS), '<_:_|_>[O', Ct, T'])
    = if O == O'
      then if getType(V) == getType(Ct)
           then '<_:_|_>[O, V, adjustAttrsObjectRHS(T, T')]
           else '<_:_|_>[O', Ct, T']
           fi
      else adjustObjectRHS(TS, '<_:_|_>[O', Ct, T'])
      fi .
  eq adjustObjectRHS(emptyTermSet, '<_:_|_>[O, Ct, T]) = '<_:_|_>[O, Ct, T] .

***  eq adjustObjectRHS(_|_('<_:_|_>[Ct, C, T], TS), '<_:_|_>[O, Ct', T'])
***    = adjustObjectRHS(TS, '<_:_|_>[O, Ct', T']) .
***  eq adjustObjectRHS(
***       _|_('<_:_|_>[Ct, C, T], TS), '<_:_|_>[Ct', Ct'', T'])
***    = if Ct == Ct'
***      then '<_:_|_>[Ct, Ct'', adjustAttrsObjectRHS(T, T')]
***      else adjustObjectRHS(TS, '<_:_|_>[Ct', Ct'', T'])
***      fi .
***  eq adjustObjectRHS(emptyTermSet, '<_:_|_>[Ct, Ct', T])
***    = '<_:_|_>[Ct, Ct', T] .

*** The function \texttt{adjustAttrsObjectRHS} completes the set of
*** attributes of an object in the righthand side with those in the object in
*** the lefthand side or in the class not used in the lefthand side, which
*** have been completed by the function \texttt{crtObject}.

  eq adjustAttrsObjectRHS('_`,_[TL], T)
    = adjustAttrsObjectRHSAux(termAttrListToTermSet(TL), T) .

  eq adjustAttrsObjectRHSAux(_|_(A[T], TS), '_`,_[A[T'], T''])
    = '_`,_[A[T'], adjustAttrsObjectRHSAux(TS, T'')] .
  ceq adjustAttrsObjectRHSAux(TS, '_`,_[A[T], T'])
    = qidError(A 'is 'not 'a 'valid 'attribute)
    if not A attrInTermSet TS .
  eq adjustAttrsObjectRHSAux(_|_(A[T], TS), A[T'])
    = '_`,_[A[T'], adjustAttrsObjectRHSAux(TS, 'none.AttributeSet)] .
  ceq adjustAttrsObjectRHSAux(TS, A[T])
    = qidError(A 'is 'not 'a 'valid 'attribute)
    if not A attrInTermSet TS .
  eq adjustAttrsObjectRHSAux(_|_(A[T], TS), 'none.AttributeSet)
    = '_`,_[A[T], adjustAttrsObjectRHSAux(TS, 'none.AttributeSet)] .
  eq adjustAttrsObjectRHSAux(V, 'none.AttributeSet) = V .

  eq A attrInTermSet _|_(V, TS) = A attrInTermSet TS .
  eq A attrInTermSet _|_(A'[T], TS)
    = (A == A') or-else (A attrInTermSet TS) .
  eq A attrInTermSet emptyTermSet = false .

  ceq termAttrListToTermSet((T, TL))
    = if T == 'none.AttributeSet
      then termAttrListToTermSet(TL)
      else _|_(T, termAttrListToTermSet(TL))
      fi
    if TL =/= empty .
  eq termAttrListToTermSet(T)
    = if T == 'none.AttributeSet
      then emptyTermSet
      else T
      fi .

*** In the case of equations and rules, the function \texttt{prepAxs} calls the
*** function \texttt{prepLHS} with the term in the lefthand side of the axiom,
*** and then use the generated set of objects to call the \texttt{prepRHS}
*** function. For conditional equations, rules, and membership axioms, this set
*** of terms representing the objects in the lefthand side is also used in the
*** calls to \texttt{prepRHS} with each of the terms in the conditions. The
*** term in the lefthand side of the equation, rule, or membership axiom is
*** replaced by the term returned by \texttt{prepLHS}. The index is used in
*** the recursive calls to \texttt{prepAxs}.

*** \texttt{prepLHS} returns as second argument the set of objects (as a set of
*** terms) appearing in it. These objects are returned after extending their
*** set of attributes by those of the class to which they belong not already
*** specified.

  op prepAxs : Module MembAxSet EquationSet RuleSet ClassDeclSet Nat QidList
       -> Module .

  eq prepAxs(U, ((mb T : S [AtS] .) MAS), EqS, RlS, CDS, I, QIL)
    = prepAxs(
        addMbs(mb term(prepLHS(T, CDS, I)) : S [AtS] ., U),
        MAS, EqS, RlS, CDS,
        index(prepLHS(T, CDS, I)),
        (QIL messages(prepLHS(T, CDS, I)))) .
  eq prepAxs(U, ((cmb T : S if Cond [AtS] .) MAS), EqS, RlS, CDS, I, QIL)
    = prepAxs(
        addMbs(cmb term(prepLHS(T, CDS, I)) : S
                 if prepRHS(objects(prepLHS(T, CDS, I)), Cond) [AtS] ., U),
        MAS, EqS, RlS, CDS,
        index(prepLHS(T, CDS, I)),
        (QIL messages(prepLHS(T, CDS, I)))) .
  eq prepAxs(U, MAS, ((eq T = T' [AtS] .) EqS), RlS, CDS, I, QIL)
    = prepAxs(
        addEqs(eq term(prepLHS(T, CDS, I))
                 = prepRHS(objects(prepLHS(T, CDS, I)), T') [AtS] ., U),
        MAS, EqS, RlS, CDS,
        index(prepLHS(T, CDS, I)),
        (QIL messages(prepLHS(T, CDS, I)))) .
  eq prepAxs(U, MAS, ((ceq T = T' if Cond [AtS] .) EqS), RlS, CDS, I, QIL)
    = prepAxs(
        addEqs(ceq term(prepLHS(T, CDS, I))
                 = prepRHS(objects(prepLHS(T, CDS, I)), T')
                 if prepRHS(objects(prepLHS(T, CDS, I)), Cond) [AtS] ., U),
        MAS, EqS, RlS, CDS,
        index(prepLHS(T, CDS, I)),
        (QIL messages(prepLHS(T, CDS, I)))) .

  eq prepAxs(U, MAS, EqS, ((rl T => T' [AtS] .) RlS), CDS, I, QIL)
    = prepAxs(
        addRls(rl term(prepLHS(T, CDS, I))
                 => prepRHS(objects(prepLHS(T, CDS, I)), T') [AtS] ., U),
        MAS, EqS, RlS, CDS,
        index(prepLHS(T, CDS, I)),
        (QIL messages(prepLHS(T, CDS, I)))) .
  eq prepAxs(U, MAS, EqS, ((crl T => T' if Cond [AtS] .) RlS), CDS, I, QIL)
    = prepAxs(
        addRls(crl term(prepLHS(T, CDS, I))
                 => prepRHS(objects(prepLHS(T, CDS, I)), T')
                 if prepRHS(objects(prepLHS(T, CDS, I)), Cond) [AtS] ., U),
        MAS, EqS, RlS, CDS,
        index(prepLHS(T, CDS, I)),
        (QIL messages(prepLHS(T, CDS, I)))) .
  eq prepAxs(U, none, none, none, CDS, I, nil) = U .
  eq prepAxs(U, none, none, none, CDS, I, NQIL) = unitError(NQIL) .
  eq prepAxs(unitError(QIL), MAS, EqS, RlS:[RuleSet], CDS, I, QIL':QidList) = unitError(QIL':QidList QIL) .

*** After completing the set of classes in the module with the attributes from
*** their superclasses, the function \texttt{omod2mod} calls the function
*** \texttt{omod2modAux} with the same module and the set of class
*** declarations. The definition of the \texttt{omod2mod} function is given by
*** the five equations below.

  op omod2mod : OModule Database -> SModule .
  op omod2modAux : OModule ClassDeclSet -> SModule .
  op omod2mod : OTheory Database -> SModule .
  op omod2modAux : OTheory ClassDeclSet -> SModule .

  eq omod2mod(
       omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom,
       DB)
    = omod2modAux(
        omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom,
        prepClasses(CDS, SCDS, IL, getParDecls(H), DB)) .
  eq omod2mod(
       oth H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth,
       DB)
    = omod2modAux(
        oth H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth,
        prepClasses(CDS, SCDS, IL, getParDecls(H), DB)) .

  eq omod2modAux(
       omod H is
          IL sorts SS . SSDS ((class C | ADS .) CDS) SCDS OPDS MDS MAS EqS RlS
       endom,
       CDS')
    = omod2modAux(
        omod H is
           IL sorts (SS ; C) .
           (subsort C < 'Cid . SSDS)
           CDS SCDS
           ((op C : nil -> C [none] .)
            ops4Attr(ADS) OPDS)
           MDS MAS EqS RlS
        endom,
        CDS') .
  eq omod2modAux(
       omod H is
          IL sorts SS . SSDS CDS ((subclass C < C' .) SCDS)
          OPDS MDS MAS EqS RlS
       endom,
       CDS')
    = omod2modAux(
        omod H is
           IL sorts SS . ((subsort C < C' .) SSDS)
           CDS SCDS OPDS MDS MAS EqS RlS
        endom,
        CDS') .
  eq omod2modAux(
        omod H is
           IL sorts SS . SSDS CDS SCDS OPDS
           ((msg F : TyL -> Ty .) MDS) MAS EqS RlS
        endom,
        CDS')
    = omod2modAux(
         omod H is
            IL sorts SS . SSDS CDS SCDS
            ((op F : TyL -> Ty [msg] .) OPDS) MDS MAS EqS RlS
         endom,
         CDS') .
  eq omod2modAux(
       omod H is IL sorts SS . SSDS none none OPDS none MAS EqS RlS endom,
       CDS)
    = prepAxs(mod H is IL sorts SS . SSDS OPDS none none none endm,
        MAS, EqS, RlS, CDS, 0, nil) .

  eq omod2modAux(
       oth H is
          IL sorts SS . SSDS ((class C | ADS .) CDS)
          SCDS OPDS MDS MAS EqS RlS
       endoth,
       CDS')
    = omod2modAux(
        oth H is
           IL sorts (SS ; C) .
           (subsort C < 'Cid . SSDS)
           CDS SCDS
           ((op C : nil -> C [none] .)
            ops4Attr(ADS) OPDS)
           MDS MAS EqS RlS
        endoth,
        CDS') .
  eq omod2modAux(
       oth H is
          IL sorts SS . SSDS CDS ((subclass C < C' .) SCDS)
          OPDS MDS MAS EqS RlS
       endoth,
       CDS')
    = omod2modAux(
        oth H is
           IL sorts SS . ((subsort C < C' .) SSDS)
           CDS SCDS OPDS MDS MAS EqS RlS
        endoth,
        CDS') .
  eq omod2modAux(
        oth H is
           IL sorts SS . SSDS CDS SCDS OPDS
           ((msg F : TyL -> Ty .) MDS) MAS EqS RlS
        endoth,
        CDS')
    = omod2modAux(
         oth H is
            IL sorts SS . SSDS CDS SCDS
            ((op F : TyL -> Ty [msg] .) OPDS) MDS MAS EqS RlS
         endoth,
         CDS') .
  eq omod2modAux(
       oth H is IL sorts SS . SSDS none none OPDS none MAS EqS RlS endoth,
       CDS)
    = prepAxs(
        th H is IL sorts SS . SSDS OPDS none none none endth,
        MAS, EqS, RlS, CDS, 0, nil) .
endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

***
*** Evaluation of Modules and Theories
***

*** As explained in Section~\ref{evaluation-overview}, in our approach
*** transforming a module from its possibly complex structured version to its
*** unstructured form is a two-step process.  First, all module expressions
*** are evaluated, generating an intermediate form in which there are only
*** simple inclusion relationships among the modules. This first step can be
*** seen as the reduction of a structured specification to its structured
*** \emph{normal form}. Then, in a second step, this structured normal form is
*** flattened into an unstructured specification.  Note, however, that the
*** importation of built-in modules is left explicit in the flattened form.
*** The function \texttt{normalize} is in charge of normalizing the
*** structure.

*** The process of evaluation of a preunit has to take into account the
*** possibility of bubbles being contained in it. Depending on whether it is
*** dealing with a preunit or with a unit, the evaluation process is
*** accomplished by two different functions, namely, \texttt{evalPreModule} and
*** \texttt{evalModule}. One function or the other will be called in each case.
*** Evaluating a module already in the database, which is done by
*** \texttt{evalModule}, does not require bubble handling. Besides this
*** difference, both functions proceed in a similar way. Before presenting the
*** functions \texttt{evalPreModule} and \texttt{evalModule} we introduce some
*** auxiliary declarations.

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod FM-EVALUATION is
  pr O-O-TO-SYSTEM-MOD-TRANSF .
  pr MOD-EXPR-EVAL .
  pr UNIT-BUBBLE-PARSING .

  sort List<Module> .
  subsort Module < List<Module> .

  op nil : -> List<Module> .
  op __ : List<Module> List<Module> -> List<Module> [assoc id: nil] .
  eq unitError(QIL) UL unitError(QIL') = unitError(QIL QIL') UL .

  vars M PU U U' U'' : Module .
  vars UL UL' : List<Module> .
  vars DB  DB' : Database .
  vars ME ME' : ModuleExpression .
  var  P : ViewExpression .
  var  PD : ParameterDecl .
  vars PL PL' PL'' : ParameterList .
  vars IL IL' IL'' : ImportList .
  var  I : Import .
  var  CDS : ClassDeclSet .
  var  SSDS : SubsortDeclSet .
  var  SCDS : SubclassDeclSet .
  var  OPD : OpDecl .
  var  OPDS : OpDeclSet .
  var  VDS : VariableSet .
  var  MDS : MsgDeclSet .
  var  MAS : MembAxSet .
  var  EqS : EquationSet .
  var  RlS : RuleSet .
  var  B : Bool .
  vars QI QI' V L L' L'' A A' A'' F F' F'' X Y W Z : Qid .
  vars QIL QIL' SL : QidList .
  vars S S' S'' C C' C'' : Sort .
  vars SS SS' : SortSet .
  vars Ty Ty' : Type .
  vars TyL TyL' : TypeList .
  vars AtS AtS' : AttrSet .
  var  Rl : Rule .
  var  CD : ClassDecl .
  var  ADS : AttrDeclSet .
  var  MD : MsgDecl .
  vars T T' T'' T3 : Term .
  var  TL : TermList .
  var  MAP : Renaming .
  var  MAPS : RenamingSet .
  vars VE VE' VE'' : ViewExpression .
  var  HkL : HookList .
  vars PDL PDL' : ParameterDeclList .
  var  St : String .

*** The \texttt{subunitImports} function returns the list of all the
*** subunits of a given unit. It is called with the list of importations of
*** the given unit as first argument, and proceeds recursively through its
*** structure collecting all the subunits in it.

*** The function \texttt{subunitImports} proceeds storing the importations
*** considered up to that point, so it does not have to go through the same
*** part of the structure more than once. When the function is initially
*** called the second argument is set to \texttt{nil}.

  op subunitImports : ParameterDeclList ImportList Database -> ImportList .
  op subunitImports : ImportList ImportList Database -> ImportList .

  eq subunitImports((PD, PDL), IL, DB)
    = subunitImports(PDL, IL (protecting pd(PD) .), DB) .
  eq subunitImports((nil).ParameterDeclList, IL, DB)
    = subunitImports(IL, nil, DB) .

  eq subunitImports(I IL, IL' I IL'', DB)
    = subunitImports(IL, IL' I IL'', DB)  .
  eq subunitImports(I IL, IL', DB)
    = subunitImports(getImports(getTopModule(moduleName(I), DB)) IL, I IL', DB)
    [owise] .
  eq subunitImports((nil).ImportList, IL, DB) = IL .

*** The function \texttt{getModules} returns the list of those units
*** in the list of importations given as argument which are not built-in.

  op getModules : ImportList Database -> List<Module> .
  op getModules : ImportList List<Module> Database -> List<Module> .

  eq getModules(IL, DB) = getModules(IL, nil, DB) .

  eq getModules(((including ME .) IL), UL, DB)
    = getModules(IL, (UL getInternalModule(ME, DB)), DB) .
  eq getModules(((including pd(PD) .) IL), UL, DB)
    = getModules(IL, (UL getInternalModule(pd(PD), DB)), DB) .
  eq getModules(((extending ME .) IL), UL, DB)
    = getModules(IL, (UL getInternalModule(ME, DB)), DB) .
  eq getModules(((extending pd(PD) .) IL), UL, DB)
    = getModules(IL, (UL getInternalModule(pd(PD), DB)), DB) .
  eq getModules(((protecting ME .) IL), UL, DB)
    = getModules(IL, (UL getInternalModule(ME, DB)), DB) .
  eq getModules(((protecting pd(PD) .) IL), UL, DB)
    = getModules(IL, (UL getInternalModule(pd(PD), DB)), DB) .
  eq getModules(IL, UL unitError(QIL) UL', DB) = unitError(QIL) .
  eq getModules(nil, UL, DB) = UL .

*** The normalization of a structure consists in evaluating each of the module
*** expressions appearing in it. Note that, if the \texttt{evalModExp} function
*** generates new modules, they will be evaluated using the \texttt{evalModule}
*** function, producing recursive calls on the part of the structure not
*** previously normalized. Parameters are handled separatedly. They are
*** folded out when analyzing the interface of a module.

  pr 3TUPLE{ImportList,ParameterDeclList,Database}
       * (op ((_,_,_)) to <_;_;_>,
          op p1_ to importList,
          op p2_ to parameterDeclList,
          op p3_ to database) .

----  sort Tuple{ImportList,ParameterDeclList,Database} .
----  op <_;_;_> : ImportList ParameterDeclList Database
----       -> Tuple{ImportList,ParameterDeclList,Database} .
----  op importList : Tuple{ImportList,ParameterDeclList,Database} -> ImportList .
----  op parameterDeclList :
----       Tuple{ImportList,ParameterDeclList,Database} -> ParameterDeclList .
----  op database : Tuple{ImportList,ParameterDeclList,Database} -> Database .
----  eq importList(< IL ; PDL ; DB >) = IL .
----  eq parameterDeclList(< IL ; PDL ; DB >) = PDL .
----  eq database(< IL ; PDL ; DB >) = DB .

  op normalize : ImportList ParameterDeclList Database
       -> Tuple{ImportList,ParameterDeclList,Database} .
  op normalize : ImportList ImportList ParameterDeclList ParameterDeclList
       Database -> Tuple{ImportList,ParameterDeclList,Database} .
  op createCopy : ParameterDecl Database -> Database .
  ---- its definition is in FM-INST-EXPR-EVALUATION

  eq normalize(IL, PDL, DB) = normalize(nil, IL, nil, PDL, DB) .

  eq normalize(IL, IL', PDL, (X :: ME, PDL'), DB)
    = normalize(IL, IL',
        (PDL, X :: modExp(evalModExp(ME, nil, DB))), PDL',
        createCopy((X :: modExp(evalModExp(ME, nil, DB))),
          database(evalModExp(ME, nil, DB)))) .
  eq normalize(IL, (including ME .) IL', PDL, PDL', DB)
    = normalize(IL (including modExp(evalModExp(ME, PDL, DB)) .), IL',
        PDL, PDL', database(evalModExp(ME, PDL, DB))) .
  eq normalize(IL, (extending ME .) IL', PDL, PDL', DB)
    = normalize(IL (extending modExp(evalModExp(ME, PDL, DB)) .), IL',
        PDL, PDL', database(evalModExp(ME, PDL, DB))) .
  eq normalize(IL, (protecting ME .) IL', PDL, PDL', DB)
    = normalize(IL (protecting modExp(evalModExp(ME, PDL, DB)) .), IL',
        PDL, PDL', database(evalModExp(ME, PDL, DB))) .
  eq normalize(IL, I IL', PDL, PDL', DB)
    = normalize(IL I, IL', PDL, PDL', DB)
    [owise] .
  eq normalize(IL, nil, PDL, nil, DB) = < IL ; PDL ; DB > .

*** \texttt{checkSortClashes} checks whether the intersection of the two sTS
*** of sorts given as arguments is empty or not. If it is nonempty, then there
*** is a clash of names, and a warning message is passed to the database.  The
*** check is very simple, and only reports the name of one of the modules from
*** which the sorts come. Only the name of the module from which the sorts
*** given as second argument come is known at this point. This is the module
*** name given as first argument.
***
***   op checkSortClashes : Header SortSet SortSet Database -> Database .
***
***   eq checkSortClashes(ME, (S ; SS), (S ; SS'), DB)
***     = checkSortClashes(ME, SS, SS',
***         warning(DB,
***           '\g 'Advisory: '\o
***           'Clash 'of 'sort eSortToSort(S) 'from header2Qid(ME) '\n)) .
***   ceq checkSortClashes(ME, (S ; SS), SS', DB)
***     = checkSortClashes(ME, SS, SS', DB)
***     if not (S in SS') .
***   eq check(ME, none, SS, DB) = DB .

*** In the current system, the only transformation handled by the
*** \texttt{transform} function is the one from object-oriented modules to
*** system modules, which is accomplished by the
*** \texttt{omod2mod} function presented in
*** Section~\ref{omod2modfunction}. However, \texttt{transform} has been
*** defined as a general transformation that could affect other kinds of
*** modules in a future extension.

  op transform : Module Database -> Module .

  eq transform(unitError(QIL), DB) = unitError(QIL) .
 ceq transform(U, DB)
    = rmVariantAttrs(U)
    if U :: SModule or U :: STheory or U :: StratModule or U :: StratTheory .
  eq transform(U, DB) = rmVariantAttrs(omod2mod(U, DB)) [otherwise] .

*** The function \texttt{signature} generates a functional module of sort
*** \texttt{FModule}, without equations, by ``forgetting'' the appropriate
*** declarations and converting extended sorts and module names into quoted
*** identifiers.

  op removeIds : OpDeclSet -> OpDeclSet .
  eq removeIds(op F : TyL -> Ty [id(T) AtS] . OPDS)
    = removeIds(op F : TyL -> Ty [AtS] . OPDS) .
  eq removeIds(op F : TyL -> Ty [right-id(T) AtS] . OPDS)
    = removeIds(op F : TyL -> Ty [AtS] . OPDS) .
  eq removeIds(op F : TyL -> Ty [left-id(T) AtS] . OPDS)
    = removeIds(op F : TyL -> Ty [AtS] . OPDS) .
  eq removeIds(op F : TyL -> Ty [special(term-hook(QI, T) HkL) AtS] . OPDS)
    = removeIds(op F : TyL -> Ty [special(HkL) AtS] . OPDS) .
  eq removeIds(OPDS) = OPDS [owise] .

  op removeCtors : Module -> Module .
  op removeCtors : OpDeclSet -> OpDeclSet .
  eq removeCtors(M) = setOps(M, removeCtors(getOps(M))) .
  eq removeCtors(op F : TyL -> Ty [ctor AtS] . OPDS)
    = removeCtors(op F : TyL -> Ty [AtS] . OPDS) .
  eq removeCtors(OPDS) = OPDS [owise] .

  op removeDittos : OpDeclSet Module -> OpDeclSet .
  ceq removeDittos(
        op F : TyL -> Ty [ditto AtS] . op F : TyL' -> Ty' [AtS'] . OPDS, M)
    = removeDittos(
        op F : TyL -> Ty [AtS removeCtorMetadata(AtS')] . op F : TyL' -> Ty' [AtS'] . OPDS, M)
    if not ditto in AtS' /\ sameKind(M, TyL Ty, TyL' Ty') .
  eq removeDittos(OPDS, M) = OPDS [owise] .

  op signature : Module -> Module .
  eq signature(unitError(QIL)) = unitError(QIL) .
  eq signature(U)
    = if U :: StratModule
    then smod header2Qid(getHeader(U)) is
           convertModuleExpressions(getImports(U))
           sorts getSorts(U) .
           getSubsorts(U)
           removeIds(
             removeDittos(getOps(U),
               setSubsorts(
                 setSorts(emptyFModule('DUMMY), getSorts(U)),
                 getSubsorts(U))))
           none
           none
           none
           getStratDcls(U)
           none
         endsm
    else fmod header2Qid(getHeader(U)) is
           convertModuleExpressions(getImports(U))
           sorts getSorts(U) .
           getSubsorts(U)
           removeIds(
             removeDittos(getOps(U),
               setSubsorts(
                 setSorts(emptyFModule('DUMMY), getSorts(U)),
                 getSubsorts(U))))
           none
           none
         endfm
    fi
    [owise] .

*** The function \texttt{flatModule} generates a module of sort \texttt{Module}
*** by ``forgetting'' declarations and converting extended sorts and module
*** identifiers into quoted identifiers.

  op flatModule : Module -> Module .
  eq flatModule(unitError(QIL)) = unitError(QIL) .
  eq flatModule(U)
    = if U :: FModule or U :: FTheory
      then (fmod header2Qid(getHeader(U)) is
               getImports(U)
               sorts getSorts(U) .
               getSubsorts(U)
               getOps(U)
               getMbs(U)
               getEqs(U)
            endfm)
      else if U :: StratModule or U :: StratTheory
        then (smod header2Qid(getHeader(U)) is
                 getImports(U)
                 sorts getSorts(U) .
                 getSubsorts(U)
                 getOps(U)
                 getMbs(U)
                 getEqs(U)
                 getRls(U)
                 getStratDcls(U)
                 getStratDefs(U)
              endsm)
        else (mod header2Qid(getHeader(U)) is
                 getImports(U)
                 sorts getSorts(U) .
                 getSubsorts(U)
                 getOps(U)
                 getMbs(U)
                 getEqs(U)
                 getRls(U)
              endm)
        fi
      fi
    [owise] .

  op convertModuleExpressions : ImportList -> ImportList .
  eq convertModuleExpressions(((protecting ME * (MAPS) .) IL))
    = (protecting ME * (renamings(MAPS)) .) convertModuleExpressions(IL) .
  eq convertModuleExpressions(((extending ME * (MAPS) .) IL))
    = (extending ME * (renamings(MAPS)) .) convertModuleExpressions(IL) .
  eq convertModuleExpressions(((including ME * (MAPS) .) IL))
    = (including ME * (renamings(MAPS)) .) convertModuleExpressions(IL) .
  eq convertModuleExpressions(I IL) = I convertModuleExpressions(IL) [owise] .
  eq convertModuleExpressions(nil) = nil .

  op renamings : RenamingSet -> RenamingSet .
  eq renamings(op F to F' [AtS]) = op F to F' [AtS] .
  eq renamings((op F to F' [AtS], MAPS))
    = (op F to F' [AtS], renamings(MAPS))
    [owise] .
  eq renamings(op F : TyL -> Ty to F' [AtS])
    = op F : TyL -> Ty to F' [AtS] .
  eq renamings((op F : TyL -> Ty to F' [AtS], MAPS))
    = (op F : TyL -> Ty to F' [AtS],
       renamings(MAPS))
    [owise] .
  eq renamings(sort S to S') = sort S to S' .
  eq renamings(((sort S to S'), MAPS))
    = ((sort S to S'), renamings(MAPS))
    [owise] .
  eq renamings(label L to L') = label L to L' .
  eq renamings(((label L to L'), MAPS))
    = ((label L to L'), renamings(MAPS))
    [owise] .
  eq renamings((MAP, MAPS)) = renamings(MAPS) [owise] .
  eq renamings(none) = none .

*** The evaluation process for units without bubbles is as follows. After
*** normalizing the structure, the function \texttt{evalModule} calls
*** \texttt{evalModule1} with an empty copy of the module to which the list of
*** declarations of importations of built-in modules is added, and with the
*** list of its nonbuilt-in subunits.

*** \texttt{evalModule1} accumulates all the declarations in all the
*** nonbuilt-insubmodules in the copy of the module passed as second argument.
*** The top module is then introduced in the database, and, after calling the
*** \texttt{transform} function and renaming all the variables in it, the
*** internal version of such a module is entered in the database as well.

*** Finally, \texttt{evalModule2} generates the signature and the flat version
*** of the module and enters them in the database.

  *** op evalModule : Module Database -> Database .
  ***  moved to MOD-EXPR-EVAL to solve dependency
  op evalModule1 : Module Module List<Module> VariableSet Database -> Database .
  op evalModule2 : Module Module Database -> Database .

  ceq evalModule(U, VDS, DB)
    = evalModule1(setPars(setImports(U, IL), PDL), empty(U),
        getModules(IL', DB'), VDS, DB')
    if < IL ; PDL ; DB' > := normalize(getImports(U), getPars(U), DB)
    /\ IL' := subunitImports(PDL, IL, DB') .
   eq evalModule(U, VDS, DB) = DB [owise] .

  eq evalModule1(U, U', (U'' UL), VDS, DB)
    = evalModule1(U, addDecls(U', setImports(U'', nil)), UL, VDS, DB) .
  eq evalModule1(U, U', nil, VDS, DB)
    = evalModule2(
        setImports(transform(U, DB), nil),
        U',
        insertVars(getHeader(U), VDS,
          insertInternalModule(getHeader(U), transform(U, DB),
            insertTopModule(getHeader(U), U, DB)))) .
  eq evalModule1(U, U', unitError(QIL), VDS, DB) = warning(DB, QIL) .

  eq evalModule2(U, U', DB)
    = insertFlatModule(getHeader(U), flatModule(addDecls(U, U')), DB) .
  eq evalModule2(unitError(QIL), U, DB) = warning(DB, QIL) .

*** The function \texttt{evalPreModule} has to take care of the bubbles in the
*** unit. As we explained in Section~\ref{evaluation-overview}, both the
*** signature and the flattened version of the module are created
*** simultaneously, completing the parsing of the bubbles once the signature
*** has been built, and then completing the flattened module.

*** The \texttt{evalPreModule} function takes as arguments two copies of the
*** module and a database. We shall see in Section~\ref{unit-processing} how
*** these two modules are generated; the one passed as first argument has
*** still bubbles in it, while the other one, which will be used to build the
*** signature, does not contain any bubbles. This module without bubbles is
*** the result of removing the bubbles from the declarations in it, or of
*** removing the declarations themselves when they contain bubbles, as in the
*** case of equations, for example.

*** The \texttt{evalPreModule} function is quite similar to the function
*** \texttt{evalModule}. First, the structure is normalized by calling the
*** \texttt{normalize} function, and then all the subunits in the
*** structure are collected (accomplished by \texttt{subunitImports} and
*** \texttt{getModules}) and the list of importations is updated
*** with the sublist of importations of built-in
*** modules (\texttt{selectBuiltInImports}). Second, the structure of all the
*** subunits below the top is flattened to a single unit. This unit is used to
*** create a first version of the signature (without identity elements of
*** operators) in which all the bubbles in the top preunit are
*** parsed (\texttt{solveBubbles}). The final version of the signature and
*** the flat unit are generated once the bubbles have been parsed. The
*** `internal' version of the module is also generated by renaming the
*** variables in it (\texttt{renameVars}). All these versions of the module
*** are finally entered in the database.

*** Note that if the \texttt{META-LEVEL} module is imported in the module
*** being evaluated, a declaration importing the predefined module
*** \texttt{UP} Section~\ref{non-built-in-predefined}) is added. With the
*** declarations in this module it will be possible to parse bubbles
*** containing calls to the \texttt{up} functions (see
*** Section~\ref{structured-specifications}) in them.

  op evalPreModule : Module Module VariableSet Database -> Database .
  op evalPreModule1 : Module Module List<Module> Module VariableSet Database -> Database .
  op evalPreModule2 : Module Module Module VariableSet Database -> Database .
  op evalPreModule3 : Module Module Module Database -> Database .

  *** evalPreModule just calls evalPreModule1 with a set of the units in the
  *** structure of the given module. Depending on whether the module is
  *** importing META-LEVEL or not UP will be added. BOOL will be added if
  *** the include BOOL flag is set and the module doesn't include it already.

  ceq evalPreModule(PU, U, VDS, DB)
    *** PU  : top unit with bubbles (preunit)
    *** U   : top unit without bubbles (decls with bubbles were removed)
    *** VDS : ops corresponding to the vbles in the top unit
    = evalPreModule1(
        setPars(setImports(PU, IL'), PDL'),
        setName(empty(U), getHeader(U)),
        getModules(IL'', DB'),
        setImports(U, nil),
        VDS,
        DB')
    if IL := getImports(PU)
    /\ PDL := getPars(PU)
    /\ < IL' ; PDL' ; DB' > := normalize(defImports(PU, DB) IL, PDL, DB)
    /\ IL'' := subunitImports(PDL, IL', DB') .
  eq evalPreModule(PU, U, VDS, DB) = DB [owise] .

  *** evalPreModule1 joins all the units in the structure into a single unit,
  *** the one given as second argument; recall that the fourth one is the
  *** top module without bubbles but with the complete list of subunits
  *** being imported explicitly

  eq evalPreModule1(PU, U, (U' UL), U'', VDS, DB)
    = evalPreModule1(PU, addDecls(U, U'), UL, U'', VDS, DB) .
  eq evalPreModule1(PU, U, nil, U', VDS, DB)
    = evalPreModule2(PU, U, signature(transform(addDecls(U', setImports(U, nil)), DB)), VDS, DB)
    [owise] .
  eq evalPreModule1(PU, unitError(QIL), UL, U', VDS, DB) = warning(DB, QIL) .
  eq evalPreModule1(unitError(QIL), U, UL, U', VDS, DB) = warning(DB, QIL) .
  eq evalPreModule1(PU, U, unitError(QIL), U', VDS, DB) = warning(DB, QIL) .

  eq evalPreModule2(PU, U, M, VDS, DB)
    *** PU : top module with bubbles
    *** U  : everything below
    *** M  : complete signature
    = evalPreModule3(
        solveBubblesMod(PU, getOps(U), getRls(U), M,
          included('META-MODULE, getImports(PU), DB), VDS, DB),
        U, M,
        insertVars(getHeader(PU), VDS,
          insertTopModule(getHeader(PU),
            solveBubblesMod(PU, getOps(U), getRls(U), M,
              included('META-MODULE, getImports(PU), DB), VDS, DB), DB))) .

  eq evalPreModule3(PU, U, M, DB)
    *** PU : top module without bubbles
    *** U  : everything below
    *** M  : complete signature
    = insertFlatModule(getHeader(PU),
        flatModule(setImports(transform(addDecls(PU, U), DB), nil)),
        insertInternalModule(getHeader(PU), transform(PU, DB), DB)) .
  eq evalPreModule3(unitError(QIL), U, M, DB) = warning(DB, QIL) .
endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

*** Note that in both \texttt{evalModule} and \texttt{evalPreModule}, the function
*** \texttt{transform} has to be invoked to transform the module into a
*** functional or system module. In the current system, the only
*** transformation available is from object-oriented modules to system modules.

***
*** 6.8 Application of Map STS
***

*** The following two modules deal with the application of a set of renaming
*** maps to a module. Except for the proof obligations and additional checks
*** associated with views---almost none of these checks are performed, and
*** none of these proof obligations is generated in the current version---the
*** way of applying a renaming map and a view map on a module is the same.
*** Internally, they are treated in the same way; the only difference between
*** them consists in the way of calling the function to accomplish this
*** application.

*** Note that there might be some `interference' between sort maps, and
*** operator maps and message maps when they are applied. Let us consider for
*** example a module with an operator declaration
***
***  op f : Foo -> Foo .
***
*** and a renaming map set
***
***  (sort Foo to Bar, op f : Foo -> Foo to g)
***
*** These renamings have to be applied carefully to avoid unintended behaviors.
*** Depending on which of the maps is applied first, the other will be
*** applicable or not.  All the maps must be applied to the original module.
*** To avoid the interference between the sort maps and other maps, the map set
*** is divided into two sTS: The first one contains the sort maps, and the
*** second one contains the other maps.

*** We assume that there are no ambiguous mappings, that is, that we do not
*** have, for example, maps \verb~op f to g~ and \verb~op f to h~. In case of
*** such ambiguity, one of the maps will be arbitrarily chosen.

***
*** 6.8.1 Map STS on Terms
***

*** The application of a set of view maps to a term is defined in the following
*** module \texttt{RENAMING-SET-APPL-ON-TERM}. The function
*** \texttt{applyMapsToTerm} is used to apply a given view map set to terms
*** appearing in equations, rules, identity element declarations, and
*** membership axioms, as part of the process of applying a map set to a unit.

*** Some of the auxiliary functions introduced in this module will also be used
*** in the application of maps to operator and message declarations in the
*** \texttt{RENAMING-SET-APPL-ON-UNIT} module.

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod FM-RENAMING-SET-APPL-ON-TERM is
  pr FM-UNIT .
  pr FM-FMAP .
  pr FM-EXT-SORT .

  var  R : Renaming .
  vars RS RS' RS'' SRS ORS : RenamingSet .
  var  M : Module .
  vars F F' F'' A A' A'' : Qid .
  vars T T' T'' O : Term .
  vars TL TL' TL'' TL3 : TermList .
  vars S S' S'' C C' C'' : Sort .
  var  SS : SortSet .
  var  K : Kind .
  vars TyL TyL' : TypeList .
  vars Ty Ty' : Type .
  vars Subst Subst' Subst'' : Substitution .
  var  AtS : AttrSet .
  var  OPDS : OpDeclSet .
  vars V V' : Variable .
  vars Ct Ct' : Constant .
  var  QIL : QidList .
  var  Cd : Condition .

*** The following functions \texttt{applyMapsToSort} and
*** \texttt{applyMapsToClassSort} apply a set of maps, respectively, to a
*** sort a to a class name in its single identifier form, that is, when they
*** appear qualifying constants. Functions \texttt{applyMapsToType} and
*** \texttt{applyMapsToClassName} are similar but being applied to sort or
*** class names in their normal form.

  op applyMapsToSort : RenamingSet Sort -> Sort .
  eq applyMapsToSort((sort S to S'), S) = S' .
  eq applyMapsToSort((sort S to S'), S'') = S'' [owise] .
  eq applyMapsToSort(((sort S to S'), SRS), S) = S' .
  eq applyMapsToSort(((sort S to S'), SRS), S'')
    = applyMapsToSort(SRS, S'')
    [owise] .
  eq applyMapsToSort(R, S) = S [owise].
  eq applyMapsToSort((R, SRS), S) = applyMapsToSort(SRS, S) [owise].
  eq applyMapsToSort(none, S) = S .

  op applyMapsToSortSet : RenamingSet SortSet -> SortSet .
  eq applyMapsToSortSet(SRS, (S ; SS))
    = (applyMapsToType(SRS, S) ; applyMapsToSortSet(SRS, SS)) .
  eq applyMapsToSortSet(SRS, none) = none .

  op applyMapsToType : RenamingSet Type -> Type .
  eq applyMapsToType((sort S to S'), S) = S' .
  eq applyMapsToType(((sort S to S'), SRS), S) = S' .
  eq applyMapsToType((sort S to S'), K)
    = qid("[" + string(applyMapsToType(sort S to S', getSort(K))) + "]") .
  eq applyMapsToType(((sort S to S'), SRS), K)
    = qid("["
       + string(applyMapsToType(((sort S to S'), SRS), getSort(K)))
       + "]") .
  eq applyMapsToType(SRS, Ty) = Ty [owise] .

  op applyMapsToClassName : RenamingSet Sort -> Sort .
  eq applyMapsToClassName((class C to C'), C) = C' .
  eq applyMapsToClassName(((class C to C'), SRS), C) = C' .
  eq applyMapsToClassName(SRS, C) = C [owise] .

*** \texttt{applyOpMapsToOpId} applies a map set to an operator name.

  op applyOpMapsToOpId : Qid RenamingSet -> Qid .
  eq applyOpMapsToOpId(F, (op F to F' [AtS])) = F' .
  eq applyOpMapsToOpId(F, (op F : TyL -> Ty to F' [AtS])) = F' .
  eq applyOpMapsToOpId(F, RS) = F [owise] .

  op applyStMapsToStId : Qid RenamingSet -> Qid .
  eq applyStMapsToStId(F, (strat F to F')) = F' .
  eq applyStMapsToStId(F, (strat F : TyL @ Ty to F')) = F' .
  eq applyStMapsToStId(F, RS) = F [owise] .

*** Note that all maps introduced in Sections~\ref{renaming-maps}
*** and~\ref{view-maps}, except for label maps, may affect a term. For example,
*** sort maps will be applied to the qualifications of terms, and class and
*** attribute maps have to be applied to the objects appearing in the term.
*** Operator and message maps in which an explicit arity and coarity is given,
*** and operator maps going to derived operators (see Section~\ref{Views})
*** must be applied to the complete family of subsort-overloaded operators.

*** The function \texttt{applyMapsToTerm} takes as arguments two sTS of
*** view maps (the first set for sort maps, and the second for the other maps),
*** the term to which the maps will be applied, and a module to be used in the
*** matching of terms, sort comparisons, etc. Its declaration is as follows.

  op applyMapsToTerm2 : RenamingSet RenamingSet Term Module -> Term .

*** If the term on which the maps have to be applied is not an object,
*** different cases have to be considered for each of the possible forms of a
*** term. If it is a variable or \texttt{error*}, the same term is returned
*** without change (term maps are a special case for this). If it is a sort
*** test or a lazy sort test, with forms \verb~T : S~ and \verb~T :: S~,
*** respectively, the maps are applied to the term \texttt{T} and to the sort
*** \texttt{S}.  In case of being of forms \verb~F.S~ or \verb~F[TL]~ with
*** \texttt{F} an operator name, \texttt{S} a sort, and \texttt{TL} a list of
*** terms, the function \texttt{getRightOpMaps} will return the subset of
*** maps which are applicable on such term. If \texttt{none} is returned then
*** no map is applicable. If more than one map is returned then there is an
*** ambiguity, and any of them will be arbitrarily taken. The function
*** \texttt{imagTerm} is called with the term and the maps applicable on
*** it and return the image of the term. In case of a term of the form
*** \texttt{F[TL]}, \texttt{imageOfTerm} will make recursive calls with the
*** arguments in \texttt{TL}.

*** The application of a term map to a term requires the `matching' of the
*** source term in the map with the term on which the map is applied, and then
*** the application of the obtained substitution. Note, however, that a
*** complete matching algorithm is not required. Given the form of the pattern
*** we can choose beforehand the appropriate map, that is, we know that in
*** fact there is a match when the function is called. Note also that the map
*** has to be applied to the whole family of subsort overloaded operators. We
*** just have to check that the sort of the given variable and the
*** corresponding term are in the same connected component of sorts.  In
*** addition to getting the appropriate substitution, the only thing we need
*** to check is that there are no variables with different assignments, that
*** is, that in case of having a nonlinear pattern, the terms being assigned
*** to each variable are equal. We call \texttt{pseudoMatch} to the function
*** doing this task.

  op applyMapsToTerm2 : RenamingSet RenamingSet TermList Module -> TermList .
  op applyMapsToVars : RenamingSet VariableSet -> VariableSet .
  op imageOfTerm : RenamingSet RenamingSet Term RenamingSet Module -> Term .
  op applyMapsToSubst : RenamingSet RenamingSet Substitution Module -> Substitution .
  op pseudoMatch : TermList TermList Module Substitution -> Substitution .
  op pseudoMatch2 : TermList TermList Module Substitution -> Substitution .
  op pseudoMatchResult : Substitution -> Substitution .
  op pseudoMatchResult : Substitution Assignment Substitution Substitution -> Substitution .

  op getRightOpMaps : Qid TypeList Type RenamingSet Module -> RenamingSet .
  op applyMapsToObjectAttrSet : RenamingSet RenamingSet Sort Term Module -> Term .
  op applyMapsToAttrNameInTerm : RenamingSet Sort Qid Module -> Qid .

  eq applyMapsToTerm2(SRS, ORS, Ct, M)
    = imageOfTerm(SRS, ORS, Ct,
        getRightOpMaps(getName(Ct), nil, getType(Ct), ORS, M), M) .
  eq applyMapsToTerm2(SRS, ORS, V, M)
    = applyMapsToVars(SRS, V) .
  eq applyMapsToTerm2(SRS, ORS, qidError(QIL), M) = qidError(QIL) .
  eq applyMapsToTerm2(SRS, ORS, F[TL], M)
    = imageOfTerm(SRS, ORS, F[TL],
        getRightOpMaps(F, eLeastSort(M, TL), leastSort(M, F[TL]), ORS, M),
        M)
    [owise] .
  eq applyMapsToTerm2(SRS, ORS, '<_:_|_>[O, Ct, T], M)
    = '<_:_|_>[applyMapsToTerm2(SRS, ORS, O, M),
               qid(string(applyMapsToClassName(SRS, getName(Ct)))
                  + "." + string(applyMapsToClassName(SRS, getType(Ct)))),
               applyMapsToObjectAttrSet(SRS, ORS, getName(Ct), T, M)].
  ceq applyMapsToTerm2(SRS, ORS, '<_:_|_>[O, C, T], M)
    = '<_:_|_>[applyMapsToTerm2(SRS, ORS, O, M),
               applyMapsToClassName(SRS, C),
               applyMapsToObjectAttrSet(SRS, ORS, C, T, M)]
    if not C :: Constant .
  eq applyMapsToTerm2(SRS, ORS, '<_:_|`>[O, Ct], M)
    = '<_:_|_>[applyMapsToTerm2(SRS, ORS, O, M),
               qid(string(applyMapsToClassName(SRS, getName(Ct)))
                 + "." + string(applyMapsToClassName(SRS, getType(Ct)))),
               'none.AttributeSet] .
  ceq applyMapsToTerm2(SRS, ORS, '<_:_|`>[O, C], M)
    = '<_:_|_>[applyMapsToTerm2(SRS, ORS, O, M),
         applyMapsToClassName(SRS, C), 'none.AttributeSet]
    if not C :: Constant .
  ceq applyMapsToTerm2(SRS, ORS, F[TL], M)
    = qid("_::`" + string(applyMapsToType(SRS, qid(substr(string(F), 4, length(string(F))))))) [
        applyMapsToTerm2(SRS, ORS, TL, M)]
    if substr(string(F), 0, 4) == "_::`" .

  ceq applyMapsToTerm2(SRS, ORS, (T, TL), M)
    = (applyMapsToTerm2(SRS, ORS, T, M),
       applyMapsToTerm2(SRS, ORS, TL, M))
    if TL =/= empty .
  eq applyMapsToTerm2(SRS, ORS, empty, M) = empty .

*** Application of a map set to the name of an attribute in an object

  eq applyMapsToAttrNameInTerm((attr A . S to A'), C, A'', M)
    = if sameKind(M, S, C) and-then (qid(string(A) + "`:_") == A'')
      then qid(string(A') + "`:_")
      else A''
      fi .
  eq applyMapsToAttrNameInTerm(((attr A . S to A'), ORS), C, A'', M)
    = if sameKind(M, S, C) and-then (qid(string(A) + "`:_") == A'')
      then qid(string(A') + "`:_")
      else applyMapsToAttrNameInTerm(ORS, C, A'', M)
      fi .
  eq applyMapsToAttrNameInTerm(R, C, A, M) = A [owise] .
  eq applyMapsToAttrNameInTerm((R, ORS), C, A, M)
    = applyMapsToAttrNameInTerm(ORS, C, A, M)
    [owise] .
  eq applyMapsToAttrNameInTerm(none, S, A, M) = A .

*** Selection of all the operator or message maps that are applicable on an
*** operator with a given arity and coarity.

  eq getRightOpMaps(F, TyL, Ty, (msg F' to F''), M)
    = getRightOpMaps(F, TyL, Ty, (op F' to F'' [none]), M) .
  eq getRightOpMaps(F, TyL, Ty, ((msg F' to F''), RS), M)
    = getRightOpMaps(F, TyL, Ty, ((op F' to F'' [none]), RS), M) .
  eq getRightOpMaps(F, TyL, Ty, (msg F' : TyL' -> Ty' to F''), M)
    = getRightOpMaps(F, TyL, Ty, op F' : TyL' -> Ty' to F'' [none], M) .
  eq getRightOpMaps(F, TyL, Ty, ((msg F' : TyL' -> Ty' to F''), RS), M)
    = getRightOpMaps(F, TyL, Ty,
        (op F' : TyL' -> Ty' to F'' [none], RS), M) .
  eq getRightOpMaps(F, TyL, Ty, (op F to F' [AtS]), M) = (op F to F' [AtS]) .
  eq getRightOpMaps(F, TyL, Ty, (op F to F' [AtS], RS), M)
    = (op F to F' [AtS], getRightOpMaps(F, TyL, Ty, RS, M)) .
  eq getRightOpMaps(F, TyL, Ty, op F : TyL' -> Ty' to F' [AtS], M)
    = if (size(TyL') == 2 and-then (sameKindAll(M, Ty', TyL) and-then assoc in attrs2SameKind(F, TyL, M)))
         or-else
         sameKind(M, TyL Ty, TyL' Ty')
      then (op F : TyL' -> Ty' to F' [AtS])
      else none
      fi .
  eq getRightOpMaps(F, TyL, Ty, (op F : TyL' -> Ty' to F' [AtS], RS), M)
    = if (size(TyL') == 2 and-then (sameKindAll(M, Ty', TyL) and-then assoc in attrs2SameKind(F, TyL, M)))
         or-else
         sameKind(M, TyL Ty, TyL' Ty')
      then (op F : TyL' -> Ty' to F' [AtS],
            getRightOpMaps(F, TyL, Ty, RS, M))
      else getRightOpMaps(F, TyL, Ty, RS, M)
      fi .
  eq getRightOpMaps(F, TyL, Ty, op_to`term_(F[TL], T), M)
    = if sameKind(M, TyL, varListSort(TL))
      then (op_to`term_(F[TL], T))
      else none
      fi .
  eq getRightOpMaps(F, TyL, Ty, (op_to`term_(F[TL], T), RS), M)
    = if sameKind(M, TyL, varListSort(TL))
      then (op_to`term_(F[TL], T), getRightOpMaps(F, TyL, Ty, RS, M))
      else getRightOpMaps(F, TyL, Ty, RS, M)
      fi .
  eq getRightOpMaps(F, TyL, Ty, (op_to`term_(Ct, T)), M)
    = if TyL == nil
         and-then (F == getName(Ct)
         and-then sameKind(M, Ty, getType(Ct)))
      then (op_to`term_(Ct, T))
      else none
      fi .
  eq getRightOpMaps(F, TyL, Ty, (op_to`term_(Ct, T), RS), M)
    = if TyL == nil
         and-then (F == getName(Ct)
         and-then sameKind(M, Ty, getType(Ct)))
      then (op_to`term_(Ct, T), getRightOpMaps(F, TyL, Ty, RS, M))
      else getRightOpMaps(F, TyL, Ty, RS, M)
      fi .
  eq getRightOpMaps(F, TyL:[Type], Ty:[Type], RS, M) = none [owise].

  op varListSort : TermList -> TypeList .
  eq varListSort((V, TL)) = (getType(V) varListSort(TL)) .
  eq varListSort(empty) = nil .

  op attrs2SameKind : Qid TypeList Module -> AttrSet .
  op attrs2SameKind : Qid TypeList OpDeclSet Module -> AttrSet .
  eq attrs2SameKind(F, Ty Ty' TyL, M) = attrs2SameKind(F, Ty Ty', getOps(M), M) .
 ceq attrs2SameKind(F, TyL, op F : TyL' -> Ty' [AtS] . OPDS, M) ---- all subsort overloaded operators have the same equational attributes
    = AtS
    if sameKind(M, TyL, TyL') .
  eq attrs2SameKind(F, TyL, OPDS, M) = none [owise] .

*** Application of a map set to the set of attributes in an object

  eq applyMapsToObjectAttrSet(RS, RS', C, '_`,_[A[T], TL], M)
    = '_`,_[applyMapsToAttrNameInTerm(RS', C, A, M)
              [applyMapsToTerm2(RS, RS', T, M)],
            applyMapsToObjectAttrSet(RS, RS', C, TL, M)] .
  eq applyMapsToObjectAttrSet(RS, RS', C, A[T], M)
    = applyMapsToAttrNameInTerm(RS', C, A, M)
        [applyMapsToTerm2(RS, RS', T, M)] .
  eq applyMapsToObjectAttrSet(RS, RS', C,
       '_`,_['none.AttributeSet, TL], M)
    = '_`,_['none.AttributeSet,
            applyMapsToObjectAttrSet(RS, RS', C, TL, M)] .
  eq applyMapsToObjectAttrSet(RS, RS', C, 'none.AttributeSet, M)
    = 'none.AttributeSet .

*** Image of a term

  eq imageOfTerm(RS, RS', Ct, none, M)
    = qid(string(getName(Ct)) + "."
          + string(applyMapsToType(RS, getType(Ct)))) .
  eq imageOfTerm(RS, RS', F[TL], none, M)
    = F [ applyMapsToTerm2(RS, RS', TL, M) ] .

  eq imageOfTerm(RS, RS', F[TL], (op F to F' [AtS]), M)
    = F' [ applyMapsToTerm2(RS, RS', TL, M) ] .
  eq imageOfTerm(RS, RS', F[TL], ((op F to F' [AtS]), RS''), M)
    = F' [ applyMapsToTerm2(RS, RS', TL, M) ] .
  eq imageOfTerm(RS, RS', F[TL], (op F : TyL -> Ty to F'[AtS]), M)
    = F' [ applyMapsToTerm2(RS, RS', TL, M) ] .
  eq imageOfTerm(RS, RS', F[TL], (op F : TyL -> Ty to F'[AtS], RS''),M)
    = F' [ applyMapsToTerm2(RS, RS', TL, M) ] .
  eq imageOfTerm(RS, RS', T, op_to`term_(T', T''), M)
    = applySubst(T'',
        applyMapsToSubst(RS, RS', pseudoMatch(T', T, M, none), M)) .
  eq imageOfTerm(RS, RS', T, (op_to`term_(T', T''), RS''), M)
    = applySubst(T'',
        applyMapsToSubst(RS, RS', pseudoMatch(T', T, M, none), M)) .
  ceq imageOfTerm(RS, RS', Ct, (op F to F' [AtS]), M)
    = qid(string(F') + "." + string(applyMapsToType(RS, getType(Ct))))
    if getName(Ct) = F .
  ceq imageOfTerm(RS, RS', Ct, ((op F to F' [AtS]), RS''), M)
    = qid(string(F') + "." + string(applyMapsToType(RS, getType(Ct))))
    if getName(Ct) = F .
  ceq imageOfTerm(RS, RS', Ct, (op F : TyL -> Ty to F' [AtS]), M)
    = qid(string(F') + "." + string(applyMapsToType(RS, getType(Ct))))
    if getName(Ct) = F .
  ceq imageOfTerm(RS, RS', Ct, (op F : TyL -> Ty to F' [AtS], RS''),M)
    = qid(string(F') + "." + string(applyMapsToType(RS, getType(Ct))))
    if getName(Ct) = F .

*** Application of a Substitution on a term

  op applySubst : TermList Substitution -> TermList .
  eq applySubst(T, none) = T .
  eq applySubst(V, ((V' <- T) ; Subst))
    = if getName(V) == getName(V')
      then T
      else applySubst(V, Subst)
      fi .
  eq applySubst(F[TL], Subst) = F[applySubst(TL, Subst)] .
  eq applySubst(Ct, Subst) = Ct .
  ceq applySubst((T, TL), Subst)
    = (applySubst(T, Subst), applySubst(TL,Subst))
    if TL =/= empty .

*** Application of a Substitution to a condition

  op applySubst : Condition Substitution -> Condition .
  eq applySubst(T = T' /\ Cd, Subst)
    = (applySubst(T, Subst) = applySubst(T', Subst)) /\ applySubst(Cd, Subst) .
  eq applySubst(T => T' /\ Cd, Subst)
    = (applySubst(T, Subst) => applySubst(T', Subst)) /\ applySubst(Cd, Subst) .
  eq applySubst(T : S /\ Cd, Subst)
    = (applySubst(T, Subst) : S) /\ applySubst(Cd, Subst) .
  eq applySubst((nil).EqCondition, Subst) = nil .

*** Application of a Substitution to a Substitution

  op applySubst : Substitution Substitution -> Substitution .
  eq applySubst((V <- T ; Subst), Subst')
    = (applySubst(V, Subst) <- applySubst(T, Subst')) ; applySubst(Subst, Subst') .
  eq applySubst((none).Substitution, Subst) = none .

*** PseudoMatch

  eq pseudoMatch(T, T', M, Subst)
    = pseudoMatchResult(pseudoMatch2(T, T', M, Subst)) .

  eq pseudoMatch2(Ct, Ct', M, Subst) = none .
  eq pseudoMatch2(F[TL], F'[TL'], M, Subst)
    = if F == F'
      then pseudoMatch2(TL, TL', M, Subst)
      else none
      fi .
  eq pseudoMatch2((V, TL), (T, TL'), M, Subst)
    = if sameKind(M, getType(V), leastSort(M, T))
      then pseudoMatch2(TL, TL', M, (V <- T ; Subst))
      else none
      fi .
  eq pseudoMatch2(V, T, M, Subst)
    = if sameKind(M, getType(V), leastSort(M, T))
      then (V <- T ; Subst)
      else none
      fi .

  eq pseudoMatch2((V, TL), (T, TL'), M, Subst)
    = if sameKind(M, getType(V), leastSort(M, T))
      then pseudoMatch2(TL, TL', M, (V <- T ; Subst))
      else none
      fi .
  eq pseudoMatch2((Ct, TL), (Ct', TL'), M, Subst)
    = if getName(Ct) == getName(Ct')
      then pseudoMatch2(TL, TL', M, Subst)
      else none
      fi .
  eq pseudoMatch2((F[TL], TL'), (F'[TL''], TL3), M, Subst)
    = if F == F'
      then pseudoMatch2(TL', TL3, M, pseudoMatch2(TL, TL'', M, none) ; Subst)
      else none
      fi .
  eq pseudoMatch2(empty, empty, M, Subst) = Subst .

  *** pseudoMatchResult detects conflicts and eliminates duplicates

  eq pseudoMatchResult((V <- T) ; Subst)
    = pseudoMatchResult(none, (V <- T), none, Subst) .
  eq pseudoMatchResult(none) = none .

  eq pseudoMatchResult(Subst, (V <- T), Subst', (V' <- T') ; Subst'')
    = if V == V'
      then if T == T'
           then pseudoMatchResult(Subst, (V <- T), Subst', Subst'')
           else none
           fi
      else pseudoMatchResult(Subst, (V <- T), Subst' ; (V' <- T'), Subst'')
      fi .
  eq pseudoMatchResult(Subst, (V <- T), (V' <- T') ; Subst', none)
    = pseudoMatchResult(Subst ; (V <- T), (V' <- T'), none, Subst') .
  eq pseudoMatchResult(Subst, (V <- T), none, none) = (Subst ; (V <- T)) .

*** Application of a set of maps to a substitution

  eq applyMapsToSubst(RS, RS', ((V <- T) ; Subst), M)
    = ((applyMapsToTerm2(RS, RS', V, M) <- applyMapsToTerm2(RS, RS', T, M)) ;
       applyMapsToSubst(RS, RS', Subst, M)) .
  eq applyMapsToSubst(RS, RS', none, M) = none .

endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

*** We do not include here the equations defining the semantics of the function
*** \texttt{applyMapsToTerm}. Instead, we present an example illustrating
*** the meaning of the function. Renaming maps and view maps were already
*** discussed in Sections~\ref{Views} and~\ref{module-expressions}.

*** Let us consider the following configuration in the module
*** \texttt{STACK2[Accnt]} presented in Section~\ref{module-expressions}. In
*** this configuration we have objects in the class \texttt{Accnt} which
*** represent the accounts of different clients of a bank, which is
*** represented as an object \texttt{'bank} of class \texttt{Stack[Accnt]}.
*** The object \texttt{'bank} in the example configuration below keeps a stack
*** with the accounts of the bank represented as a linked list of nodes, each
*** of which corresponds to the account of one of the clients.

***   ('bank push 'john)
***   ('peter elt 2000)
***   < 'bank : Stack[Accnt] | first : o ('bank, 1) >
***   < 'paul : Accnt | bal : 5000 >
***   < 'peter : Accnt | bal : 2000 >
***   < 'mary : Accnt | bal : 7200 >
***   < 'john : Accnt | bal : 100 >
***   < o('bank, 0) : Node[Accnt] | node : 'peter, next : null >
***   < o('bank, 1) : Node[Accnt] | node : 'mary, next : o('bank, 0) > .
***
*** Let us apply the following renaming to the previous term.
***
***   (op o to id,
***    class Stack[Accnt] to Bank,
***    msg _push_ : Oid Oid -> Msg to open`account`in_to_,
***    msg _pop to close`account`of_,
***    msg _elt_ to _owns_dollars,
***    attr node . Node[Accnt] to client,
***    attr bal . Accnt to balance)
***
*** The resulting term is as follows.
***
***   (open account in 'bank to 'john)
***   ('peter owns 2000 dollars)
***   < 'bank : Bank | first : id('bank, 1) >
***   < 'paul : Accnt | balance : 5000 >
***   < 'peter : Accnt | balance : 2000 >
***   < 'mary : Accnt | balance : 7200 >
***   < 'john : Accnt | balance : 100 >
***   < id('bank, 0) : Node[Accnt] | client : 'peter, next : null >
***   < id('bank, 1) : Node[Accnt] | client : 'mary, next : id('bank, 0) >

*** The function \texttt{applyMapsToTerm} treats the object constructor
*** \verb~<_:_|_>~ in a special way. It cannot be renamed, and, when an
*** occurrence of such a constructor is found, class and attribute maps require
*** a particular handling. Inside terms these maps are only triggered when
*** this constructor is found, and they are applied in a very restricted way,
*** according to the general pattern for objects.  We assume that the operator
*** \verb~<_:_|_>~ is only used for objects and that objects constructed using
*** it are well-formed.

***
*** 6.8.2 Map STS on Modules
***

*** The application of view maps to modules and theories of the different types
*** is defined in the following module \texttt{RENAMING-SET-APPL-ON-UNIT}. The
*** function \texttt{applyMapsToModule} is defined recursively by applying it
*** to the different components of a unit. When the terms in the different
*** declarations are reached, the function \texttt{applyMapsToTerm} is
*** called. This call is made with the set of maps split conveniently, as
*** explained above.

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

view RenamingSet from TRIV to META-LEVEL is
  sort Elt to RenamingSet .
endv

fmod FM-RENAMING-SET-APPL-ON-UNIT is
  pr FM-RENAMING-SET-APPL-ON-TERM .
  pr FM-INT-LIST .
  pr FM-VIEW-EXPR .

  op applyMapsToModule : RenamingSet Module Module -> Module .
  op applyMapsToModuleAux : RenamingSet RenamingSet RenamingSet Module Module -> Module .
  op splitMaps : RenamingSet -> Tuple{RenamingSet,RenamingSet,RenamingSet} .
  op splitMapsAux : RenamingSet RenamingSet RenamingSet RenamingSet -> Tuple{RenamingSet,RenamingSet,RenamingSet} .

  op applyMapsToTypeList : RenamingSet TypeList -> TypeList .
  op applyMapsToSubsorts : RenamingSet SubsortDeclSet -> SubsortDeclSet .
  op applyMapsToOps : RenamingSet RenamingSet OpDeclSet Module -> OpDeclSet .
  op applyMapsToOp : RenamingSet RenamingSet RenamingSet OpDecl Module -> OpDecl .
  op applyMapsToAttrs : RenamingSet RenamingSet AttrSet Module -> AttrSet .
  op applyMapToAttrs : Renaming AttrSet -> AttrSet .
  op applyMapToAttrsAux : AttrSet AttrSet AttrSet -> AttrSet .
  op applyMapsToHooks : RenamingSet RenamingSet HookList Module -> HookList .
  op applyMapsToHooksAux : RenamingSet RenamingSet Hook Module -> Hook .
  op applyMapsToMbs : RenamingSet RenamingSet MembAxSet Module -> MembAxSet .
  op applyMapsToEqs : RenamingSet RenamingSet EquationSet Module -> EquationSet .
  op applyMapsToRls : RenamingSet RenamingSet RuleSet Module -> RuleSet .
  op applyMapsToCond : RenamingSet RenamingSet Condition Module -> Condition .
  op applyMapsToLabel : RenamingSet Qid -> Qid .
  op applyMapsToClassDeclSet : RenamingSet RenamingSet ClassDeclSet -> ClassDeclSet .
  op applyMapsToSubclassDeclSet : RenamingSet SubclassDeclSet -> SubclassDeclSet .
  op applyMapsToMsgDeclSet : RenamingSet RenamingSet MsgDeclSet Module -> MsgDeclSet .
  op applyMapsToMsgDecl : RenamingSet RenamingSet MsgDecl Module -> MsgDecl .
  op applyMapsToAttrName : RenamingSet Sort Qid -> Qid .
  op applyMapsToAttrDeclSet : RenamingSet RenamingSet Sort AttrDeclSet -> AttrDeclSet .
  op applyMapsToStratDcls : RenamingSet RenamingSet RenamingSet StratDeclSet Module -> StratDeclSet .
  op applyMapsToStratDefs : RenamingSet RenamingSet RenamingSet StratDefSet Module -> StratDefSet .
  op applyMapsToStratDcl : RenamingSet RenamingSet RenamingSet StratDecl Module -> StratDecl .
  op applyMapsToStratDef : RenamingSet RenamingSet RenamingSet StratDefinition Module -> StratDefinition .

  vars M U : Module .
  vars QI QI' QI'' L L' L'' F F' F'' A A' A'' : Qid .
  vars V V' : Variable .
  var  Ct : Constant .
  vars QIL QIL' : QidList .
  var  VE : ViewExpression .
  var  H : Header .
  var  ME : ModuleExpression .
  var  PDL : ParameterDeclList .
  var  IL : ImportList .
  vars S S' S'' C C' C'' : Sort .
  vars Ty Ty' : Type .
  vars TyL TyL' : TypeList .
  var  SS : SortSet .
  var  SSDS : SubsortDeclSet .
  var  OPDS : OpDeclSet .
  var  MAS : MembAxSet .
  var  EqS : EquationSet .
  var  RlS : RuleSet .
  var  CDS : ClassDeclSet .
  var  SCDS : SubclassDeclSet .
  var  MDS : MsgDeclSet .
  var  ADS : AttrDeclSet .
  vars T T' T'' T3 O : Term .
  vars TL TL' : TermList .
  var  At : Attr .
  vars AtS AtS' AtS'' : AttrSet .
  vars I I' : Nat .
  vars NL NL' : IntList .
  var  Hk : Hook .
  var  HkL : HookList .
  var  R : Renaming .
  vars RS RS' RS'' RS3 SRS ORS TRS : RenamingSet .
  vars Subst Subst' : Substitution .
  var  Cond : Condition .
  var  St : String .
  var  MN : ModuleName .
  var  StratDcls : StratDeclSet .
  var  StratDefs : StratDefSet .
  var  Strats : StrategyList .
  vars CS CS' : CallStrategy .
  vars Strat Strat' Strat'' : Strategy .
  var  UPS : UsingPairSet .

  pr (3TUPLE * (op `(_`,_`,_`) to <_;_;_>,
                op p1_ to sortMaps,
                op p2_ to opMaps,
                op p3_ to stratMaps)) { RenamingSet,RenamingSet,RenamingSet } .

---(
  sort Tuple{RenamingSet,RenamingSet} .
  op <_;_> : RenamingSet RenamingSet -> Tuple{RenamingSet, RenamingSet} .
  ops sortMaps otherMaps : Tuple{RenamingSet, RenamingSet} -> RenamingSet .
  eq sortMaps(< RS ; RS' >) = RS .
  eq otherMaps(< RS ; RS' >) = RS' .
)

  eq splitMaps(RS) = splitMapsAux(RS, none, none, none) .
  eq splitMapsAux(sort S to S', RS', RS'', RS3)
    = splitMapsAux(none, ((sort S to S'), RS'), RS'', RS3) .
  eq splitMapsAux((sort S to S', RS), RS', RS'', RS3)
    = splitMapsAux(RS, ((sort S to S'), RS'), RS'', RS3) .
  eq splitMapsAux(class S to S', RS', RS'', RS3)
    = splitMapsAux(none, ((class S to S'), RS'), RS'', RS3) .
  eq splitMapsAux((class S to S', RS), RS', RS'', RS3)
    = splitMapsAux(RS, ((class S to S'), RS'), RS'', RS3) .
  eq splitMapsAux(R, RS', RS'', RS3)
    = splitMapsAux(none, RS', (R, RS''), RS3) [owise] .
  eq splitMapsAux((R, RS), RS', RS'', RS3)
    = splitMapsAux(RS, RS', (R, RS''), RS3) [owise] .
  eq splitMapsAux(strat F to F', RS', RS'', RS3)
    = splitMapsAux(none, RS', RS'', (strat F to F', RS3)) .
  eq splitMapsAux((strat F to F', RS), RS', RS'', RS3)
    = splitMapsAux(RS, RS', RS'', (strat F to F', RS3)) .
  eq splitMapsAux(strat F : TyL @ Ty to F', RS', RS'', RS3)
    = splitMapsAux(none, RS', RS'', (strat F : TyL @ Ty to F', RS3)) .
  eq splitMapsAux(((strat F : TyL @ Ty to F'), RS), RS', RS'', RS3)
    = splitMapsAux(RS, RS', RS'', (strat F : TyL @ Ty to F', RS3)) .
  eq splitMapsAux(none, RS, RS', RS3) = < RS ; RS' ; RS3 > .

*** To avoid the interference between the sort and class maps with other maps, the map
*** set is divided in two sets.

  ceq applyMapsToModule(RS, U, M)
    = applyMapsToModuleAux(SRS, ORS, TRS, U, M)
    if < SRS ; ORS ; TRS > := splitMaps(RS) .
  eq applyMapsToModule(RS, U, unitError(QIL)) = unitError(QIL) .

  eq applyMapsToModuleAux(SRS, ORS, TRS, mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm, M)
    = mod H is
          IL
          sorts applyMapsToSortSet(SRS, SS) .
          applyMapsToSubsorts(SRS, SSDS)
          applyMapsToOps(SRS, ORS, OPDS, M)
          applyMapsToMbs(SRS, ORS, MAS, M)
          applyMapsToEqs(SRS, ORS, EqS, M)
          applyMapsToRls(SRS, ORS, RlS, M)
      endm .
  eq applyMapsToModuleAux(SRS, ORS, TRS, th MN is IL sorts SS . SSDS OPDS MAS EqS RlS endth, M)
    = th MN is
          IL sorts applyMapsToSortSet(SRS, SS) .
          applyMapsToSubsorts(SRS, SSDS)
          applyMapsToOps(SRS, ORS, OPDS, M)
          applyMapsToMbs(SRS, ORS, MAS, M)
          applyMapsToEqs(SRS, ORS, EqS, M)
          applyMapsToRls(SRS, ORS, RlS, M)
      endth .
  eq applyMapsToModuleAux(SRS, ORS, TRS, fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm, M)
    = fmod H is
          IL
          sorts applyMapsToSortSet(SRS, SS) .
          applyMapsToSubsorts(SRS, SSDS)
          applyMapsToOps(SRS, ORS, OPDS, M)
          applyMapsToMbs(SRS, ORS, MAS, M)
          applyMapsToEqs(SRS, ORS, EqS, M)
      endfm .
  eq applyMapsToModuleAux(SRS, ORS, TRS, fth MN is IL sorts SS . SSDS OPDS MAS EqS endfth, M)
    = fth MN is
          IL
          sorts applyMapsToSortSet(SRS, SS) .
          applyMapsToSubsorts(SRS, SSDS)
          applyMapsToOps(SRS, ORS, OPDS, M)
          applyMapsToMbs(SRS, ORS, MAS, M)
          applyMapsToEqs(SRS, ORS, EqS, M)
      endfth .
  eq applyMapsToModuleAux(SRS, ORS, TRS, omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom, M)
    = omod H is
           IL
           sorts applyMapsToSortSet(SRS, SS) .
           applyMapsToSubsorts(SRS, SSDS)
           applyMapsToClassDeclSet(SRS, ORS, CDS)
           applyMapsToSubclassDeclSet(SRS, SCDS)
           applyMapsToOps(SRS, ORS, OPDS, M)
           applyMapsToMsgDeclSet(SRS, ORS, MDS, M)
           applyMapsToMbs(SRS, ORS, MAS, M)
           applyMapsToEqs(SRS, ORS, EqS, M)
           applyMapsToRls(SRS, ORS, RlS, M)
      endom .
  eq applyMapsToModuleAux(SRS, ORS, TRS, oth MN is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth, M)
    = oth MN is
           IL
           sorts applyMapsToSortSet(SRS, SS) .
           applyMapsToSubsorts(SRS, SSDS)
           applyMapsToClassDeclSet(SRS, ORS, CDS)
           applyMapsToSubclassDeclSet(SRS, SCDS)
           applyMapsToOps(SRS, ORS, OPDS, M)
           applyMapsToMsgDeclSet(SRS, ORS, MDS, M)
           applyMapsToMbs(SRS, ORS, MAS, M)
           applyMapsToEqs(SRS, ORS, EqS, M)
           applyMapsToRls(SRS, ORS, RlS, M)
      endoth .
  eq applyMapsToModuleAux(SRS, ORS, TRS, smod H is IL sorts SS . SSDS OPDS MAS EqS RlS StratDcls StratDefs endsm, M)
    = smod H is
          IL
          sorts applyMapsToSortSet(SRS, SS) .
          applyMapsToSubsorts(SRS, SSDS)
          applyMapsToOps(SRS, ORS, OPDS, M)
          applyMapsToMbs(SRS, ORS, MAS, M)
          applyMapsToEqs(SRS, ORS, EqS, M)
          applyMapsToRls(SRS, ORS, RlS, M)
          applyMapsToStratDcls(SRS, ORS, TRS, StratDcls, M)
          applyMapsToStratDefs(SRS, ORS, TRS, StratDefs, M)
      endsm .
  eq applyMapsToModuleAux(SRS, ORS, TRS, sth MN is IL sorts SS . SSDS OPDS MAS EqS RlS StratDcls StratDefs endsth, M)
    = sth MN is
          IL sorts applyMapsToSortSet(SRS, SS) .
          applyMapsToSubsorts(SRS, SSDS)
          applyMapsToOps(SRS, ORS, OPDS, M)
          applyMapsToMbs(SRS, ORS, MAS, M)
          applyMapsToEqs(SRS, ORS, EqS, M)
          applyMapsToRls(SRS, ORS, RlS, M)
          applyMapsToStratDcls(SRS, ORS, TRS, StratDcls, M)
          applyMapsToStratDefs(SRS, ORS, TRS, StratDefs, M)
      endsth .

  eq applyMapsToOps(RS, RS', (op F : TyL -> Ty [AtS] . OPDS), M)
    = (applyMapsToOp(RS, getRightOpMaps(F, TyL, Ty, RS', M), RS', (op F : TyL -> Ty [AtS] .), M)
       applyMapsToOps(RS, RS', OPDS, M)) .
  eq applyMapsToOps(RS, RS', none, M) = none .

  eq applyMapsToOp(RS, R, RS', (op F : TyL -> Ty [AtS] .), M)
    = (op applyOpMapsToOpId(F, R) : applyMapsToTypeList(RS, TyL) -> applyMapsToType(RS, Ty)
         [applyMapsToAttrs(RS, RS', applyMapToAttrs(R, AtS), M)] .) .
  eq applyMapsToOp(RS, (R, RS'), RS'', (op F : TyL -> Ty [AtS] .), M)
    *** In case of ambiguous mappings we take one of them arbitrarily
    = (op applyOpMapsToOpId(F, R) : applyMapsToTypeList(RS, TyL) -> applyMapsToType(RS, Ty)
         [applyMapsToAttrs(RS, RS'', applyMapToAttrs(R, AtS), M)] .) .
  eq applyMapsToOp(RS, none, RS', (op F : TyL -> Ty [AtS] .), M)
    *** No map for this declaration
    = (op F : applyMapsToTypeList(RS, TyL) -> applyMapsToType(RS, Ty)
         [applyMapsToAttrs(RS, RS', AtS, M)] .) .

  eq applyMapsToMsgDeclSet(RS, RS', ((msg F : TyL -> Ty .) MDS), M)
    = (applyMapsToMsgDecl(RS, getRightOpMaps(F, TyL, Ty, RS', M), (msg F : TyL -> Ty .), M)
       applyMapsToMsgDeclSet(RS, RS', MDS, M)) .
  eq applyMapsToMsgDeclSet(RS, RS', none, M) = none .

  eq applyMapsToMsgDecl(RS, R, (msg F : TyL -> Ty .), M)
    = (msg applyOpMapsToOpId(F, R) : applyMapsToTypeList(RS, TyL) -> applyMapsToType(RS, Ty) .) .
  eq applyMapsToMsgDecl(RS, (R, RS'), (msg F : TyL -> Ty .), M)
    *** In case of ambiguous mappings we take one of them arbitrarily
    = (msg applyOpMapsToOpId(F, R) : applyMapsToTypeList(RS, TyL) -> applyMapsToType(RS, Ty) .) .
  eq applyMapsToMsgDecl(RS, none, (msg F : TyL -> Ty .), M)
    *** No map for this declaration
    = (msg F : applyMapsToTypeList(RS, TyL) -> applyMapsToType(RS, Ty) .) .

*** The function \texttt{applyMapToAttrs} just takes care of changing the
*** attributes of the operators as indicated in the renamings. The renamings
*** properly said is accomplished by the function
*** \texttt{applyMapsToAttrs}.

  eq applyMapToAttrs((msg F to F'), AtS) = AtS .
  eq applyMapToAttrs((msg F : TyL -> Ty to F'), AtS) = AtS .
  eq applyMapToAttrs(op_to`term_(T, T'), AtS) = AtS .
  eq applyMapToAttrs((op F to F' [AtS]), AtS')
    = applyMapToAttrsAux(AtS, AtS', none) .
  eq applyMapToAttrs((op F : TyL -> Ty to F' [AtS]), AtS')
    = applyMapToAttrsAux(AtS, AtS', none) .
  eq applyMapToAttrs(R, AtS) = AtS [owise] .

  *** add the new syntactic attributes
  eq applyMapToAttrsAux((gather(QIL) AtS), AtS', AtS'')
    = applyMapToAttrsAux(AtS, AtS', (gather(QIL) AtS'')) .
  eq applyMapToAttrsAux((format(QIL) AtS), AtS', AtS'')
    = applyMapToAttrsAux(AtS, AtS', (format(QIL) AtS'')) .
  eq applyMapToAttrsAux((prec(I) AtS), AtS', AtS'')
    = applyMapToAttrsAux(AtS, AtS', (prec(I) AtS'')) .
  eq applyMapToAttrsAux((At AtS), AtS', AtS'')
    = applyMapToAttrsAux(AtS, AtS', AtS'')
    [owise] .

  *** remove the old syntactic attributes
  eq applyMapToAttrsAux(AtS, (format(QIL) AtS'), AtS'')
    = applyMapToAttrsAux(AtS, AtS', AtS'') .
  eq applyMapToAttrsAux(AtS, (gather(QIL) AtS'), AtS'')
    = applyMapToAttrsAux(AtS, AtS', AtS'') .
  eq applyMapToAttrsAux(AtS, (prec(I) AtS'), AtS'')
    = applyMapToAttrsAux(AtS, AtS', AtS'') .

  eq applyMapToAttrsAux(none, (At AtS), AtS')
    = applyMapToAttrsAux(none, AtS, (At AtS')) .
  eq applyMapToAttrsAux(none, none, AtS) = AtS .

  eq applyMapsToTypeList(RS, (Ty TyL))
    = (applyMapsToType(RS, Ty) applyMapsToTypeList(RS, TyL)) .
  eq applyMapsToTypeList(RS, nil) = nil .

  eq applyMapsToSubsorts(RS, ((subsort S < S' .) SSDS))
    = ((subsort applyMapsToType(RS, S) < applyMapsToType(RS, S') .)
       applyMapsToSubsorts(RS, SSDS)) .
  eq applyMapsToSubsorts(RS, none) = none .

  eq applyMapsToAttrs(RS, RS', (id(T) AtS), M)
    = (id(applyMapsToTerm2(RS, RS', T, M))
       applyMapsToAttrs(RS, RS', AtS, M)) .
  eq applyMapsToAttrs(RS, RS', (left-id(T) AtS), M)
    = (left-id(applyMapsToTerm2(RS, RS', T, M))
       applyMapsToAttrs(RS, RS', AtS, M)) .
  eq applyMapsToAttrs(RS, RS', (right-id(T) AtS), M)
    = (right-id(applyMapsToTerm2(RS, RS', T, M))
       applyMapsToAttrs(RS, RS', AtS, M)) .
  eq applyMapsToAttrs(RS, RS', (special(HkL) AtS), M)
    = (special(applyMapsToHooks(RS, RS', HkL, M))
       applyMapsToAttrs(RS, RS', AtS, M)) .
  eq applyMapsToAttrs(RS, RS', (label(L) AtS), M)
    = (label(applyMapsToLabel(RS, L))
       applyMapsToAttrs(RS, RS', AtS, M)) .
  eq applyMapsToAttrs(RS, RS', AtS, M) = AtS [owise] .

  eq applyMapsToHooks(RS, RS', id-hook(QI, QIL) HkL, M)
    = id-hook(QI, QIL)
      applyMapsToHooks(RS, RS', HkL, M).
  eq applyMapsToHooks(RS, RS', op-hook(QI, QI', QIL, QI'') HkL, M)
    = applyMapsToHooksAux(RS,
         getRightOpMaps(QI', QIL, QI'', RS', M),
         op-hook(QI, QI', QIL, QI''), M)
      applyMapsToHooks(RS, RS', HkL, M).
  eq applyMapsToHooks(RS, RS', term-hook(QI, T) HkL, M)
    = term-hook(QI, applyMapsToTerm2(RS, RS', T, M))
      applyMapsToHooks(RS, RS', HkL, M).
  eq applyMapsToHooks(RS, RS', nil, M) = nil .

  eq applyMapsToHooksAux(RS, R, op-hook(QI, F, TyL, Ty), M)
    = op-hook(QI, applyOpMapsToOpId(F, R),
         applyMapsToTypeList(RS, TyL), applyMapsToType(RS, Ty)) .
  eq applyMapsToHooksAux(RS, (R, RS'), op-hook(QI, F, TyL, Ty), M)
    *** In case of ambiguous mappings we take any of them arbitrarily
    = op-hook(QI, applyOpMapsToOpId(F, R),
         applyMapsToTypeList(RS, TyL), applyMapsToType(RS, Ty)) .
  eq applyMapsToHooksAux(RS, none, op-hook(QI, F, TyL, Ty), M)
    = op-hook(QI, F, applyMapsToTypeList(RS, TyL),
        applyMapsToType(RS, Ty)) .

  eq applyMapsToMbs(SRS, ORS, ((mb T : S [AtS] .) MAS), M)
    = ((mb applyMapsToTerm2(SRS, ORS, T, M) : applyMapsToType(SRS, S)
          [applyMapsToAttrs(SRS, ORS, AtS, M)] .)
       applyMapsToMbs(SRS, ORS, MAS, M)) .
  eq applyMapsToMbs(SRS, ORS, ((cmb T : S if Cond [AtS] .) MAS), M)
    = ((cmb applyMapsToTerm2(SRS, ORS, T, M) : applyMapsToType(SRS, S)
          if applyMapsToCond(SRS, ORS, Cond, M)
          [applyMapsToAttrs(SRS, ORS, AtS, M)] .)
       applyMapsToMbs(SRS, ORS, MAS, M)) .
  eq applyMapsToMbs(SRS, ORS, none, M) = none .

  eq applyMapsToEqs(RS, RS', ((ceq T = T' if Cond [AtS] .) EqS), M)
    = ((ceq applyMapsToTerm2(RS, RS', T, M)
          = applyMapsToTerm2(RS, RS', T', M)
          if applyMapsToCond(RS, RS', Cond, M)
        [applyMapsToAttrs(RS, RS', AtS, M)] .)
       applyMapsToEqs(RS, RS', EqS, M)) .
  eq applyMapsToEqs(RS, RS', ((eq T = T' [AtS] .) EqS), M)
    = ((eq applyMapsToTerm2(RS, RS', T, M)
          = applyMapsToTerm2(RS, RS', T', M)
          [applyMapsToAttrs(RS, RS', AtS, M)] .)
       applyMapsToEqs(RS, RS', EqS, M)) .
  eq applyMapsToEqs(RS, RS', none, M) = none .

  eq applyMapsToRls(RS, RS', ((crl T => T' if Cond [AtS] .) RlS), M)
    = ((crl applyMapsToTerm2(RS, RS', T, M)
          => applyMapsToTerm2(RS, RS', T', M)
          if applyMapsToCond(RS, RS', Cond, M)
          [applyMapsToAttrs(RS, RS', AtS, M)] .)
       applyMapsToRls(RS, RS', RlS, M)) .
  eq applyMapsToRls(RS, RS', ((rl T => T' [AtS] .) RlS), M)
    = ((rl applyMapsToTerm2(RS, RS', T, M)
          => applyMapsToTerm2(RS, RS', T', M)
          [applyMapsToAttrs(RS, RS', AtS, M)] .)
       applyMapsToRls(RS, RS', RlS, M)) .
  eq applyMapsToRls(RS, RS', none, M) = none .

  eq applyMapsToCond(RS, RS', T = T' /\ Cond, M)
    = applyMapsToTerm2(RS, RS', T, M) = applyMapsToTerm2(RS, RS', T', M)
      /\ applyMapsToCond(RS, RS', Cond, M) .
  eq applyMapsToCond(RS, RS', T : S /\ Cond, M)
    = applyMapsToTerm2(RS, RS', T, M) : applyMapsToSort(RS, S)
      /\ applyMapsToCond(RS, RS', Cond, M) .
  eq applyMapsToCond(RS, RS', T := T' /\ Cond, M)
    = applyMapsToTerm2(RS, RS', T, M) := applyMapsToTerm2(RS, RS', T', M)
      /\ applyMapsToCond(RS, RS', Cond, M) .
  eq applyMapsToCond(RS, RS', T => T' /\ Cond, M)
    = applyMapsToTerm2(RS, RS', T, M) => applyMapsToTerm2(RS, RS', T', M)
      /\ applyMapsToCond(RS, RS', Cond, M) .
  eq applyMapsToCond(RS, RS', nil, M) = nil .

  eq applyMapsToLabel((label L to L'), L'')
    = if L == L''
      then L'
      else L''
      fi .
  eq applyMapsToLabel(((label L to L'), RS), L'')
    = if L == L''
      then L'
      else applyMapsToLabel(RS, L'')
      fi .
  eq applyMapsToLabel(R, L) = L [owise] .
  eq applyMapsToLabel((R, RS), L)
    = applyMapsToLabel(RS, L)
    [owise] .
  eq applyMapsToLabel(none, L) = L .

  eq applyMapsToClassDeclSet(RS, RS', class C | ADS . CDS)
    = (class applyMapsToClassName(RS, C) | applyMapsToAttrDeclSet(RS, RS', C, ADS) .
       applyMapsToClassDeclSet(RS, RS', CDS)) .
  eq applyMapsToClassDeclSet(RS, RS', none) = none .

  eq applyMapsToAttrDeclSet(RS, RS', C, ((attr A : Ty), ADS))
    = ((attr applyMapsToAttrName(RS', C, A) : applyMapsToType(RS, Ty)),
       applyMapsToAttrDeclSet(RS, RS', C, ADS)) .
  eq applyMapsToAttrDeclSet(RS, RS', C, none) = none .

  eq applyMapsToAttrName((attr A . C to A'), C', A'')
    = if (C == C') and (A == A'')
      then A'
      else A''
      fi .
  eq applyMapsToAttrName(((attr A . C to A'), RS), C', A'')
    = if (C == C') and (A == A'')
      then A'
      else applyMapsToAttrName(RS, C', A'')
      fi .
  eq applyMapsToAttrName(R, C, A) = A [owise] .
  eq applyMapsToAttrName((R, RS), C, A)
    = applyMapsToAttrName(RS, C, A)
    [owise] .
  eq applyMapsToAttrName(none, C, A) = A .

  eq applyMapsToSubclassDeclSet(RS, subclass C < C' . SCDS)
    = (subclass applyMapsToClassName(RS, C) < applyMapsToClassName(RS, C') .
       applyMapsToSubclassDeclSet(RS, SCDS)) .
  eq applyMapsToSubclassDeclSet(RS, none) = none .

  eq applyMapsToStratDcls(RS, RS', RS'', (strat F : TyL @ Ty [AtS] . StratDcls), M)
    = (applyMapsToStratDcl(RS, RS', getRightStratMaps(F, TyL, RS'', M), (strat F : TyL @ Ty [AtS] .), M)
       applyMapsToStratDcls(RS, RS', RS'', StratDcls, M)) .
  eq applyMapsToStratDcls(RS, RS', RS'', none, M) = none .

  eq applyMapsToStratDcl(RS, RS', R, (strat F : TyL @ Ty [AtS] .), M)
    = (strat applyStMapsToStId(F, R) : applyMapsToTypeList(RS, TyL) @ applyMapsToType(RS, Ty)
        [applyMapsToAttrs(RS, RS', AtS, M)] .) .
  eq applyMapsToStratDcl(RS, RS', (R, RS''), (strat F : TyL @ Ty [AtS] .), M)
    *** In case of ambiguous mappings we take one of them arbitrarily
    = (strat applyStMapsToStId(F, R) : applyMapsToTypeList(RS, TyL) @ applyMapsToType(RS, Ty)
        [applyMapsToAttrs(RS, RS', AtS, M)] .) .
  eq applyMapsToStratDcl(RS, RS', none, (strat F : TyL @ Ty [AtS] .), M)
    *** No map for this declaration
    = (strat F : applyMapsToTypeList(RS, TyL) @ applyMapsToType(RS, Ty) [applyMapsToAttrs(RS, RS', AtS, M)] .) .

  eq applyMapsToStratDefs(RS, RS', RS'', csd CS := Strat if Cond [AtS] . StratDefs, M)
    = (csd applyMapsToStrategy(RS, RS', RS'', CS, M)
         := applyMapsToStrategy(RS, RS', RS'', Strat, M)
         if applyMapsToCond(RS, RS', Cond, M)
         [applyMapsToAttrs(RS, RS', AtS, M)] .)
      applyMapsToStratDefs(RS, RS', RS'', StratDefs, M) .
  eq applyMapsToStratDefs(RS, RS', RS'', sd CS := Strat [AtS] . StratDefs, M)
    = (sd applyMapsToStrategy(RS, RS', RS'', CS, M)
         := applyMapsToStrategy(RS, RS', RS'', Strat, M)
         [applyMapsToAttrs(RS, RS', AtS, M)] .)
      applyMapsToStratDefs(RS, RS', RS'', StratDefs, M) .
  eq applyMapsToStratDefs(RS, RS', RS'', none, M) = none .

----  op applyMapsToStrategy : RenamingSet RenamingSet RenamingSet Strategy Module -> Strategy .
  op imageOfCallStrategy : RenamingSet RenamingSet CallStrategy RenamingSet Module -> CallStrategy .
  op pseudoMatch : CallStrategy CallStrategy Module Substitution -> Substitution .
  op pseudoMatchCS : CallStrategy CallStrategy Module Substitution -> Substitution .

  eq imageOfCallStrategy(SRS, ORS, F[[TL]], (strat F to F', TRS), M)
    = F' [[ applyMapsToTerm2(SRS, ORS, TL, M) ]] .
  eq imageOfCallStrategy(SRS, ORS, F[[TL]], strat F to F', M)
    = F' [[ applyMapsToTerm2(SRS, ORS, TL, M) ]] .
  eq imageOfCallStrategy(SRS, ORS, F[[TL]], (strat F : TyL @ Ty to F', TRS), M)
    = F' [[ applyMapsToTerm2(SRS, ORS, TL, M) ]] .
  eq imageOfCallStrategy(SRS, ORS, F[[TL]], strat F : TyL @ Ty to F', M)
    = F' [[ applyMapsToTerm2(SRS, ORS, TL, M) ]] .
  eq imageOfCallStrategy(SRS, ORS, CS, (strat_to`expr_(CS', Strat), TRS), M)
    = applySubst(Strat, applyMapsToSubst(SRS, ORS, pseudoMatch(CS', CS, M, none), M)) .
  eq imageOfCallStrategy(SRS, ORS, CS, strat_to`expr_(CS', Strat), M)
    = applySubst(Strat, applyMapsToSubst(SRS, ORS, pseudoMatch(CS', CS, M, none), M)) .
  eq imageOfCallStrategy(SRS, ORS, F[[TL]], TRS, M)
    = F [[ applyMapsToTerm2(SRS, ORS, TL, M) ]]
    [owise] .

  eq pseudoMatch(CS, CS', M, Subst)
    = pseudoMatchResult(pseudoMatchCS(CS, CS', M, Subst)) .

  eq pseudoMatchCS(F[[TL]], F'[[TL']], M, Subst)
    = if F == F'
      then pseudoMatch2(TL, TL', M, Subst)
      else none
      fi .

  op getRightStratMaps : Qid TypeList RenamingSet Module -> RenamingSet .
  eq getRightStratMaps(F, TyL, (strat F to F'), M) = (strat F to F') .
  eq getRightStratMaps(F, TyL, (strat F to F', RS), M)
    = (strat F to F', getRightStratMaps(F, TyL, RS, M)) .
  eq getRightStratMaps(F, TyL, (strat F : TyL' @ Ty to F', RS), M)
    = if sameKind(M, TyL, TyL')
      then strat F : TyL' @ Ty to F'
      else none
      fi,
      getRightStratMaps(F, TyL, RS, M) .
  eq getRightStratMaps(F, TyL, strat F : TyL' @ Ty to F', M)
    = if sameKind(M, TyL, TyL')
      then strat F : TyL' @ Ty to F'
      else none
      fi .
  eq getRightStratMaps(F, TyL, (strat_to`expr_(F[[TL]], Strat), RS), M)
    = if sameKind(M, TyL, varListSort(TL))
      then strat_to`expr_(F[[TL]], Strat)
      else none
      fi,
      getRightStratMaps(F, TyL, RS, M) .
  eq getRightStratMaps(F, TyL, strat_to`expr_(F[[TL]], Strat), M)
    = if sameKind(M, TyL, varListSort(TL))
      then strat_to`expr_(F[[TL]], Strat)
      else none
      fi .
  eq getRightStratMaps(F, TyL:[Type], RS, M) = none [owise].

  op applyMapsToStrategy : RenamingSet RenamingSet RenamingSet Strategy Module -> Strategy .
  op applyMapsToStrategies : RenamingSet RenamingSet RenamingSet StrategyList Module -> StrategyList .
  op applyMapsToUPS : RenamingSet RenamingSet RenamingSet UsingPairSet Module -> UsingPairSet .

  eq applyMapsToStrategy(SRS, ORS, TRS, F[[TL]], M)
    = imageOfCallStrategy(SRS, ORS, F[[TL]], getRightStratMaps(F, eLeastSort(M, TL), TRS, M), M) .
  eq applyMapsToStrategy(SRS, ORS, TRS, fail, M) = fail .
  eq applyMapsToStrategy(SRS, ORS, TRS, idle, M) = idle .
  eq applyMapsToStrategy(SRS, ORS, TRS, all, M) = all .
  eq applyMapsToStrategy(SRS, ORS, TRS, QI[Subst]{Strats}, M)
    = QI [ applyMapsToSubst(SRS, ORS, Subst, M) ]
         { applyMapsToStrategies(SRS, ORS, TRS, Strats, M) } .
  eq applyMapsToStrategy(SRS, ORS, TRS, top(Strat), M)
    = top(applyMapsToStrategy(SRS, ORS, TRS, Strat, M)) .
  eq applyMapsToStrategy(SRS, ORS, TRS, match T s.t. Cond, M)
    = match applyMapsToTerm2(SRS, ORS, T, M) s.t. applyMapsToCond(SRS, ORS, Cond, M) .
  eq applyMapsToStrategy(SRS, ORS, TRS, xmatch T s.t. Cond, M)
    = xmatch applyMapsToTerm2(SRS, ORS, T, M) s.t. applyMapsToCond(SRS, ORS, Cond, M) .
  eq applyMapsToStrategy(SRS, ORS, TRS, amatch T s.t. Cond, M)
    = amatch applyMapsToTerm2(SRS, ORS, T, M) s.t. applyMapsToCond(SRS, ORS, Cond, M) .
  eq applyMapsToStrategy(SRS, ORS, TRS, Strat or-else Strat', M)
    = applyMapsToStrategy(SRS, ORS, TRS, Strat, M) or-else applyMapsToStrategy(SRS, ORS, TRS, Strat', M) .
  eq applyMapsToStrategy(SRS, ORS, TRS, Strat +, M)
    = applyMapsToStrategy(SRS, ORS, TRS, Strat, M) + .
  eq applyMapsToStrategy(SRS, ORS, TRS, Strat ? Strat' : Strat'', M)
    = applyMapsToStrategy(SRS, ORS, TRS, Strat, M) ?
      applyMapsToStrategy(SRS, ORS, TRS, Strat', M) :
      applyMapsToStrategy(SRS, ORS, TRS, Strat'', M) .
  eq applyMapsToStrategy(SRS, ORS, TRS, matchrew T s.t. Cond by UPS, M)
    = matchrew applyMapsToTerm2(SRS, ORS, T, M) s.t. applyMapsToCond(SRS, ORS, Cond, M)
        by applyMapsToUPS(SRS, ORS, TRS, UPS, M) .
  eq applyMapsToStrategy(SRS, ORS, TRS, xmatchrew T s.t. Cond by UPS, M)
    = xmatchrew applyMapsToTerm2(SRS, ORS, T, M) s.t. applyMapsToCond(SRS, ORS, Cond, M)
        by applyMapsToUPS(SRS, ORS, TRS, UPS, M) .
  eq applyMapsToStrategy(SRS, ORS, TRS, amatchrew T s.t. Cond by UPS, M)
    = amatchrew applyMapsToTerm2(SRS, ORS, T, M) s.t. applyMapsToCond(SRS, ORS, Cond, M)
        by applyMapsToUPS(SRS, ORS, TRS, UPS, M) .
  eq applyMapsToStrategy(SRS, ORS, TRS, one(Strat), M)
    = one(applyMapsToStrategy(SRS, ORS, TRS, Strat, M)) .
  eq applyMapsToStrategy(SRS, ORS, TRS, Strat *, M)
    = applyMapsToStrategy(SRS, ORS, TRS, Strat, M) * .
  eq applyMapsToStrategy(SRS, ORS, TRS, Strat !, M)
    = applyMapsToStrategy(SRS, ORS, TRS, Strat, M) ! .
  eq applyMapsToStrategy(SRS, ORS, TRS, not(Strat), M)
    = not(applyMapsToStrategy(SRS, ORS, TRS, Strat, M)) .
  eq applyMapsToStrategy(SRS, ORS, TRS, test(Strat), M)
    = test(applyMapsToStrategy(SRS, ORS, TRS, Strat, M)) .
  eq applyMapsToStrategy(SRS, ORS, TRS, try(Strat), M)
    = try(applyMapsToStrategy(SRS, ORS, TRS, Strat, M)) .
  ceq applyMapsToStrategy(SRS, ORS, TRS, Strat | Strat', M)
     = applyMapsToStrategy(SRS, ORS, TRS, Strat, M) | applyMapsToStrategy(SRS, ORS, TRS, Strat', M)
     if Strat =/= fail /\ Strat' =/= fail .
  ceq applyMapsToStrategy(SRS, ORS, TRS, Strat ; Strat', M)
     = applyMapsToStrategy(SRS, ORS, TRS, Strat, M) ; applyMapsToStrategy(SRS, ORS, TRS, Strat', M)
     if Strat =/= idle /\ Strat' =/= idle .

  eq applyMapsToStrategies(SRS, ORS, TRS, (Strat, Strats), M)
    = applyMapsToStrategy(SRS, ORS, TRS, Strat, M) .
  eq applyMapsToStrategies(SRS, ORS, TRS, empty, M) = empty .

  eq applyMapsToUPS(SRS, ORS, TRS, (V using Strat, UPS), M)
    = applyMapsToVars(SRS, V) using applyMapsToStrategy(SRS, ORS, TRS, Strat, M),
      applyMapsToUPS(SRS, ORS, TRS, UPS, M) .
  eq applyMapsToUPS(SRS, ORS, TRS, V using Strat, M)
    = applyMapsToVars(SRS, V) using applyMapsToStrategy(SRS, ORS, TRS, Strat, M) .

  op applySubst : StrategyList Substitution -> StrategyList .
  eq applySubst(F[[TL]], Subst) = F[[applySubst(TL, Subst)]] .
  eq applySubst(fail, Subst) = fail .
  eq applySubst(idle, Subst) = idle .
  eq applySubst(all, Subst) = all .
  eq applySubst(QI[Subst]{Strats}, Subst') = QI [ applySubst(Subst, Subst') ] { applySubst(Strats, Subst') } .
  eq applySubst(top(Strat), Subst) = top(applySubst(Strat, Subst)) .
  eq applySubst(match T s.t. Cond, Subst) = match applySubst(T, Subst) s.t. applySubst(Cond, Subst) .
  eq applySubst(xmatch T s.t. Cond, Subst) = xmatch applySubst(T, Subst) s.t. applySubst(Cond, Subst) .
  eq applySubst(amatch T s.t. Cond, Subst) = amatch applySubst(T, Subst) s.t. applySubst(Cond, Subst) .
  eq applySubst(Strat | Strat', Subst) = applySubst(Strat, Subst) | applySubst(Strat', Subst) .
  eq applySubst(Strat ; Strat', Subst) = applySubst(Strat, Subst) ; applySubst(Strat', Subst) .
  eq applySubst(Strat or-else Strat', Subst) = applySubst(Strat, Subst) or-else applySubst(Strat', Subst) .
  eq applySubst(Strat +, Subst) = applySubst(Strat, Subst) + .
  eq applySubst(Strat ? Strat' : Strat'', Subst)
    = applySubst(Strat, Subst) ? applySubst(Strat', Subst) : applySubst(Strat'', Subst) .
  eq applySubst(matchrew T s.t. Cond by UPS, Subst)
    = matchrew applySubst(T, Subst) s.t. applySubst(Cond, Subst) by applySubst(UPS, Subst) .
  eq applySubst(xmatchrew T s.t. Cond by UPS, Subst)
    = xmatchrew applySubst(T, Subst) s.t. applySubst(Cond, Subst) by applySubst(UPS, Subst) .
  eq applySubst(amatchrew T s.t. Cond by UPS, Subst)
    = amatchrew applySubst(T, Subst) s.t. applySubst(Cond, Subst) by applySubst(UPS, Subst) .
  eq applySubst(one(Strat), Subst)
    = one(applySubst(Strat, Subst)) .
  eq applySubst(Strat *, Subst)
    = applySubst(Strat, Subst) * .
  eq applySubst(Strat !, Subst)
    = applySubst(Strat, Subst) ! .
  eq applySubst(not(Strat), Subst)
    = not(applySubst(Strat, Subst)) .
  eq applySubst(test(Strat), Subst)
    = test(applySubst(Strat, Subst)) .
  eq applySubst(try(Strat), Subst)
    = try(applySubst(Strat, Subst)) .

  op applySubst : UsingPairSet Substitution -> UsingPairSet .
  eq applySubst((V using Strat, UPS), Subst)
    = applySubst(V, Subst) using applySubst(Strat, Subst), applySubst(UPS, Subst) .
  eq applySubst(V using Strat, Subst) = applySubst(V, Subst) using applySubst(Strat, Subst) .

endfm

*******************************************************************************

***
*** 6.9 Instantiation of Parameterized Modules and the
***     \texttt{META-LEVEL} Module Expression

*** A parameterized module
*** $\texttt{M[L}_1\texttt{\ ::\ T}_1\texttt{,\}\ldots\texttt{, L}_n
*** \texttt{ :: T}_n\texttt{]}$, with \mbox{$\texttt{L}_1\ldots\texttt{L}_n$}
*** labels and \mbox{$\texttt{T}_1\ldots\texttt{T}_n$} theory identifiers, is
*** represented as a module with name \texttt{M} which contains parameter
*** declarations  \mbox{$\texttt{par\ L}_i\texttt{\ ::\ T}_i$} for
*** $1\leq i\leq n$, and an importation declaration
*** \mbox{$\texttt{inc\ par\ L}_i\texttt{\ ::\ T}_i\texttt{\ .}$} for each
*** parameter \mbox{$\texttt{L}_i\texttt{\ ::\ T}_i$} in its interface.  Note
*** that all modules are handled in a uniform way: nonparameterized modules
*** and theories have their list of parameters set to \texttt{nil}.

*** The instantiation of the formal parameters of a parameterized module with
*** actual modules or theories requires a view from each formal parameter
*** theory to its corresponding actual unit. The process of instantiation
*** results in the replacement of each interface theory by its corresponding
*** actual parameter, using the views to bind actual names to formal names.

*** The naming conventions for sorts have to be taken into account in the
*** instantiation process: every occurrence of a sort coming from a theory in
*** the interface of a module must be qualified by its theory's label, and
*** sorts defined in the body of a parameterized module can be parameterized
*** by the labels in the interface of the module (see
*** Section~\ref{parameterized-modules}).

*** The labeling convention for theories and for the sorts coming from them is
*** very useful to avoid collisions of sort names coming from the parameter
*** theories, and also to allow different uses of the same theory several
*** times in the interface of a module. We assume that all sorts coming from
*** the theory part of the parameter theories are used in their qualified form
*** to manipulate the maps defined in the views before being applied to the
*** body of the module being instantiated. If the target of a view is a
*** theory, the sorts from the theory part of the target theory appearing in
*** the targTS of the maps in the view will be qualified as well, following
*** the same convention.

*** When a parameterized module
*** $\texttt{M[L}_1\texttt{\ ::\ T}_1\texttt{,\ }
***            \ldots\texttt{,\ L}_n\texttt{\ ::\ T}_n\texttt{]}$
*** is instantiated with views $\texttt{V}_1\ldots\texttt{V}_n$, each
*** parameterized sort $\texttt{S[L}_1\texttt{,}\ldots\texttt{,L}_n\texttt{]}$
*** in the body of the parameterized module is renamed to
*** $\texttt{S[V}_1\texttt{,}\ldots\texttt{,V}_n\texttt{]}$.

*** The discussion on the qualification of sorts in views before being used in
*** the instantiation process applies in a completely similar way to class
*** names in parameterized object-oriented modules.

*** As we saw in Section~\ref{module-expressions}, it is possible to import a
*** module expression in which a parameterized module is instantiated by some
*** of the formal parameters of the parameterized module in which it is
*** imported. This is done by using the label of some of the parameters in the
*** interface of a module, say \mbox{$\texttt{L}_k\texttt{\ ::\ T}_k$}, in a
*** module expression in which some parameterized module \texttt{N} with formal
*** parameter $\texttt{T}_k$ is instantiated with $\texttt{L}_k$, that is, we
*** have the module expression $\texttt{N[}\ldots\texttt{L}_k\ldots\texttt{]}$.
*** In this case, $\texttt{L}_k$ is considered as the identity view for the
*** theory $\texttt{T}_k$ with $\texttt{L}_k$ as name. Note that to be able to
*** check whether a label in the interface of a module is used in an
*** instantiation of this form, in the evaluation of a module expression the
*** list of parameters of the module in which the module expression appears
*** must be available. This is the reason why the \texttt{evalModExp} function
*** was defined with \texttt{ParameterList} as one of the sorts in its
*** arity (see Section~\ref{evalModExp}). For module expressions appearing
*** outside of any module, that is, in commands, etc., this list will be set
*** to \texttt{nil}.

*** Note that this kind of instantiation may produce a `cascade' effect. The
*** module being instantiated may itself import other module expressions in
*** which labels of some of its parameter theories are used in the
*** instantiation of some of these imported module expressions. This is handled
*** by `preparing' the module expressions appearing in the importation
*** declarations of the module (\texttt{prepImports}). This process
*** consists in changing the labels of the interface of the module being
*** instantiated which are used in the importations of module expressions by
*** the corresponding view names (\texttt{prepHeader}). After completing the
*** generation of the module resulting from the evaluation of the module
*** expression, this module will be evaluated with the \texttt{evalModule}
*** function, producing the evaluation of these new module expressions. In any
*** extension of the language, new equations for the function
*** \texttt{prepHeader} will have to be added for each new kind of module
*** expression being defined.

*** In Sections~\ref{renaming} and~\ref{extension} we shall see how new
*** equations completing the semantics of \texttt{prepHeader} are added for
*** each new module expression being defined. In the case of the renaming
*** module expression, the renaming maps will have to be prepared as well, to
*** adjust the sort names being renamed to the conventions discussed above.

*** As for any other module expression being defined, in addition to the
*** operator declaration for the constructor of the instantiation module
*** expression, equations completing the semantics of operators
*** \texttt{evalModExp}, \texttt{header2QidList}, and
*** \texttt{setUpModExpDeps} have to be given.

fmod FM-INST-EXPR-EVALUATION is
  pr FM-EVALUATION .
  pr FM-RENAMING-SET-APPL-ON-UNIT .
  inc MOD-EXPR .
  inc MOD-NAME .
  pr DATABASE .

*** We start by giving the new constructor for sort \texttt{ModuleExpression}.
*** Note that the modules \texttt{MOD-EXPR} and \texttt{MOD-NAME} have been
*** imported in \texttt{including} mode.

  vars QI QI' QI'' X Y W Z C F F' A A' L L' : Qid .
  var  QIL : QidList .
  vars M M' PU U U' U'' DM : Module .
  var  Th : Theory .
  vars ME ME' ME'' ME''' : ModuleExpression .
  var  H : Header .
  vars MN MN' : ModuleName .
  vars MNS MNS' MNS'' MNS3 MNS4 MNS5 : Set{ModuleName} .
  vars VE VE' VE'' VE3 VE4 : ViewExpression .
  vars VES VES' : Set{ViewExpression} .
  vars MIS MIS' : Set{ModuleInfo} .
  var  VIS : Set{ViewInfo} .
  vars DB DB' DB'' DB''' : Database .
  var  PD : ParameterDecl .
  vars PDL PDL' PDL'' PDL3 PDL4 PDL5 : ParameterDeclList .
  var  PDS : Set{ParameterDecl} .
  vars PL PL' PL'' PL3 : ParameterList .
  vars S S' P P' P'' : Sort .
  vars IL IL' IL'' IL3 : ImportList .
  vars SMS SMS' SMS'' SMS3 : SortMappingSet .
  vars OMS OMS' OMS'' OMS3 : OpMappingSet .
  vars TMS TMS' TMS'' TMS3 : StratMappingSet .
  var  V : Variable .
  var  Ct : Constant .
  var  SL : QidList .
  var  Ty : Type .
  var  TyL : TypeList .
  vars SS SS' SS'' : SortSet .
  var  K : Kind .
  vars T T' O : Term .
  var  DT : Default{Term} .
  var  TL : TermList .
  var  CDS : ClassDeclSet .
  var  ADS : AttrDeclSet .
  var  B : Bool .
  var  AtS : AttrSet .
  var  N : Nat .
  var  PV : PreView .
  var  VI : View .
  var  VDS : VariableSet .
  vars RS RS' RS'' SRS SRS' ORS ORS' : RenamingSet .

*** In the input given by the user, the operator \verb~_(_)~ is used both for
*** the instantiation of module expressions, and for expressions
*** parameterizing the module \texttt{META-LEVEL} with a list of module names.
*** The function \texttt{evalModExp} distinguishes these two cases, calling
*** the function \texttt{unitInst} in the former and the function
*** \texttt{prepMetalevel} in the latter.

  op unitInst : Header ParameterList ParameterDeclList Database -> Database .
  op prepMetalevel : ParameterList Database -> Database .

  eq evalModExp(ME{PL}, PDL, DB)
    = if unitInDb(ME{PL}, DB)
      then < DB ; ME{PL} >
      else if ME == 'META-LEVEL
           then < prepMetalevel(PL, DB) ; ME{PL} >
           else < unitInst(
                    modExp(evalModExp(ME, PDL, evalViewExpression(PL, PDL, DB))),
                    PL, PDL,
                    database(evalModExp(ME, PDL, evalViewExpression(PL, PDL, DB))))
                  ;
                  modExp(evalModExp(ME, PDL, evalViewExpression(PL, PDL, DB))){PL} >
           fi
      fi .

*** The function \texttt{prepMetalevel} creates a new module with the
*** module expression being evaluated as name, which imports the predefined
*** \texttt{META-LEVEL} module. For each module name \texttt{I} in the list
*** given as parameter of the expression, the declaration of a constant
*** \texttt{I} of sort \texttt{Module} and an equation identifying such
*** constant with the metarepresentation of the module with such name in the
*** database are added to the module being created.

  op prepMetalevelAux : ParameterList Module Database -> Database .

  eq prepMetalevel(PL, DB)
    = prepMetalevelAux(PL,
        addImports((including 'META-LEVEL .),
          setName(emptyFModule, 'META-LEVEL{PL})), DB) .

  eq prepMetalevelAux((QI), U, DB)
    = prepMetalevelAux(nil,
        addOps((op qid("META-" + string(QI)) : nil -> 'Module [none] .),
          addEqs((eq qid("META-" + string(QI) + ".Module")
                    = up(getFlatModule(QI, database(evalModExp(QI, DB))))
                    [none] .),
            U)),
        DB) .
  eq prepMetalevelAux((QI, PL), U, DB)
    = prepMetalevelAux(PL,
        addOps((op qid("META-" + string(QI)) : nil -> 'Module [none] .),
          addEqs((eq qid("META-" + string(QI) + ".Module")
                    = up(getFlatModule(QI, database(evalModExp(QI, DB))))
                    [none] .),
            U)),
        DB) .
  eq prepMetalevelAux(nil, U, DB) = evalModule(U, none, DB) .

*** The function \texttt{getClassNames} returns the set of the names of
*** the classes in a set of class declarations.

  op getClassNames : ClassDeclSet -> SortSet .

  eq getClassNames(((class S | ADS .) CDS))
    = (S ; getClassNames(CDS)) .
  eq getClassNames(none) = none .

*** The following `getTh' functions return the corresponding elements in the
*** theory part of the structure of the given unit. For example, the function
*** \texttt{getThSorts} returns the set of sorts declared in the ``loose
*** part'' of the structure of the unit in the database having the name
*** indicated as first argument.

  op getThSorts : ModuleExpression Database -> SortSet .
  op getThClasses : ModuleExpression Database -> SortSet .
  op getThSortsAux : ImportList Database -> SortSet .
  op getThClassesAux : ImportList Database -> SortSet .

  eq getThSorts(ME, DB)
    = if theory(getTopModule(ME, DB))
      then (getThSortsAux(getImports(getTopModule(ME, DB)), DB) ;
            getSorts(getTopModule(ME, DB)))
      else none
      fi .

  eq getThSortsAux(((including MN .) IL), DB)
    = (getThSorts(MN, DB) ; getThSortsAux(IL, DB)) .
  eq getThSortsAux(((extending MN .) IL), DB)
    = (getThSorts(MN, DB) ; getThSortsAux(IL, DB)) .
  eq getThSortsAux(((protecting MN .) IL), DB)
    = (getThSorts(MN, DB) ; getThSortsAux(IL, DB)) .
  eq getThSortsAux(nil, DB) = none .

  eq getThClasses(ME, DB)
    = if getTopModule(ME, DB) :: OTheory
         and-then not getTopModule(ME, DB) :: STheory
      then (getThClassesAux(getImports(getTopModule(ME, DB)), DB) ;
            getClassNames(getClasses(getTopModule(ME, DB))))
      else none
      fi .

  eq getThClassesAux(((including MN .) IL), DB)
    = (getThClasses(MN, DB) ; getThClassesAux(IL, DB)) .
  eq getThClassesAux(((extending MN .) IL), DB)
    = (getThClasses(MN, DB) ; getThClassesAux(IL, DB)) .
  eq getThClassesAux(((protecting MN .) IL), DB)
    = (getThClasses(MN, DB) ; getThClassesAux(IL, DB)) .
  eq getThClassesAux(nil, DB) = none .

*** The `get' functions return the corresponding elements in the structure of
*** the given unit. For example, \texttt{getSortSet} returns all the sorts
*** declared in the structure of the unit in the database having the name
*** given as first argument.

  op getSortSet : ModuleName Database -> SortSet .
  op getClassSet : ModuleName Database -> SortSet .

  op getSortSetAux : ImportList Database -> SortSet .
  op getClassSetAux : ImportList Database -> SortSet .

  eq getSortSet(MN, DB)
    = (getSortSetAux(getImports(getTopModule(MN, DB)), DB) ;
       getSorts(getTopModule(MN, DB))) .

  eq getSortSetAux(((including MN .) IL), DB)
    = (getSortSet(MN, DB) ; getSortSetAux(IL, DB)) .
  eq getSortSetAux(((extending MN .) IL), DB)
    = (getSortSet(MN, DB) ; getSortSetAux(IL, DB)) .
  eq getSortSetAux(((protecting MN .) IL), DB)
    = (getSortSet(MN, DB) ; getSortSetAux(IL, DB)) .
  eq getSortSetAux(nil, DB) = none .

  eq getClassSet(MN, DB)
    = (getClassSetAux(getImports(getTopModule(MN, DB)), DB) ;
       getClassNames(getClasses(getTopModule(MN, DB)))) .

  eq getClassSetAux(((including MN .) IL), DB)
    = (getClassSet(MN, DB) ; getClassSetAux(IL, DB)) .
  eq getClassSetAux(((extending MN .) IL), DB)
    = (getClassSet(MN, DB) ; getClassSetAux(IL, DB)) .
  eq getClassSetAux(((protecting MN .) IL), DB)
    = (getClassSet(MN, DB) ; getClassSetAux(IL, DB)) .
  eq getClassSetAux(nil, DB) = none .

*** As pointed out in Section~\ref{parameterized-modules}, in a parameterized
*** module all occurrences of sorts or classes coming from the parameter
*** theories have to be qualified. \texttt{createCopy} is the function used
*** for creating these renamed copies of the parameters. As also explained in
*** Section~\ref{parameterized-modules}, if a parameter theory is structured,
*** the renaming is carried out not only at the top level, but for the entire
*** ``theory part'' in the structure.

*** The function \texttt{createCopy} calls an auxiliary function,
*** \texttt{prepPar}, which recursively proceeds through all the subtheories
*** of the given theory. For each theory in the structure, the required set of
*** maps is generated and applied to such a theory using the
*** \texttt{applyMapsToModule} function discussed in
*** Section~\ref{applyMapsToModule}, which is then evaluated and entered into
*** the database. Note that the renamings to which a theory is subjected must
*** also be applied to the theories importing it. The new database and the
*** renaming maps applied to the theory will have to be returned by the
*** function.

*** The function \texttt{prepPar} makes a copy of the theory specified by the
*** name given as first argument and of all its subtheories (only theories, no
*** modules), and qualifies all the sorts appearing in it with the label given
*** in the declaration of the parameter, which is given as second argument.

  pr SET{Tuple{ViewExpression,ViewExpression}}
       * (op `(_`,_`) : ViewExpression ViewExpression
            -> Tuple{ViewExpression,ViewExpression} to <_;_>,
          op p1_ : Tuple{ViewExpression,ViewExpression} -> ViewExpression to 1st,
          op p2_ : Tuple{ViewExpression,ViewExpression} -> ViewExpression to 2nd,
          op empty : -> Set{Tuple{ViewExpression,ViewExpression}} to none,
          op _,_ : Set{Tuple{ViewExpression,ViewExpression}}
                   Set{Tuple{ViewExpression,ViewExpression}} ->
                   Set{Tuple{ViewExpression,ViewExpression}} to __) .

----  pr 2TUPLE{ViewExpression,ViewExpression}
----       * (op ((_,_)) to <_;_>,
----          op p1_ to 1st,
----          op p2_ to 2nd).

----  sorts Tuple{ViewExpression,ViewExpression}
----        Set{Tuple{ViewExpression,ViewExpression}} .
----  sort PrepParResult  .
----  subsort Tuple{ViewExpression,ViewExpression}
----          < Set{Tuple{ViewExpression,ViewExpression}} .
----  op <_;_> : ViewExpression ViewExpression -> Tuple{ViewExpression, ViewExpression} .
----  ops 1st 2nd : Tuple{ViewExpression,ViewExpression} -> ViewExpression .
----  op none : -> Set{Tuple{ViewExpression,ViewExpression}} .
----  op __ : Set{Tuple{ViewExpression,ViewExpression}}
----          Set{Tuple{ViewExpression,ViewExpression}}
----          -> Set{Tuple{ViewExpression,ViewExpression}} [assoc comm id: none] .

  vars VEPS VEPS' : Set{Tuple{ViewExpression,ViewExpression}} .

----  eq 1st(< VE ; VE' >) = VE .
----  eq 2nd(< VE ; VE' >) = VE' .

  op prepPar : Qid Qid ModuleExpression Database -> PrepParResult .
  op prepParImports : ImportList ImportList Qid Qid SortMappingSet OpMappingSet
        StratMappingSet Set{Tuple{ViewExpression,ViewExpression}} ParameterDeclList
        Database -> PrepParResult .

  pr 9TUPLE{SortMappingSet, OpMappingSet, StratMappingSet, Database, ViewExpression,
            ViewExpression, Set{Tuple{ViewExpression,ViewExpression}}, Bool,
            ImportList}
       * (sort Tuple{SortMappingSet, OpMappingSet, StratMappingSet, Database,
                     ViewExpression, ViewExpression,
                     Set{Tuple{ViewExpression,ViewExpression}}, Bool, ImportList}
                     to PrepParResult,
          op ((_,_,_,_,_,_,_,_,_)) to <_;_;_;_;_;_;_;_;_>,
          op p1_ to sortMappingSet,
          op p2_ to opMappingSet,
          op p3_ to stratMappingSet,
          op p4_ to database,
          op p5_ to sourceViewExpression,
          op p6_ to targetViewExpression,
          op p7_ to viewExpPairSet,
          op p8_ to theoryFlag,
          op p9_ to getImports) .
---(
  op <_;_;_;_;_;_;_;_> : SortMappingSet OpMappingSet Database ViewExpression ViewExpression Set{Tuple{ViewExpression,ViewExpression}} Bool ImportList -> PrepParResult .
  op sortMappingSet : PrepParResult -> SortMappingSet .
  op opMappingSet : PrepParResult -> OpMappingSet .
  op database : PrepParResult -> Database .
  op sourceViewExpression : PrepParResult -> ViewExpression .
  op targetViewExpression : PrepParResult -> ViewExpression .
  op viewExpPairSet : PrepParResult -> Set{Tuple{ViewExpression,ViewExpression}} .
  op theoryFlag : PrepParResult -> Bool .
  op getImports : PrepParResult -> ImportList .
  eq opMappingSet(< SMS ; OMS ; DB ; VE ; VE' ; VEPS ; B ; IL >) = OMS .
  eq sortMappingSet(< SMS ; OMS ; DB ; VE ; VE' ; VEPS ; B ; IL >) = SMS .
  eq database(< SMS ; OMS ; DB ; VE ; VE' ; VEPS ; B ; IL >) = DB .
  eq sourceViewExpression(< SMS ; OMS ; DB ; VE ; VE' ; VEPS ; B ; IL >) = VE .
  eq targetViewExpression(< SMS ; OMS ; DB ; VE ; VE' ; VEPS ; B ; IL >) = VE' .
  eq viewExpPairSet(< SMS ; OMS ; DB ; VE ; VE' ; VEPS ; B ; IL >) = VEPS .
  eq theoryFlag(< SMS ; OMS ; DB ; VE ; VE' ; VEPS ; B ; IL >) = B .
  eq getImports(< SMS ; OMS ; DB ; VE ; VE' ; VEPS ; B ; IL >) = IL .
---)

  ----op createCopy : ParameterDecl Database -> Database .
  op prepPar : Qid ModuleExpression Database  -> PrepParResult .
  op prepParImports : ImportList ImportList Qid SortMappingSet OpMappingSet
        StratMappingSet Set{Tuple{ViewExpression,ViewExpression}} ParameterDeclList
        Database -> PrepParResult .

  eq createCopy(X :: ME, DB)
    = if unitInDb(pd(X :: ME), DB)
      then DB
      else database(prepPar(X, ME, database(evalModExp(ME, DB))))
      fi .

  ceq prepPar(X, ME, DB)
    = < SMS' ;
        OMS ;
        TMS ;
        (if unitInDb(pd(X :: ME), DB)
         then DB
         else evalModule(
                setImports(
                  setName(
                    applyMapsToModule(maps2rens(SMS'), maps2rens(OMS), Th, getFlatModule(ME, DB)),
                    pd(X :: ME)),
                  IL),
                applyMapsToVars(maps2rens(SMS'), maps2rens(OMS), getVars(ME, DB)),
                DB')
         fi) ;
        mtViewExpression ; mtViewExpression ; none ; true ; nil >
    if Th := getTopModule(ME, DB)
       /\ < SMS ; OMS ; TMS ; DB' ; VE ; VE' ; VEPS ; B ; IL >
            := prepParImports(getImports(Th), nil, X,
                 none, none, none, none, X :: ME, DB)
       /\ SMS' := (SMS
                   sortMapsPar(X, getSorts(Th), none)
                   classMapsPar(X, classSet(getClasses(Th)), none)) .
  eq prepPar(X, ME, DB)
    = < none ; none ; none ; warning(DB, '\r 'Error: '\o 'Incorrect 'parameter '\n) ;
        mtViewExpression ; mtViewExpression ; none ; false ; nil >
      [owise] .

  ceq prepParImports(((including ME .) IL), IL', X, SMS, OMS, TMS, VEPS, PDL, DB)
    = if B
      then prepParImports(IL, (IL' (including pd(X :: ME') .)), X,
             (SMS SMS'), (OMS OMS'), (TMS TMS'), VEPS, PDL, DB')
      else prepParImports(IL, (IL' (including ME .)), X,
             SMS, OMS, TMS, VEPS, PDL, DB)
      fi
    if ME' := prepModExp(ME, VEPS)
    /\ < SMS' ; OMS' ; TMS' ; DB' ; VE ; VE' ; VEPS' ; B ; IL'' >
         := prepPar(X, ME', database(evalModExp(ME', PDL, DB))) .
  ceq prepParImports(((extending ME .) IL), IL', X, SMS, OMS, TMS, VEPS, PDL, DB)
    = if B
      then *** A theory shouldn't be imported in protecting mode
           prepParImports(IL, (IL' (extending pd(X :: ME') .)), X,
             (SMS SMS'), (OMS OMS'), (TMS TMS'), VEPS, PDL, DB')
      else prepParImports(IL, (IL' (extending ME .)), X,
             SMS, OMS, TMS, VEPS, PDL, DB)
      fi
    if ME' := prepModExp(ME, VEPS)
    /\ < SMS' ; OMS' ; TMS' ; DB' ; VE ; VE' ; VEPS' ; B ; IL'' >
         := prepPar(X, ME', database(evalModExp(ME', PDL, DB))) .
  ceq prepParImports(((protecting ME .) IL), IL', X, SMS, OMS, TMS, VEPS, PDL, DB)
    = if B
      then *** A theory shouldn't be imported in protecting mode
           prepParImports(IL, (IL' (protecting pd(X :: ME') .)), X,
              (SMS SMS'), (OMS OMS'), (TMS TMS'), VEPS, PDL, DB')
      else prepParImports(IL, (IL' (protecting ME .)), X,
              SMS, OMS, TMS, VEPS, PDL, DB)
      fi
    if ME' := prepModExp(ME, VEPS)
    /\ < SMS' ; OMS' ; TMS' ; DB' ; VE ; VE' ; VEPS' ; B ; IL'' >
         := prepPar(X, ME', database(evalModExp(ME', PDL, DB))) .
  ceq prepParImports(((including pd(X :: ME) .) IL), IL', Y,
        SMS, OMS, TMS, (< X ; Z > VEPS), PDL, DB)
    = prepParImports(IL, (IL' (including pd(Z :: ME') .)), Y,
        (SMS SMS'), (OMS OMS'), (TMS TMS'), (< X ; Z > VEPS), PDL, DB')
    if ME' := prepModExp(ME, VEPS)
    /\ < SMS' ; OMS' ; TMS' ; DB' ; VE ; VE' ; VEPS' ; B ; IL'' >
         := prepPar(X, ME', database(evalModExp(ME', PDL, DB))) .
  ceq prepParImports(((extending pd(X :: ME) .) IL), IL', Y,
        SMS, OMS, TMS, (< X ; Z > VEPS), PDL, DB)
    = prepParImports(IL, (IL' (extending pd(Z :: ME') .)), Y,
        (SMS SMS'), (OMS OMS'), (TMS TMS'), (< X ; Z > VEPS), PDL, DB')
    if ME' := prepModExp(ME, VEPS)
    /\ < SMS' ; OMS' ; TMS' ; DB' ; VE ; VE' ; VEPS' ; B ; IL'' >
         := prepPar(X, ME', database(evalModExp(ME', PDL, DB))) .
  ceq prepParImports(((protecting pd(X :: ME) .) IL), IL', Y,
        SMS, OMS, TMS, (< X ; Z > VEPS), PDL, DB)
    = prepParImports(IL, (IL' (protecting pd(Z :: ME') .)), Y,
        (SMS SMS'), (OMS OMS'), (TMS TMS'), (< X ; Z > VEPS), PDL, DB')
    if ME' := prepModExp(ME, VEPS)
    /\ < SMS' ; OMS' ; TMS' ; DB' ; VE ; VE' ; VEPS' ; B ; IL'' >
         := prepPar(X, ME', database(evalModExp(ME', PDL, DB))) .
  eq prepParImports(nil, IL, X, SMS, OMS, TMS, VEPS, PDL, DB)
    = < SMS ; OMS ; TMS ; DB ; mtViewExpression ; mtViewExpression ; none ;
        false ; IL > .

  ceq prepPar(X, Y, ME, DB)
    = (< SMS' ; OMS ; TMS ;
        (if unitInDb(pd(Y :: ME), DB)
         then DB
         else evalModule(
                setImports(
                  setName(
                    applyMapsToModule(maps2rens(SMS'), maps2rens(OMS), getTopModule(pd(X :: ME), DB), getFlatModule(pd(X :: ME), DB)),
                    pd(Y :: ME)),
                  IL),
                applyMapsToVars(maps2rens(SMS'), maps2rens(OMS), getVars(pd(X :: ME), DB)),
                DB')
         fi) ;
        X ; Y ; < X ; Y > ; true ; nil >)
    if Th := getTopModule(ME, DB)
    /\ (< SMS ; OMS ; TMS ; DB' ; VE ; VE' ; VEPS ; B ; IL >)
          := prepParImports(getImports(Th), nil, X, Y, none, none, none,
               < X ; Y >, X :: ME, DB)
    /\ SMS' := (SMS
                genMapsQualSorts(X, Y, getSorts(Th), none)
                genMapsQualClasses(X, Y, classSet(getClasses(Th)), none)) .

  eq prepParImports(((including ME .) IL), IL', X, Y, SMS, OMS, TMS, VEPS, PDL, DB)
    = prepParImports(IL, (IL' including ME .), X, Y, SMS, OMS, TMS, VEPS, PDL, DB) .
  eq prepParImports(((extending ME .) IL), IL', X, Y, SMS, OMS, TMS, VEPS, PDL, DB)
    = prepParImports(IL, (IL' extending ME .), X, Y, SMS, OMS, TMS, VEPS, PDL, DB) .
  eq prepParImports(((protecting ME .) IL), IL', X, Y, SMS, OMS, TMS, VEPS, PDL, DB)
    = prepParImports(IL, (IL' protecting ME .), X, Y, SMS, OMS, TMS, VEPS, PDL, DB) .
  ceq prepParImports(including pd(X :: ME) . IL, IL', Y, Z, SMS, OMS, TMS, VEPS, PDL, DB)
    = prepParImports(IL, IL' including pd(X :: ME') ., Y, Z,
        (SMS SMS'), (OMS OMS'), (TMS TMS'), VEPS, PDL, DB')
    if ME' := prepModExp(ME, VEPS)
    /\ < SMS' ; OMS' ; TMS' ; DB' ; VE ; VE' ; VEPS' ; B ; IL'' >
         := prepPar(Y, Z, ME', database(evalModExp(ME', PDL, DB))) .
  ceq prepParImports(extending pd(X :: ME) . IL, IL', Y, Z, SMS, OMS, TMS, VEPS, PDL, DB)
    = prepParImports(IL, IL' extending pd(X :: ME') ., Y, Z,
        (SMS SMS'), (OMS OMS'), (TMS TMS'), VEPS, PDL, DB')
    if ME' := prepModExp(ME, VEPS)
    /\ < SMS' ; OMS' ; TMS' ; DB' ; VE ; VE' ; VEPS' ; B ; IL'' >
         := prepPar(Y, Z, ME', database(evalModExp(ME', PDL, DB))) .
  ceq prepParImports(protecting pd(X :: ME) . IL, IL', Y, Z,
        SMS, OMS, TMS, VEPS, PDL, DB)
    = prepParImports(IL, IL' protecting pd(X :: ME') ., Y, Z,
        (SMS SMS'), (OMS OMS'), (TMS TMS'), VEPS, PDL, DB')
    if ME' := prepModExp(ME, VEPS)
    /\ < SMS' ; OMS' ; TMS' ; DB' ; VE ; VE' ; VEPS' ; B ; IL'' >
         := prepPar(Y, Z, ME', database(evalModExp(ME', PDL, DB))) .
  eq prepParImports(nil, IL, X, Y, SMS, OMS, TMS, VEPS, PDL, DB)
    = < SMS ; OMS ; TMS ; DB ; mtViewExpression ; mtViewExpression ; none ; false ; IL > .

  op sortMapsPar : Qid SortSet Set{Tuple{ViewExpression,ViewExpression}} -> SortMappingSet .
  op classMapsPar : Qid SortSet Set{Tuple{ViewExpression,ViewExpression}} -> SortMappingSet .

  op qualify : Qid Sort -> Sort .
  op qualify : Qid Sort Set{Tuple{ViewExpression,ViewExpression}} -> Sort .
  op qualify : Qid Sort ParameterList ParameterList Set{Tuple{ViewExpression,ViewExpression}} -> Sort .

  eq qualify(X, S) = qualify(X, getName(S), getPars(S), empty, none) .

  eq qualify(X, S, VEPS) = qualify(X, getName(S), getPars(S), empty, VEPS) .

  eq qualify(X, S, (P, PL), PL', < P ; P' > VEPS)
    = qualify(X, S, PL, PL' P', < P ; P' > VEPS) .
  eq qualify(X, S, (P, PL), PL', VEPS)
    = qualify(X, S, PL, PL' P, VEPS)
    [owise] .
  eq qualify(X, S, empty, PL, VEPS)
    = qid(string(X) + "$" + string(makeSort(S, PL))) .

  eq sortMapsPar(X, (S ; SS), VEPS)
    = (sort S to qualify(X, S, VEPS) . sortMapsPar(X, SS, VEPS)) .
  eq sortMapsPar(X, none, VEPS) = none .

  eq classMapsPar(X, (S ; SS), VEPS)
    = (class S to qualify(X, S, VEPS) . classMapsPar(X, SS, VEPS)) .
  eq classMapsPar(X, none, VEPS) = none .

*** When one of the labels of the interface of a module is being used in a
*** module expression to instantiate some formal parameter of a module, then,
*** in the evaluation of such module expression the qualification of all sorts
*** and class names coming from the theory part of the parameter theory have
*** to be changed according to such a label. In the evaluation of an
*** instantiation module expression this is done by generating the
*** corresponding renaming maps, which are then applied to the module being
*** instantiated. Given labels \texttt{L} and \texttt{L'}, for each sort or
*** class name \texttt{S} in the set given as argument, a map of the form
*** \verb~L$S to L'$S~ is generated.

  op genMapsQualSorts : Qid Qid SortSet Set{Tuple{ViewExpression,ViewExpression}} -> SortMappingSet .
  op genMapsQualClasses : Qid Qid SortSet Set{Tuple{ViewExpression,ViewExpression}} -> SortMappingSet .

  eq genMapsQualSorts(X, Y, (S ; SS), VEPS)
    = (sort qualify(X, S, VEPS) to qualify(Y, S, VEPS) .
       genMapsQualSorts(X, Y, SS, VEPS)) .
  eq genMapsQualSorts(X, Y, none, VEPS) = none .

  eq genMapsQualClasses(X, Y, (S ; SS), VEPS)
    = (class qualify(X, S, VEPS) to qualify(Y, S, VEPS) .
       genMapsQualClasses(X, Y, SS, VEPS)) .
  eq genMapsQualClasses(X, Y, none, VEPS) = none .

*** The function \texttt{prepare} takes the map set of a view and
*** prepares it to be used in an instantiation by transforming sort and class
*** names into their qualified form, if required (sorts and class names in a
*** view have to be qualified only if they were defined in a theory).

*** The \texttt{prepare} function takes six arguments: The sets of maps
*** to be prepared, the label with which the sorts to be renamed have to be
*** qualified, the set of sorts in the theory part of the source of the view,
*** and the set of sorts and class names in the theory part of the target of
*** the view.

*** Note that we assume that there is a sort map and a class map for each sort
*** and class in the theory part of the source of the view. Therefore, sorts
*** and class names appearing as sources of sort and class maps are
*** systematically qualified. The sorts or class names used in the targets of
*** the maps will be qualified only if they were declared in a theory. In maps
*** for operators in which the arity and coarity are specified, or for those
*** going to derived terms, the sorts appearing in the arity or coarity of an
*** operator and those used to qualify terms, or in sort tests in terms, must
*** also be qualified. However, in these cases the qualification cannot be
*** done on all sorts, but only on those defined in the theory parts. This is
*** the reason why the sets of sorts in the theory parts of the source and
*** target and the set of class names in the target of the view are given when
*** calling \texttt{prepare}.

  op prepare : SortMappingSet Qid SortSet SortSet SortSet -> SortMappingSet .
  op prepare : OpMappingSet Qid SortSet SortSet SortSet -> OpMappingSet .
  op prepare : StratMappingSet Qid SortSet SortSet SortSet -> StratMappingSet .

  op prepare : TypeList Qid SortSet -> TypeList .
  op prepTerm : TermList Qid SortSet -> TermList .

  eq prepare(sort S to S' . SMS, X, SS, SS', SS'')
    = (if S' in SS'
       then sort qualify(X, S) to qualify(X, S') .
       else sort qualify(X, S) to S' .
       fi
       prepare(SMS, X, SS, SS', SS'')) .
  eq prepare(class S to S' . SMS, X, SS, SS', SS'')
    = (if S' in SS''
       then (class qualify(X, S) to qualify(X, S') .)
       else (class qualify(X, S) to S' .)
       fi
       prepare(SMS, X, SS, SS', SS'')) .
  eq prepare((none).SortMappingSet, X, SS, SS', SS'') = none .

  eq prepare(op F to F' . OMS, X, SS, SS', SS'')
    = (op F to F' .
       prepare(OMS, X, SS, SS', SS'')) .
  eq prepare(op F : TyL -> Ty to F' . OMS, X, SS, SS', SS'')
    = (op F : prepare(TyL, X, SS) -> prepare(Ty, X, SS) to F' .
       prepare(OMS, X, SS, SS', SS'')) .
  eq prepare(op T to term T' . OMS, X, SS, SS', SS'')
    = (op prepTerm(T, X, SS) to term prepTerm(T', X, SS') .
       prepare(OMS, X, SS, SS', SS'')) .
  eq prepare(msg F to F' . OMS, X, SS, SS', SS'')
    = (msg F to F' .
       prepare(OMS, X, SS, SS', SS'')) .
  eq prepare(msg F : TyL -> Ty to F' . OMS, X, SS, SS', SS'')
    = (msg F : prepare(TyL, X, SS) -> prepare(Ty, X, SS) to F' .
       prepare(OMS, X, SS, SS', SS'')) .
  eq prepare(attr A . S to A' . OMS, X, SS, SS', SS'')
    = (attr A . qualify(X, S) to A' .
       prepare(OMS, X, SS, SS', SS'')) .
  eq prepare((none).OpMappingSet, X, SS, SS', SS'') = none .

  eq prepare(strat F to F' . TMS, X, SS, SS', SS'')
    = (strat F to F' .
       prepare(TMS, X, SS, SS', SS'')) .
  eq prepare(strat F : TyL @ Ty to F' . TMS, X, SS, SS', SS'')
    = (strat F : prepare(TyL, X, SS) @ prepare(Ty, X, SS) to F' .
       prepare(TMS, X, SS, SS', SS'')) .
  eq prepare((none).StratMappingSet, X, SS, SS', SS'') = none .

  eq prepare((S TyL), X, (S ; SS)) = (qualify(X, S) prepare(TyL, X, (S ; SS))) .
  eq prepare((K TyL), X, SS) = prepare((getSort(K) TyL), X, SS) .
  eq prepare((S TyL), X, SS) = (S prepare(TyL, X, SS)) [owise] .
  eq prepare(nil, X, SS) = nil .

  eq prepTerm(F[TL], X, SS) = F[prepTerm(TL, X, SS)] .
  eq prepTerm(V, X, SS)
    = if getType(V) in SS
      then qid(string(getName(V)) + ":" + string(qualify(X, getType(V))))
      else qid(string(getName(V)) + ":" + string(getType(V)))
      fi .
  eq prepTerm(Ct, X, SS)
    = if getType(Ct) in SS
      then qid(string(getName(Ct)) + "." + string(qualify(X, getType(Ct))))
      else qid(string(getName(Ct)) + "." + string(getType(Ct)))
      fi .
  ceq prepTerm((T, TL), X, SS)
    = (prepTerm(T, X, SS), prepTerm(TL, X, SS))
    if TL =/= empty .
  eq prepTerm(qidError(QIL), X, SS) = qidError(QIL) .

*** For each parameterized sort
*** $\texttt{S[L}_1\texttt{,}\ldots\texttt{,L}_n\texttt{]}$ in the
*** body of a parameterized module with
*** $\texttt{L}_1\ldots\texttt{L}_n$ the labels of the parameters in
*** the interface of the module, a map of the form 9
*** $\texttt{sort\ S[L}_1\texttt{,}\ldots\texttt{,L}_n\texttt{]\
***      to\ S[V}_1\texttt{,}\ldots\texttt{,V}_n\texttt{]}$
*** is generated, where $\texttt{V}_i$ is the name of the view associated to
*** the label $\texttt{L}_i$ in the set of pairs given as argument.

  op genMapsSorts : SortSet Set{Tuple{ViewExpression,ViewExpression}} -> SortMappingSet .
  op genMapsClasses : SortSet Set{Tuple{ViewExpression,ViewExpression}} -> SortMappingSet .

  op prepSort : Sort Set{Tuple{ViewExpression,ViewExpression}} -> Sort .
  op prepSort : Sort ParameterList ParameterList Set{Tuple{ViewExpression,ViewExpression}} -> Sort .

  eq genMapsSorts((S ; SS), VEPS)
    = (if prepSort(S, VEPS) == S
       then none
       else (sort S to prepSort(S, VEPS) .)
       fi)
      genMapsSorts(SS, VEPS) .
  eq genMapsSorts(none, VEPS) = none .

  eq genMapsClasses((S ; SS), VEPS)
    = (if prepSort(S, VEPS) == S
       then none
       else (class S to prepSort(S, VEPS) .)
       fi)
      genMapsClasses(SS, VEPS) .
  eq genMapsClasses(none, VEPS) = none .

  eq prepSort(S, VEPS) = prepSort(getName(S), empty, getPars(S), VEPS) .
  eq prepSort(Ty, VEPS) = Ty [owise] .

  eq prepSort(S, PL, P, < P ; VE > VEPS)
    = prepSort(S, (PL, VE), empty, < P ; VE > VEPS) .
  eq prepSort(S, PL, (P, PL'), < P ; VE > VEPS)
    = prepSort(S, (PL, VE), PL', < P ; VE > VEPS) .
  eq prepSort(S, PL, P, VEPS)
    = prepSort(S, (PL, prepSort(P, VEPS)), empty, VEPS)
    [owise] .
  eq prepSort(S, PL, (P, PL'), VEPS)
    = prepSort(S, (PL, prepSort(P, VEPS)), PL', VEPS)
    [owise] .
  eq prepSort(S, PL, empty, VEPS)
    = if getPars(S) == empty
      then makeSort(S, PL)
      else makeSort(prepSort(S, VEPS), PL)
      fi .

*** The function \texttt{prepImports} takes a list of importation
*** declarations and a set of pairs composed of a label and a view name, and
*** returns the list of importations resulting from changing in each of the
*** module expressions the occurrences of the labels of the interface of the
*** module being instantiated by the names of the views associated to them in
*** the list of pairs.

  op prepImports : ImportList Set{Tuple{ViewExpression,ViewExpression}} -> ImportList .

  op prepModExp :
       ModuleExpression Set{Tuple{ViewExpression,ViewExpression}} -> ModuleExpression .
  op prepModExp : ModuleExpression ViewExpression ViewExpression ViewExpression
       Set{Tuple{ViewExpression,ViewExpression}} -> ModuleExpression .
  op prepParameterDecl :
       ParameterDecl Set{Tuple{ViewExpression,ViewExpression}} -> ParameterDecl .
  op prepViewExpression : ViewExpression Set{Tuple{ViewExpression,ViewExpression}} -> ViewExpression .
  op prepViewExpression : ParameterList Set{Tuple{ViewExpression,ViewExpression}} -> ParameterList .

  eq prepImports(((including ME .) IL), VEPS)
    = (including prepModExp(ME, VEPS) .)
      prepImports(IL, VEPS) .
  eq prepImports(((including pd(PD) .) IL), VEPS)
    = (including pd(prepParameterDecl(PD, VEPS)) .)
      prepImports(IL, VEPS) .
  eq prepImports(((extending ME .) IL), VEPS)
    = (extending prepModExp(ME, VEPS) .)
      prepImports(IL, VEPS) .
  eq prepImports(((extending pd(PD) .) IL), VEPS)
    = (extending pd(prepParameterDecl(PD, VEPS)) .)
      prepImports(IL, VEPS) .
  eq prepImports(((protecting ME .) IL), VEPS)
    = (protecting prepModExp(ME, VEPS) .)
      prepImports(IL, VEPS) .
  eq prepImports(((protecting pd(PD) .) IL), VEPS)
    = (protecting pd(prepParameterDecl(PD, VEPS)) .)
      prepImports(IL, VEPS) .
  eq prepImports(nil, VEPS) = nil .

  eq prepModExp(QI, VEPS) = QI .
  eq prepModExp(ME{PL}, VEPS) = prepModExp(ME, empty, empty, PL, VEPS) .
  eq prepModExp(ME + ME', VEPS)
    = prepModExp(ME, VEPS) + prepModExp(ME', VEPS) .
  eq prepModExp(ME, VEPS) = ME [owise] .

  eq prepModExp(ME, PL, PL', (P, PL''), < P ; S > VEPS)
    = prepModExp(ME, (PL, S), PL', PL'', < P ; S > VEPS) .
  eq prepModExp(ME, PL, PL', (P, PL''), < P ; S{PL3} > VEPS)
    = prepModExp(ME, (PL, S{PL3}), PL', PL'', < P ; S{PL3} > VEPS) .
  ceq prepModExp(ME, PL, PL', (P, PL''), < P ; P' ;; VE > VEPS)
    = prepModExp(ME, (PL, P'), (PL', VE), PL'', < P ; P' ;; VE > VEPS)
    if VE =/= mtViewExpression .
  eq prepModExp(ME, PL, PL', (P, PL''), VEPS)
    = prepModExp(ME, (PL, P), PL', PL'', VEPS)
    [owise] .
  eq prepModExp(ME, PL, PL', (QI{PL''}, PL3), VEPS)
    = prepModExp(ME, (PL, prepViewExpression(QI{PL''}, VEPS)), PL', PL3, VEPS) .
  eq prepModExp(ME, PL, empty, empty, VEPS) = ME{PL} .
  eq prepModExp(ME, PL, PL', empty, VEPS) = ME{PL}{PL'} [owise] .

  eq prepParameterDecl(X :: ME, < Y ; Z > VEPS)
    = if X == Y
      then (Z :: ME)
      else prepParameterDecl(X :: ME, VEPS)
      fi .
  eq prepParameterDecl(X :: ME, none) = X :: ME .

  eq prepViewExpression(VE, < VE ; VE' > VEPS) = VE' .
  eq prepViewExpression(QI, VEPS) = QI [owise] .
  eq prepViewExpression(X{PL}, VEPS) = X{prepViewExpression(PL, VEPS)} [owise] .
  ceq prepViewExpression((VE, PL), VEPS)
    = prepViewExpression(VE, VEPS), prepViewExpression(PL, VEPS)
    if VE =/= nil /\ PL =/= nil [owise] .

*** The function \texttt{unitInst} calls the auxiliary function
*** \texttt{unitInstAux}, which proceeds recursively on each of the parameters
*** in the interface of the module being instantiated. For each view, a set of
*** maps to be applied to the module is generated, which are accumulated in
*** the third argument of the function.

*** In the base case, when there are no more parameters and no more views, the
*** maps for the parameterized sorts are also generated, and all maps are
*** then applied.

*** \texttt{unitInstAux} proceeds accumulating also the list of parameters
*** being modified, the list of importations, and a list of label-view
*** pairs (\texttt{QidTuple{ViewExpression,ViewExpression}}) associating each label in
*** the interface to the view used in the instantiation of the theory with
*** such label. This list of pairs is used to generate the set of maps of the
*** parameterized  sorts and to `prepare' the list of importations as
***  indicated above.

  pr 7TUPLE{SortMappingSet, OpMappingSet, StratMappingSet, ParameterDeclList,
       ImportList, Set{Tuple{ViewExpression,ViewExpression}}, Database}
       * (sort Tuple{SortMappingSet, OpMappingSet, StratMappingSet,
            ParameterDeclList, ImportList, Set{Tuple{ViewExpression,ViewExpression}},
            Database} to TreatParResult,
          op ((_,_,_,_,_,_,_)) to <_;_;_;_;_;_;_>,
          op p1_ to getSortMappings,
          op p2_ to getOpMappings,
          op p3_ to getStratMappings,
          op p4_ to getPars,
          op p5_ to getImports,
          op p6_ to viewExpPairSet,
          op p7_ to db) .

---(
  sort TreatParResult .

  op <_;_;_;_;_;_;_> : SortMappingSet OpMappingSet StratMappingSet ParameterDeclList
       ImportList Set{Tuple{ViewExpression,ViewExpression}} Database ->
       TreatParResult .
  op getSortMappings : TreatParResult -> SortMappingSet .
  op getOpMappings : TreatParResult -> OpMappingSet .
  op getStratMappings : TreatParResult -> StratMappingSet .
  op getPars : TreatParResult -> ParameterDeclList .
  op getImports : TreatParResult -> ImportList .
  op viewExpPairSet : TreatParResult -> Set{Tuple{ViewExpression,ViewExpression}} .
  op db : TreatParResult -> Database .

  eq getSortMappings(< SMS ; OMS ; TMS ; PDL ; IL ; VEPS ; DB >) = SMS .
  eq getOpMappings(< SMS ; OMS ; TMS ; PDL ; IL ; VEPS ; DB >) = OMS .
  eq getStratMappings(< SMS ; OMS ; TMS ; PDL ; IL ; VEPS ; DB >) = TMS .
  eq getPars(< SMS ; OMS ; TMS ; PDL ; IL ; VEPS ; DB >) = PDL .
  eq getImports(< SMS ; OMS ; TMS ; PDL ; IL ; VEPS ; DB >) = IL .
  eq viewExpPairSet(< SMS ; OMS ; TMS ; PDL ; IL ; VEPS ; DB >) = VEPS .
  eq db(< SMS ; OMS ; TMS ; PDL ; IL ; VEPS ; DB >) = DB .
---)

  op unitInstAux : Module Module VariableSet SortMappingSet OpMappingSet
        StratMappingSet ParameterDeclList ParameterDeclList ImportList
        ImportList ParameterList Set{Tuple{ViewExpression,ViewExpression}}
        ParameterDeclList Database -> Database .
  op treatPar : ParameterDecl ViewExpression
        Set{Tuple{ViewExpression,ViewExpression}} ParameterDeclList Database
        -> TreatParResult .
  op treatPar2 : ParameterDecl ViewExpression
        Set{Tuple{ViewExpression,ViewExpression}} ParameterDeclList Database
        -> TreatParResult .
  op treatParAux : Qid ModuleExpression ParameterDeclList ViewExpression Qid
        ViewExpression ViewExpression  ParameterDeclList  SortMappingSet
        OpMappingSet  ParameterDeclList ImportList
        Set{Tuple{ViewExpression,ViewExpression}}  Database -> TreatParResult .
  op treatParAux2 : Qid ModuleExpression ParameterDeclList ViewExpression Qid
        ViewExpression ViewExpression ParameterDeclList SortMappingSet OpMappingSet
        StratMappingSet ParameterDeclList ImportList
        Set{Tuple{ViewExpression,ViewExpression}} Database -> TreatParResult .

  eq unitInst(ME, PL, PDL, DB)
    = unitInstAux(setName(getTopModule(ME, DB), ME{PL}),
        signature(getFlatModule(ME, DB)), getVars(ME, DB), none, none, none,
        getPars(getTopModule(ME, DB)), nil,
        getImports(getTopModule(ME, DB)), nil, PL, none, PDL, DB) .

  ceq unitInstAux(U, M, VDS, SMS, OMS, TMS, (X :: ME, PDL), PDL', IL, IL'', (QI, PL), VEPS, PDL'', DB)
    = unitInstAux(U, M, VDS, (SMS SMS'), (OMS OMS'), (TMS TMS'),
        PDL, (PDL', PDL3), IL, (IL'' IL3), PL, (VEPS VEPS'), PDL'', DB')
    if < SMS' ; OMS' ; TMS' ; PDL3 ; IL3 ; VEPS' ; DB' >
         := treatPar(X :: ME, QI, VEPS, PDL'', DB) .
  ceq unitInstAux(U, M, VDS, SMS, OMS, TMS, (X :: ME, PDL), PDL', IL, IL'', (QI{PL}, PL'), VEPS, PDL'', DB)
    = unitInstAux(U, M, VDS, (SMS SMS'), (OMS OMS'), (TMS TMS'), PDL, (PDL', PDL3), IL, (IL'' IL3), PL', (VEPS VEPS'), PDL'', DB')
    if < SMS' ; OMS' ; TMS' ; PDL3 ; IL3 ; VEPS' ; DB' >
         := treatPar(X :: ME, QI{PL}, VEPS, PDL'', DB) .
  ceq unitInstAux(U, M, VDS, SMS, OMS, TMS, nil, PDL, IL, IL', empty, VEPS, PDL', DB)
    = evalModule(
        setImports(setPars(applyMapsToModuleAux(maps2rens(SMS'), maps2rens(OMS), maps2rens(TMS), U, M), PDL),
                   (prepImports(IL, VEPS) IL')),
        applyMapsToVars(maps2rens(SMS'), maps2rens(OMS), VDS),
        DB)
    if SMS' := (SMS
                genMapsSorts((getSorts(U) ; getSortSetAux(getImports(U), DB)), VEPS)
                genMapsClasses((getClassNames(getClasses(U)) ; getClassSetAux(getImports(U), DB)), VEPS)) .
  eq unitInstAux(unitError(QIL), UK:[Module], SDV:[VariableSet], SMS, OMS, TMS, PDL, PDL', IL, IL', PL, VEPS, PDL'', DB)
    = warning(DB, QIL) .
  eq unitInstAux(noModule, unitError(QIL), VDS, SMS, OMS, TMS, PDL, PDL', IL, IL', VE, VEPS, PDL'', DB)
    = warning(DB, QIL) .
  eq unitInstAux(U, M, VDS, SMS, OMS, TMS, (X :: ME, PDL), PDL', IL, IL', empty, VEPS, PDL'', DB)
    = warning(DB, '\r 'Error: '\o 'Incorrect 'module header2QidList(getHeader(U)) '. '\n) .
  eq unitInstAux(U, M, VDS, SMS, OMS, TMS, nil, PDL, IL, IL', (QI, VE, PL), VEPS, PDL', DB)
    = warning(DB, '\r 'Error: '\o 'Incorrect 'module header2QidList(getHeader(U)) '. '\n) .
  eq unitInstAux(U, M, VDS, SMS, OMS, TMS, PDL, PDL', IL, IL', PL, VEPS, PDL'', DB)
    = DB
    [owise] .

  eq treatParView(X :: ME, VE, ME', VEPS, PDL, DB)
    = if labelInModExp(X, ME')
      then treatPar(X :: ME, VE, VEPS, PDL, DB)
      else < none ;
             none ;
             none ;
             getPars(treatPar(X :: ME, VE, VEPS, PDL, DB)) ;
             getImports(treatPar(X :: ME, VE, VEPS, PDL, DB)) ;
             viewExpPairSet(treatPar(X :: ME, VE, VEPS, PDL, DB)) ;
             db(treatPar(X :: ME, VE, VEPS, PDL, DB)) >
      fi .

  op labelInModExp : Qid ModuleExpression -> Bool .
  op labelInViewExpression : Qid ViewExpression -> Bool .

  eq labelInModExp(X, QI) = X == QI .
  eq labelInModExp(X, ME{VE}) = labelInViewExpression(X, VE) .
  eq labelInModExp(X, TUPLE[N]) = false .
  eq labelInModExp(X, POWER[N]) = false .

  eq labelInViewExpression(X, QI) = X == QI .
  eq labelInViewExpression(X, ((VE, VE')))
    = labelInViewExpression(X, VE) or-else labelInViewExpression(X, VE') .
  eq labelInViewExpression(X, QI{VE}) = X == QI or-else labelInViewExpression(X, VE) .

  eq treatPar(X :: ME, VE, VEPS, PDL, DB)
    = if VE :: Qid and-then labelInParameterDeclList(VE, PDL)
      then < (genMapsQualSorts(X, VE, getThSorts(ME, DB), VEPS)
              genMapsQualClasses(X, VE, getThClasses(ME, DB), VEPS)) ;
             none ;
             none ;
             VE :: ME ;
             nil ;
             < X ; VE > ;
             createCopy((VE :: ME), DB) >
      else if viewInDb(VE, DB)
           then if theory(getTopModule(getTo(getView(VE, DB)), DB))
                then < prepare(
                         getSortMappings(getView(VE, DB)),
                         X,
                         getThSorts(ME, DB),
                         getThSorts(getTo(getView(VE, DB)), DB),
                         getThClasses(getTo(getView(VE, DB)), DB)) ;
                       prepare(
                         getOpMappings(getView(VE, DB)),
                         X,
                         getThSorts(ME, DB),
                         getThSorts(getTo(getView(VE, DB)), DB),
                         getThClasses(getTo(getView(VE, DB)), DB)) ;
                       none ; ---- do something with strat maps
                       X :: getTo(getView(VE, DB)) ;
                       nil ;
                       < X ; (VE ;; X) > ;
                       createCopy((X :: getTo(getView(VE, DB))), DB) >
                else < prepare(
                         getSortMappings(getView(VE, DB)),
                         X,
                         getThSorts(ME, DB), none, none) ;
                       prepare(
                         getOpMappings(getView(VE, DB)),
                         X,
                         getThSorts(ME, DB), none, none) ;
                       prepare(
                         getStratMappings(getView(VE, DB)),
                         X,
                         getThSorts(ME, DB), none, none) ;
                       getPars(getTopModule(getTo(getView(VE, DB)), DB)) ;
                       (protecting getTo(getView(VE, DB)) .) ;
                       < X ; VE > ;
                       DB >
                fi
           else < none ; none ; none ; nil ; nil ; none ;
                  warning(DB, '\r 'Error: '\o 'View VE 'not 'in 'database. '\n) >
           fi
      fi .

  op viewInstAux : View SortMappingSet OpMappingSet StratMappingSet ParameterDeclList
       ParameterDeclList ParameterList Set{Tuple{ViewExpression,ViewExpression}}
       ParameterDeclList Database -> Database .
  op treatParView : ParameterDecl ParameterList ModuleExpression
       Set{Tuple{ViewExpression,ViewExpression}} ParameterDeclList Database
       -> TreatParResult .
  op treatParAux : Qid ModuleExpression ParameterList Qid ViewExpression ViewExpression
       ParameterList SortMappingSet OpMappingSet StratMappingSet ParameterList ImportList
       Set{Tuple{ViewExpression,ViewExpression}} Database -> TreatParResult .

  eq viewInst(VE, PL, PDL, DB)
    = viewInstAux(setName(getView(VE, DB), VE{PL}),
        none, none, none, getPars(getView(VE, DB)), nil, PL, none, PDL, DB) .

  ceq viewInstAux(VI, SMS, OMS, TMS, (X :: ME, PDL), PDL', (QI, PL), VEPS, PDL'', DB)
    = viewInstAux(VI, (SMS SMS'), (OMS OMS'), (TMS TMS'), PDL, (PDL', PDL3), PL, (VEPS VEPS'), PDL'', DB')
    if < SMS' ; OMS' ; TMS' ; PDL3 ; IL ; VEPS' ; DB' >
         := treatParView(X :: ME, QI, getFrom(VI), VEPS, PDL'', DB) .
  ceq viewInstAux(VI, SMS, OMS, TMS, (X :: ME, PDL), PDL', (QI{PL}, PL'), VEPS, PDL'', DB)
    = viewInstAux(VI, SMS SMS', OMS OMS', TMS TMS', PDL, (PDL', PDL3), PL', VEPS VEPS', PDL'', DB')
    if < SMS' ; OMS' ; TMS' ; PDL3 ; IL ; VEPS' ; DB' > := treatParView(X :: ME, QI{PL}, getFrom(VI), VEPS, PDL'', DB) .
  ceq viewInstAux(VI, SMS, OMS, TMS, nil, PDL, empty, VEPS, PDL', DB)
    = insertView(
        setPars(
          setFrom(
            setTo(
              setSortMappings(
                setOpMappings(VI,
                  applyMapsToMaps(
                    maps2rens(genMapsSorts(getSortSet(getFrom(VI), DB'''), VEPS)
                              genMapsClasses(getClassSet(getFrom(VI), DB'''), VEPS)),
                    maps2rens(SMS
                              genMapsSorts(getSortSet(getTo(VI), DB'''), VEPS)
                              genMapsClasses(getClassSet(getTo(VI), DB'''), VEPS)),
                    getOpMappings(VI))),
                applyMapsToMaps(
                  maps2rens(genMapsSorts(getSortSet(getFrom(VI), DB'''), VEPS)
                            genMapsClasses(getClassSet(getFrom(VI), DB'''), VEPS)),
                  maps2rens(SMS
                            genMapsSorts(getSortSet(getTo(VI), DB'''), VEPS)
                            genMapsClasses(getClassSet(getTo(VI), DB'''), VEPS)),
                  getSortMappings(VI))),
              prepModExp(getTo(VI), VEPS)),
            prepModExp(getFrom(VI), VEPS)),
          PDL),
        DB''')
    if < DB'  ; ME'  >   := evalModExp(getFrom(VI), PDL', DB)
    /\ < DB'' ; ME'' >   := evalModExp(getTo(VI), (getPars(VI), PDL'), DB')
    /\ < DB''' ; ME''' > := evalModExp(prepModExp(getTo(VI), VEPS), (getPars(VI), PDL'), DB'') .
  eq viewInstAux(viewError(QIL), SMS, OMS, TMS, PDL0:[ParameterDeclList], PDL, PL, VEPS, PDL', DB)
    = warning(DB, QIL) .
  eq viewInstAux(VI, SMS, OMS, TMS, (X :: ME, PDL), PDL', empty, VEPS, PDL'', DB)
    = warning(DB, ('\r 'Error: '\o 'Incorrect 'view getName(VI) '. '\n)) .
  eq viewInstAux(VI, SMS, OMS, TMS, nil, PDL, (QI, PL), VEPS, PDL', DB)
    = warning(DB, ('\r 'Error: '\o 'Incorrect 'view getName(VI) '. '\n)) .
  eq viewInstAux(VI, SMS, OMS, TMS, (X :: ME, PDL), PDL', (QI{PL}, PL'), VEPS, PDL'', DB)
    = warning(DB, ('\r 'Error: '\o 'Wrong 'instantiation getName(VI) '. '\n)) .

  op applyMapsToMaps : RenamingSet RenamingSet SortMappingSet -> SortMappingSet .
  op applyMapsToMaps : RenamingSet RenamingSet OpMappingSet -> OpMappingSet .
  op applyMapsToTerm : RenamingSet TermList -> TermList .
  op applyMapsToVars : RenamingSet VariableSet -> VariableSet .

  eq applyMapsToMaps(SRS, SRS', sort S to S' . SMS)
    = (sort applyMapsToType(SRS, S) to applyMapsToType(SRS', S') .
       applyMapsToMaps(SRS, SRS', SMS)) .
  eq applyMapsToMaps(SRS, SRS', class S to S' . SMS)
    = (class applyMapsToType(SRS, S) to applyMapsToType(SRS',S') .
       applyMapsToMaps(SRS, SRS', SMS)) .
  eq applyMapsToMaps(SRS, SRS', SMS) = SMS [owise] .

  eq applyMapsToMaps(SRS, SRS', op_to`term_.(T, T') OMS)
    = (op_to`term_.(applyMapsToTerm(SRS, T), applyMapsToTerm(SRS', T'))
       applyMapsToMaps(SRS, SRS', OMS)) .
  eq applyMapsToMaps(SRS, SRS', op F : TyL -> Ty to F' . OMS)
    = (op F : applyMapsToTypeList(SRS, TyL) -> applyMapsToType(SRS, Ty) to F' .
       applyMapsToMaps(SRS, SRS', OMS)) .
  eq applyMapsToMaps(SRS, SRS', msg F : TyL -> S to F' . OMS)
    = (msg F : applyMapsToTypeList(SRS, TyL) -> applyMapsToType(SRS, S) to F' .
       applyMapsToMaps(SRS, SRS', OMS)) .
  eq applyMapsToMaps(SRS, SRS', attr A . S to A' . OMS)
    = (attr A . applyMapsToType(SRS, S) to A' .
       applyMapsToMaps(SRS, SRS', OMS)) .
  eq applyMapsToMaps(SRS, SRS', OMS) = OMS [owise] .

  eq applyMapsToVars(SRS, V ; VDS)
    = qid(string(getName(V)) + ":" + string(applyMapsToType(SRS, getType(V)))) ;
      applyMapsToVars(SRS, VDS).
  eq applyMapsToVars(SRS, none) = none .

  eq applyMapsToTerm(SRS, Ct)
    = qid(string(getName(Ct)) + "." + string(applyMapsToType(SRS, getType(Ct)))) .
  eq applyMapsToTerm(SRS, V)
    = qid(string(getName(V)) + "." + string(applyMapsToType(SRS, getType(V)))) .
  eq applyMapsToTerm(SRS, qidError(QIL)) = qidError(QIL) .
  ceq applyMapsToTerm(SRS, F[TL])
    = F[applyMapsToTerm(SRS, TL)]
    if (F =/= '<_:_|_>) and (F =/= '<_:_|`>) .
  eq applyMapsToTerm(SRS, '<_:_|_>[O, Ct, T])
    = '<_:_|_>[applyMapsToTerm(SRS, O),
               qid(string(applyMapsToClassName(SRS, getName(Ct)))
                   + "." + string(applyMapsToClassName(SRS, getType(Ct)))),
               applyMapsToTerm(SRS, T)] .
  ceq applyMapsToTerm(SRS, '<_:_|_>[O, C, T])
    = '<_:_|_>[applyMapsToTerm(SRS, O),
               applyMapsToClassName(SRS, C),
               applyMapsToTerm(SRS, T)]
    if not C :: Constant .
  eq applyMapsToTerm(SRS, '<_:_|`>[O, Ct])
    = '<_:_|_>[applyMapsToTerm(SRS, O),
               qid(string(applyMapsToClassName(SRS, getName(Ct)))
                   + "." + string(applyMapsToClassName(SRS, getType(Ct)))),
               'none.AttributeSet] .
  ceq applyMapsToTerm(SRS, '<_:_|`>[O, C])
    = '<_:_|_>[applyMapsToTerm(SRS, O),
               applyMapsToClassName(SRS, C),
               'none.AttributeSet]
    if not C :: Constant .

  ceq applyMapsToTerm(SRS, (T, TL))
    = (applyMapsToTerm(SRS, T), applyMapsToTerm(SRS, TL))
    if TL =/= empty .

*** As pointed out in Section~\ref{module-names}, for each new module
*** expression constructor being introduced, we need to add equations for the
*** operator \texttt{header2Qid}. Since the function to transform view
*** expressions into lists of quoted identifiers was already defined in
*** Section~\ref{VIEW-EXPR}, we just need to add the following equation.

  eq header2Qid((ME { PL }))
    = qidList2Qid(header2Qid(ME) '`{ parameterList2Qid(PL) '`}) .
  ceq header2QidList((ME { PL }))
    = (if QI == '\s then QIL else QIL QI fi
       '`{ parameterList2QidList(PL) '`} '\s)
    if QIL QI := header2QidList(ME) .

*** Given a module expression of the form \verb~ME{VE}~ such that
*** \texttt{ME} is in the database, we need to add \verb~ME{VE}~ to the set
*** of names of the modules depending on \texttt{ME} and on \texttt{VE}.
*** Since \texttt{VE} may be a composed view expression, we have to add the
*** name of the module  to each of the views in it. In this way, if \texttt{ME}
*** or any of the  views in \texttt{VE} is redefined or removed from the
*** database,  \verb~ME{VE}~ will be removed as well.

  eq setUpModExpDeps(ME{PL},
      db(< ME ; DT ; U ; U' ; M ; VDS ; MNS ; VES > MIS, MNS',
          VIS, VES', MNS'', MNS3, MNS4, QIL))
    = viewExpDeps(ME{PL}, PL,
        db(< ME ; DT ; U ; U' ; M ; VDS ; (MNS . ME{PL}) ; VES > MIS,
           MNS', VIS, VES', MNS'', MNS3, MNS4, QIL)) .
  eq setUpModExpDeps(ME{PL},
      db(< ME ; DM ; U ; U' ; M ; VDS ; MNS ; VES > MIS, MNS',
         VIS, VES', MNS'', MNS3, MNS4, QIL))
    = viewExpDeps(ME{PL}, PL,
        db(< ME ; DM ; U ; U' ; M ; VDS ; (MNS . ME{PL}) ; VES > MIS,
           MNS', VIS, VES', MNS'', MNS3, MNS4, QIL)) .
  eq setUpModExpDeps('META-LEVEL{PL}, DB)
    = setUpModExpDeps('META-LEVEL{PL}, PL, DB) .
  eq setUpModExpDeps('META-LEVEL{QI},
       db(< QI ; DT ; U ; U' ; M ; VDS ; MNS ; VES > MIS, MNS',
          VIS, VES', MNS'', MNS3, MNS4, QIL))
    = db(< QI ; DT ; U ; U' ; M ; VDS ; MNS . 'META-LEVEL{QI} ; VES >
          MIS, MNS', VIS, VES', MNS'', MNS3, MNS4, QIL) .
  eq setUpModExpDeps('META-LEVEL{QI},
       db(< QI ; DM ; U ; U' ; M ; VDS ; MNS ; VES > MIS, MNS',
          VIS, VES', MNS'', MNS3, MNS4, QIL))
    = db(< QI ; DM ; U ; U' ; M ; VDS ; MNS . 'META-LEVEL{QI} ; VES >
          MIS, MNS', VIS, VES', MNS'', MNS3, MNS4, QIL) .
  ceq setUpModExpDeps(ME{PL}, DB)
    = warning(DB, ('\r 'Error: '\o 'Module header2QidList(ME) 'not 'in 'database. '\n))
    if (ME =/= 'META-LEVEL) /\ (not unitInDb(ME, DB)) .

  eq setUpModExpDeps('META-LEVEL{PL}, (QI, PL'),
       db(< QI ; DT ; U ; U' ; M ; VDS ; MNS ; VES > MIS, MNS',
          VIS, VES', MNS'', MNS3, MNS4, QIL))
    = setUpModExpDeps('META-LEVEL{PL}, PL',
        db(< QI ; DT ; U ; U' ; M ; VDS ; MNS . 'META-LEVEL{PL} ; VES >
           MIS, MNS', VIS, VES', MNS'', MNS3, MNS4, QIL)) .
  eq setUpModExpDeps('META-LEVEL{PL}, (QI, PL'),
       db(< QI ; DM ; U ; U' ; M ; VDS ; MNS ; VES > MIS, MNS',
          VIS, VES', MNS'', MNS3, MNS4, QIL))
    = setUpModExpDeps('META-LEVEL{PL}, PL',
        db(< QI ; DM ; U ; U' ; M ; VDS ; MNS . 'META-LEVEL{PL} ; VES >
           MIS, MNS', VIS, VES', MNS'', MNS3, MNS4, QIL)) .
  eq setUpModExpDeps('META-LEVEL{PL}, nil, DB) = DB .

  op viewExpDeps : Header ViewExpression Database -> Database .

----  eq viewExpDeps(ME, VE,
----        db(MIS, MNS,
----           < VE ; DT ; VI ; MNS' ; VES > VIS, VES',
----           MNS'', MNS3, MNS4, QIL))
----    = db(MIS, MNS, < VE ; DT ; VI ; MNS' . ME ; VES > VIS, VES',
----         MNS'', MNS3, MNS4, QIL) .
  eq viewExpDeps(ME, (VE, PL),
        db(MIS, MNS,
           < VE ; DT ; VI ; MNS' ; VES > VIS, VES',
           MNS'', MNS3, MNS4, QIL))
    = viewExpDeps(ME, PL,
        db(MIS, MNS,
           < VE ; DT ; VI ; MNS' . ME ; VES > VIS, VES',
           MNS'', MNS3, MNS4, QIL)) .
----  eq viewExpDeps(ME, VE, DB) = DB [owise] .
  eq viewExpDeps(ME, (VE, PL), DB) = viewExpDeps(ME, PL, DB) [owise] .
  eq viewExpDeps(ME, empty, DB) = DB .

endfm

*******************************************************************************

***
*** 6.10 Renaming of Modules
***

*** In addition to the declaration of the constructor for renaming module
*** expressions, the following module \texttt{RENAMING-EXPR-EVALUATION}
*** introduces equations to treat this new case in the definition of functions
*** \texttt{evalModExp}, \texttt{header2QidList}, \texttt{prepHeader}, and
*** \texttt{setUpModuleDeps}.

*** A renaming expression is evaluated by applying the renaming maps, not only
*** to the top unit, but also to the part of the structure \emph{affected} by
*** the maps. The renaming process propagates downwards in the unit hierarchy
*** while the units in the structure are affected by the renamings. We say that
*** a unit is affected by a set of maps (checked by the \texttt{modAffd}
*** function) when any of the maps is applicable to any of the declarations in
*** the unit, or in any of its subunits. The application of a set of maps to a
*** single unit is accomplished by the \texttt{applyMapsToModule} function,
*** discussed in Section~\ref{applyMapsToModule}.

fmod FM-RENAMING-EXPR-EVALUATION is
  pr DATABASE .
  pr FM-RENAMING-SET-APPL-ON-UNIT .
  pr FM-EVALUATION .
  inc MOD-EXPR .
  pr MOD-EXPR-EVAL .
  pr FM-INST-EXPR-EVALUATION .
  pr FM-FMAP .

  vars ME ME' : ModuleExpression .
  var  MNS MNS' MNS'' MNS3 MNS4 : Set{ModuleName} .
  vars MIS MIS' : Set{ModuleInfo} .
  var  VIS : Set{ViewInfo} .
  vars M M' : Module .
  vars PU U U' DM : Module .
  vars DB DB' : Database .
  var  QIL : QidList .
  vars VES VES' : Set{ViewExpression} .
  var  PL : ParameterList .
  var  PDL : ParameterDeclList .
  vars PDS PDS' : Set{ParameterDecl} .
  var  I : Import .
  vars IL IL' : ImportList .
  var  R : Renaming .
  vars RS RS' RS'' RS3 SRS ORS TRS : RenamingSet .
  var  VEPS : Set{Tuple{ViewExpression,ViewExpression}} .
  vars X QI QI' QI'' F F' F'' L L' L'' A A' A'' : Qid .
  vars S S' S'' C C' C'' : Sort .
  var  K : Kind .
  vars SS : SortSet .
  vars TyL TyL' : TypeList .
  vars Ty Ty' : Type .
  vars T T' T'' T3 : Term .
  var  DT : Default{Term} .
  var  TL : TermList .
  var  OPD : OpDeclSet .
  var  OPDS : OpDeclSet .
  var  VDS : VariableSet .
  vars AtS AtS' : AttrSet .
  var  Rl : Rule .
  var  RlS : RuleSet .
  var  CD : ClassDecl .
  var  CDS : ClassDeclSet .
  var  ADS : AttrDeclSet .
  var  MD : MsgDecl .
  var  MDS : MsgDeclSet .
  var  N : Nat .
  var  NL : IntList .
  var  Hk : Hook .
  var  HkL : HookList .
  var  B : Bool .
  var  St : String .
  var  StratDcls : StratDeclSet .

*** The function \texttt{crtCopyRen} creates a copy of the part of the
*** structure of the specified module which is affected by the renaming,
*** applying to each of the generated modules in the new structure the subset
*** of maps affecting each one of them. The equation extending the
*** \texttt{evalModExp} function to the renaming module expression is then
*** reduced to a call to \texttt{crtCopyRen} with the appropriate
*** arguments.

  eq labelInModExp(X, ME * (RS)) = labelInModExp(X, ME) .

  op crtCopyRen : ModuleExpression RenamingSet Database -> Database .

  ceq evalModExp(ME * (RS), PDL, DB)
    = if unitInDb(ME' * (RS''), DB')
      then < DB' ; ME' * (RS'') >
      else < crtCopyRen(ME', RS', DB') ; ME' * (RS'') >
      fi
    if < DB' ; ME' > := evalModExp(ME, PDL, DB)
       /\ RS' := fixMaps(RS, ME', DB')
       /\ RS'' := canMaps(RS', getFlatModule(ME', DB')) .

  eq crtCopyRen(ME, none, DB) = DB .
  ceq crtCopyRen(ME, RS, DB)
    = if unitInDb(_*`(_`)(ME, RS'), DB)
      then DB
      else applyMapsRec(
             RS,
             getImports(getTopModule(ME, DB)),
             nil,
             setName(
               applyMapsToModuleAux(SRS, ORS, TRS,
                 getTopModule(ME, DB), getFlatModule(ME, DB)),
               _*`(_`)(ME, RS')),
             applyMapsToVars(SRS, ORS, getVars(ME, DB)),
             DB)
      fi
    if RS' := canMaps(RS, getFlatModule(ME, DB))
       /\ < SRS ; ORS ; TRS > := splitMaps(RS') .

  op canMaps : RenamingSet Module -> RenamingSet .
  eq canMaps(op F : TyL -> Ty to F' [AtS], M)
    = op F : canKinds(TyL, M) -> canKinds(Ty, M) to F' [AtS] .
  eq canMaps((op F : TyL -> Ty to F' [AtS], RS), M)
    = (op F : canKinds(TyL, M) -> canKinds(Ty, M) to F' [AtS],
       canMaps(RS, M)) .
  eq canMaps(msg F : TyL -> Ty to F', M)
    = msg F : canKinds(TyL, M) -> canKinds(Ty, M) to F' .
  eq canMaps((msg F : TyL -> Ty to F', RS), M)
    = (msg F : canKinds(TyL, M) -> canKinds(Ty, M) to F',
       canMaps(RS, M)) .
  eq canMaps(strat F : TyL @ Ty to F', M)
    = strat F : canKinds(TyL, M) @ canKinds(Ty, M) to F' .
  eq canMaps((strat F : TyL @ Ty to F', RS), M)
    = (strat F : canKinds(TyL, M) @ canKinds(Ty, M) to F',
       canMaps(RS, M)) .
  eq canMaps(R:Renaming, M) = R:Renaming [owise] .
  eq canMaps((R:Renaming, RS), M)
    = (R:Renaming, canMaps(RS, M))
    [owise] .
  eq canMaps(none, M) = none .

  op canKinds : TypeList Module -> [TypeList] .
  ---- eq canKinds(K:Kind TyL, M)
  ----   = kind(maximalSorts(M, K:Kind)) canKinds(TyL, M) .
  eq canKinds(nil, M) = nil .
  eq canKinds(cc(S ; SS) TyL, M)
    = kind(maximalSorts(M, getKind(M, S))) canKinds(TyL, M) .
  ----eq canKinds(TyL, M) = nil [owise] .

*** We proceed downwards while the set of maps affects the module, but we do so
*** restricting the set of maps to the subset affecting the module. Since
*** operator and message maps in which arity and coarity are specified must be
*** applied to the whole subsort-overloaded family of operators or messages, we
*** have to carry along the signature of the module at the top to make all the
*** calls to the engine. Note that we may have maps of operations or messages
*** with the domain given by sorts that are not in the submodules but which
*** have other sorts in the submodules in the same connected components.

  op applyMapsRec : RenamingSet ImportList ImportList Module VariableSet Database -> Database .

  eq applyMapsRec(RS, ((including ME .) IL), IL', U, VDS, DB)
   = applyMapsRec(
       RS, IL,
       including ME *( canMaps(fixMaps(RS, ME, DB),
                               getFlatModule(ME, DB)) ) . IL',
       U, VDS,
       crtCopyRen(ME, fixMaps(RS, ME, DB), DB)) .
  eq applyMapsRec(RS, ((extending ME .) IL), IL', U, VDS, DB)
   = applyMapsRec(
       RS, IL,
       extending ME *( canMaps(fixMaps(RS, ME, DB),
                               getFlatModule(ME, DB)) ) . IL',
       U, VDS,
       crtCopyRen(ME, fixMaps(RS, ME, DB), DB)) .
  eq applyMapsRec(RS, ((protecting ME .) IL), IL', U, VDS, DB)
   = applyMapsRec(
       RS, IL,
       protecting ME *( canMaps(fixMaps(RS, ME, DB),
                               getFlatModule(ME, DB)) ) . IL',
       U, VDS,
       crtCopyRen(ME, fixMaps(RS, ME, DB), DB)) .
  eq applyMapsRec(RS, (I IL), IL', U, VDS, DB)
    = applyMapsRec(RS, IL, (I IL'), U, VDS, DB)
    [owise] .
  eq applyMapsRec(RS, nil, IL, U, VDS, DB)
    = evalModule(setImports(U, IL), VDS, DB) .
  eq applyMapsRec(RS, IL, IL', unitError(QIL), VDS, DB)
    = warning(DB, QIL) .

  op fixMaps : [RenamingSet] ModuleExpression Database -> RenamingSet .
  op fixMaps2 : [RenamingSet] Module ClassDeclSet MsgDeclSet -> RenamingSet .

  ceq fixMaps(RS, ME, DB)
    = fixMaps2(RS, getFlatModule(ME, DB), CDS, MDS)
    if < CDS ; MDS > := getAllClassesAndMsgs(ME, DB) .

  eq fixMaps2(op F to F' [AtS], M, CDS, MDS)
    = opsAffd(getOps(M), op F to F' [AtS], M) .
  eq fixMaps2((op F to F' [AtS], RS), M, CDS, MDS)
    = (opsAffd(getOps(M), op F to F' [AtS], M),
       fixMaps2(RS, M, CDS, MDS)) .
  eq fixMaps2(op F : TyL -> Ty to F' [AtS], M, CDS, MDS)
    = opsAffd(getOps(M), op F : TyL -> Ty to F' [AtS], M) .
  eq fixMaps2((op F : TyL -> Ty to F' [AtS], RS), M, CDS, MDS)
    = (opsAffd(getOps(M), op F : TyL -> Ty to F' [AtS], M),
       fixMaps2(RS, M, CDS, MDS)) .

  eq fixMaps2(msg F to F', M, CDS, MDS)
    = msgsAffd(MDS, msg F to F', M) .
  eq fixMaps2((msg F to F', RS), M, CDS, MDS)
    = (msgsAffd(MDS, msg F to F', M), fixMaps2(RS, M, CDS, MDS)) .
  eq fixMaps2(msg F : TyL -> Ty to F', M, CDS, MDS)
    = msgsAffd(MDS, msg F : TyL -> Ty to F', M) .
  eq fixMaps2((msg F : TyL -> Ty to F', RS), M, CDS, MDS)
    = (msgsAffd(MDS, msg F : TyL -> Ty to F', M),
       fixMaps2(RS, M, CDS, MDS)) .

  eq fixMaps2(strat F to F', M, CDS, MDS)
   = stratsAffd(getStratDcls(M), strat F to F', M) .
  eq fixMaps2((strat F to F', RS), M, CDS, MDS)
   = stratsAffd(getStratDcls(M), strat F to F', M),
     fixMaps2(RS, M, CDS, MDS) .
  eq fixMaps2(strat F : TyL @ Ty to F', M, CDS, MDS)
   = stratsAffd(getStratDcls(M), strat F : TyL @ Ty to F', M) .
  eq fixMaps2((strat F : TyL @ Ty to F', RS), M, CDS, MDS)
   = stratsAffd(getStratDcls(M), strat F : TyL @ Ty to F', M),
     fixMaps2(RS, M, CDS, MDS) .

  eq fixMaps2(sort Ty to Ty', M, CDS, MDS)
    = if sortsAffd(getSorts(M), sort Ty to Ty')
      then (sort Ty to Ty')
      else none
      fi .
  eq fixMaps2(((sort Ty to Ty'), RS), M, CDS, MDS)
    = (if sortsAffd(getSorts(M), sort Ty to Ty')
       then (sort Ty to Ty')
       else none
       fi,
       fixMaps2(RS, M, CDS, MDS)) .
  eq fixMaps2(class Ty to Ty', M, CDS, MDS)
    = if classesAffd(CDS, class Ty to Ty')
      then (class Ty to Ty')
      else none
      fi .
  eq fixMaps2(((class Ty to Ty'), RS), M, CDS, MDS)
    = (if classesAffd(CDS, class Ty to Ty')
       then (class Ty to Ty')
       else none
       fi,
       fixMaps2(RS, M, CDS, MDS)) .
  eq fixMaps2(attr A . Ty to Ty', M, CDS, MDS)
    = if classesAffd(CDS, attr A . Ty to Ty')
      then (attr A . Ty to Ty')
      else none
      fi .
  eq fixMaps2(((class A . Ty to Ty'), RS), M, CDS, MDS)
    = (if classesAffd(CDS, attr A . Ty to Ty')
       then (attr A . Ty to Ty')
       else none
       fi,
       fixMaps2(RS, M, CDS, MDS)) .
  eq fixMaps2(R:Renaming, M, CDS, MDS) = R:Renaming [owise] .
  eq fixMaps2((R:Renaming, RS), M, CDS, MDS)
    = (R:Renaming, fixMaps2(RS, M, CDS, MDS))
    [owise] .
  eq fixMaps2(none, M, CDS, MDS) = none .

  sort Tuple{ClassDeclSet, MsgDeclSet} .
  op <_;_> : ClassDeclSet MsgDeclSet -> Tuple{ClassDeclSet, MsgDeclSet} .
  op getClasses : Tuple{ClassDeclSet, MsgDeclSet} -> ClassDeclSet .
  op getMsgs : Tuple{ClassDeclSet, MsgDeclSet} -> MsgDeclSet .
  eq getClasses(< CDS ; MDS >) = CDS .
  eq getMsgs(< CDS ; MDS >) = MDS .

  op getAllClassesAndMsgs :
       ModuleExpression Database -> Tuple{ClassDeclSet, MsgDeclSet} .
  op getAllClassesAndMsgs :
       ImportList Database -> Tuple{ClassDeclSet, MsgDeclSet} .

  eq getAllClassesAndMsgs(ME, DB)
    = if getTopModule(ME, DB) :: OModule
         and-then not getTopModule(ME, DB) :: SModule
      then < getClasses(
               getAllClassesAndMsgs(getImports(getTopModule(ME, DB)), DB))
             getClasses(getTopModule(ME, DB))
             ;
             getMsgs(
               getAllClassesAndMsgs(getImports(getTopModule(ME, DB)), DB))
             getMsgs(getTopModule(ME, DB)) >
      else < none ; none >
      fi .

  eq getAllClassesAndMsgs(I IL, DB)
    = < getClasses(getAllClassesAndMsgs(moduleName(I), DB))
        getClasses(getAllClassesAndMsgs(IL, DB))
        ;
        getMsgs(getAllClassesAndMsgs(moduleName(I), DB))
        getMsgs(getAllClassesAndMsgs(IL, DB)) > .
  eq getAllClassesAndMsgs((nil).ImportList, DB) = < none ; none > .

----  sorts NeSet<TypeList> Set<TypeList> .
----  subsort TypeList < NeSet<TypeList> < Set<TypeList> .
----  op noneTLS : -> Set<TypeList> [ctor] .
----  op _!_ : Set<TypeList> Set<TypeList> -> Set<TypeList>
----     [ctor assoc comm id: noneTLS] .
----  op _!_ : NeSet<TypeList> NeSet<TypeList> -> NeSet<TypeList>
----     [ctor assoc comm id: noneTLS] .

----  sort Set<Type> .
----  subsorts Type SortSet < Set<Type> .
----  op _o_ : Set<Type> Set<Type> -> Set<Type> [ctor assoc comm id: none] .
----
----  eq Ty o Ty = Ty .

  sort TypeSetList .
  subsort TypeSet < TypeSetList .
  op nilTSL : -> TypeSetList [ctor] .
  op _l_ : TypeSetList TypeSetList -> TypeSetList
     [ctor assoc id: nilTSL] .

  var  TS : TypeSet .
  var  TSL : TypeSetList .
  var  TLS : TypeListSet .
----  var  NTLS : NeTypeListSet .

----  eq TyL ! TyL = TyL .

  ----eq _!_(qidError(QIL), NTLS) = qidError(QIL) .

  op fixKinds : TypeList Module -> TypeListSet .
  op fixKinds : TypeList TypeSetList Module -> TypeListSet .
  op fixKindsAux : Type Module -> TypeSet .
  op fixKindsAux2 : SortSet Module -> TypeSet .
  op unfold : TypeSetList -> TypeListSet .
  op add : TypeSet TypeListSet -> TypeListSet .

  eq fixKinds(TyL, M) = fixKinds(TyL, nilTSL, M) .

  eq fixKinds(Ty TyL, TSL, M)
    = if fixKindsAux(Ty, M) == nil
      then none
      else fixKinds(TyL, TSL l fixKindsAux(Ty, M), M)
      fi .
  eq fixKinds(nil, TSL, M) = unfold(TSL) .

  eq fixKindsAux(S, M)
    = if S in getSorts(M)
      then cc(connectedSorts(M, S))
      else none
      fi .
  eq fixKindsAux(K, M) = fixKindsAux2(getSorts(K), M) .
  eq fixKindsAux(cc(SS), M) = fixKindsAux2(SS, M) .

  eq fixKindsAux2((S ; SS), M)
    = (if S in getSorts(M)
       then cc(connectedSorts(M, S))
       else none
       fi
       ;
       fixKindsAux2(SS, M)) .
  eq fixKindsAux2(none, M) = none .

  ceq unfold(TS l TSL) = add(TS, unfold(TSL)) if TS =/= none .
  eq unfold(nilTSL) = none .

  ceq add(Ty, TyL ; TLS) = add(Ty, TyL) ; add(Ty, TLS) if TLS =/= none .
  eq add(Ty ; Ty' ; TS, TLS) = add(Ty, TLS) ; add(Ty' ; TS, TLS) .
  eq add(none, TLS) = nilTSL .
  eq add(Ty, none) = Ty .
  eq add(Ty, TyL) = Ty TyL .

  op connectedSorts : Module Type -> SortSet .
  op connectedSorts : Module SortSet Type -> SortSet .
  eq connectedSorts(M, Ty) = connectedSorts(M, getSorts(M), Ty) .
  eq connectedSorts(M, S ; SS, Ty)
    = if sameKind(M, S, Ty)
      then S
      else none
      fi ; connectedSorts(M, SS, Ty) .
  eq connectedSorts(M, none, Ty) = none .

  op sortsAffd : SortSet Renaming -> Bool .
  op opsAffd : OpDeclSet Renaming Module -> RenamingSet .
  op opsAffdAux : OpDeclSet Qid TypeListSet Qid AttrSet Module -> RenamingSet .

  eq sortsAffd((S ; SS), (sort S to S')) = true .
  eq sortsAffd(SS, (sort S to S')) = false [owise] .

  eq opsAffd(op F : TyL -> Ty [AtS] . OPDS, op F to F' [AtS'], M)
    = op F to F' [AtS'] .
  eq opsAffd(OPDS, op F : TyL -> Ty to F' [AtS], M)
    = opsAffdAux(OPDS, F, fixKinds(TyL Ty, M), F', AtS, M) .
  eq opsAffd(OPDS, RS:[RenamingSet], M) = none [owise] .

  eq opsAffdAux(op F : TyL -> Ty [AtS] . OPDS,
       F, (TyL' Ty') ; TLS, F', AtS', M)
    = if sameKind(M, (TyL Ty), (TyL' Ty'))
      then (op F : TyL' -> Ty' to F' [AtS'],
            opsAffdAux(OPDS, F, TLS, F', AtS', M))
      else (opsAffdAux(OPDS, F, (TyL' Ty') ; TLS, F', AtS', M),
            opsAffdAux(op F : TyL -> Ty [AtS] . OPDS, F, TLS, F', AtS', M))
      fi .
  eq opsAffdAux(OPDS, F, TLS, F', AtS, M) = none [owise] .

  op stratsAffd : StratDeclSet Renaming Module -> RenamingSet .
  op stratsAffdAux : StratDeclSet Qid TypeListSet Qid Module -> RenamingSet .

  eq stratsAffd(strat F : TyL @ Ty [AtS] . StratDcls, strat F to F', M)
    = strat F to F' .
  eq stratsAffd(StratDcls, strat F : TyL @ Ty to F', M)
    = stratsAffdAux(StratDcls, F, fixKinds(TyL Ty, M), F', M) .
  eq stratsAffd(StratDcls, RS:[RenamingSet], M) = none [owise] .

  eq stratsAffdAux(strat F : TyL @ Ty [AtS] . StratDcls,
       F, (TyL' Ty') ; TLS, F', M)
    = if sameKind(M, (TyL Ty), (TyL' Ty'))
      then (strat F : TyL' @ Ty' to F',
            stratsAffdAux(StratDcls, F, TLS, F', M))
      else (stratsAffdAux(StratDcls, F, (TyL' Ty') ; TLS, F', M),
            stratsAffdAux(strat F : TyL @ Ty [AtS] . StratDcls, F, TLS, F', M))
      fi .
  eq stratsAffdAux(StratDcls, F, TLS, F', M) = none [owise] .

*** The predicate \texttt{modAffd} checks whether the module with the
*** name given as first argument in the database is affected by the set of maps
*** given as second argument. A module is affected by a map set if any of the
*** maps is applicable to the module or to any of its submodules.

  op modAffd : Header RenamingSet Module Database -> Bool .

  op modAffdAux : Module RenamingSet Module Database -> Bool .
  op rlsAffd : RuleSet RenamingSet -> Bool .
  op importsAffd : ImportList RenamingSet Module Database -> Bool .
  op classesAffd : ClassDeclSet RenamingSet -> Bool .
  op msgsAffd : MsgDeclSet RenamingSet Module -> RenamingSet .
  op msgsAffdAux : MsgDeclSet Qid TypeListSet Qid Module -> RenamingSet .

  eq modAffd(ME, RS, M, DB)
    = modAffdAux(getTopModule(ME, DB), RS, M, DB) .

  eq modAffdAux(U, RS, M, DB)
    = sortsAffd(getSorts(U), RS)
      or-else
      (opsAffd(getOps(U), RS, M) == none
       or-else
       ((not U :: FModule
         and-then
         (rlsAffd(getRls(U), RS)
          or-else
          (not U :: SModule
           and-then
           (classesAffd(getClasses(U), RS)
            or-else
            msgsAffd(getMsgs(U), RS, M) == none))))
        or-else
        importsAffd(getImports(U), RS, M, DB))) .

  eq importsAffd(((including ME .) IL), RS, M, DB)
    = modAffd(ME, RS, M, DB)
      or-else importsAffd(IL, RS, M, DB) .
  eq importsAffd(((extending ME .) IL), RS, M, DB)
    = modAffd(ME, RS, M, DB)
      or-else importsAffd(IL, RS, M, DB) .
  eq importsAffd(((protecting ME .) IL), RS, M, DB)
    = modAffd(ME, RS, M, DB)
      or-else importsAffd(IL, RS, M, DB) .
  eq importsAffd(nil, RS, M, DB) = false .

  eq rlsAffd(((rl T => T' [label(L) AtS] .) RlS), (label L' to L''))
    = (L == L') or-else rlsAffd(RlS, label L' to L'') .
  eq rlsAffd(((rl T => T' [label(L) AtS] .) RlS),
       ((label L' to L''), RS))
    = (L == L') or-else
      (rlsAffd((rl T => T' [label(L) AtS] .), RS) or-else
       rlsAffd(RlS, ((label L' to L''), RS))) .
  eq rlsAffd(((crl T => T' if T'' = T3 [label(L) AtS] .) RlS),
       (label L' to L''))
    = (L == L') or-else rlsAffd(RlS, (label L' to L'')) .
  eq rlsAffd(((crl T => T' if T'' = T3 [label(L) AtS] .) RlS),
       ((label L' to L''), RS))
    = (L == L')
      or-else
      (rlsAffd((crl T => T' if T'' = T3 [label(L) AtS] .), RS)
      or-else
      rlsAffd(RlS, ((label L' to L''), RS))) .
  eq rlsAffd(RlS, RS) = false [owise] .

  eq classesAffd(((class C | ADS .) CDS), (class C' to C''))
    = (C == C')
      or-else
      classesAffd(CDS, (class C' to C'')) .
  eq classesAffd(((class C | ADS .) CDS), ((class C' to C''), RS))
    = (C == C')
      or-else
      (classesAffd((class C | ADS .), RS)
      or-else
      classesAffd(CDS, ((class C' to C''), RS))) .
  eq classesAffd(((class C | ((attr A : S), ADS) .) CDS),
       (attr A' . C' to A''))
    = if C == C'
      then (A == A')
           or-else
           classesAffd(((class C | ADS .) CDS), (attr A' . C' to A''))
      else classesAffd(CDS, (attr A' . C' to A''))
      fi .
  eq classesAffd(((class C | ((attr A : S), ADS) .) CDS),
       ((attr A' . C' to A''), RS))
    = if C == C'
      then (A == A')
           or-else
           (classesAffd(((class C | ADS .) CDS),
              ((attr A' . C' to A''), RS))
           or-else
           classesAffd(CDS, RS))
      else classesAffd((class C | ((attr A : S), ADS) .), RS)
           or-else
           classesAffd(CDS, ((attr A' . C' to A''), RS))
      fi .
  eq classesAffd(CDS, RS) = false [owise] .

  eq msgsAffd(msg F : TyL -> Ty . MDS, msg F to F', M) = msg F to F' .
  eq msgsAffd(MDS, msg F : TyL -> Ty to F', M)
    = msgsAffdAux(MDS, F, fixKinds(TyL Ty, M), F', M) .
  eq msgsAffd(MDS, RS:[RenamingSet], M) = none [owise] .

  eq msgsAffdAux(msg F : TyL -> Ty . MDS, F, (TyL' Ty') ; TLS, F', M)
    = if sameKind(M, (TyL Ty), (TyL' Ty'))
      then (msg F : TyL' -> Ty' to F',
            msgsAffdAux(MDS, F, TLS, F', M))
      else (msgsAffdAux(MDS, F, (TyL' Ty') ; TLS, F', M),
            msgsAffdAux(msg F : TyL -> Ty . MDS, F, TLS, F', M))
      fi .
  eq msgsAffdAux(MDS, F, TLS, F', M) = none [owise] .

*** The function \texttt{mapsRestrict} returns the subset of the view
*** maps given as second argument that affect the given module.

  op mapsRestrict : Module RenamingSet Module Database -> RenamingSet .
  op mapsRestrict : Header RenamingSet Module Database -> RenamingSet .

  eq mapsRestrict(ME, RS, M, DB)
    = mapsRestrict(getTopModule(ME, DB), RS, M, DB) .

  eq mapsRestrict(U, R, M, DB)
    = if modAffdAux(U, R, M, DB)
      then R
      else none
      fi .
  eq mapsRestrict(U, (R, RS), M, DB)
    = if modAffdAux(U, R, M, DB)
      then (R, mapsRestrict(U, RS, M, DB))
      else mapsRestrict(U, RS, M, DB)
      fi .
  eq mapsRestrict(U, none, M, DB) = none .

*** The definition of the function \texttt{header2QidList} on the renaming
*** module expression has to take care of transforming into a quoted identifier
*** list the set of view maps given in the module expression.

  op maps2QidList : RenamingSet -> QidList .

  op attrSet2QidList : AttrSet -> QidList .
  op hookList2QidList : HookList -> QidList .
  op termList2QidList : TermList -> QidList .
  op intList2QidList : IntList -> QidList .
  op typeList2QidList : TypeList -> QidList .

  eq maps2QidList(((op F to F' [AtS]), RS))
    = if AtS == none
      then ('op F 'to F' '`, '\s maps2QidList(RS))
      else ('op F 'to F' '\s '`[ attrSet2QidList(AtS) '`] '`, '\s
            maps2QidList(RS))
      fi
    [owise] .
  eq maps2QidList((op F to F' [AtS]))
    = if AtS == none
      then ('op F 'to F')
      else ('op F 'to F' '\s '`[ attrSet2QidList(AtS) '`])
      fi .
  eq maps2QidList(((op F : TyL -> Ty to F' [AtS]), RS))
    = if AtS == none
      then ('op F ': typeList2QidList(TyL) '-> Ty 'to F' '`,
            '\s maps2QidList(RS))
      else ('op F ': typeList2QidList(TyL) '-> Ty 'to F'
            '`[ attrSet2QidList(AtS) '`] '`, '\s maps2QidList(RS))
      fi
    [owise] .
  eq maps2QidList((op F : TyL -> Ty to F' [AtS]))
    = if AtS == none
      then ('op F ': typeList2QidList(TyL) '-> Ty 'to F')
      else ('op F ': typeList2QidList(TyL) '-> Ty 'to F'
            '`[ attrSet2QidList(AtS) '`])
      fi .
  eq maps2QidList(((sort S to S'), RS))
    = ('sort S 'to S' '`, '\s maps2QidList(RS))
    [owise] .
  eq maps2QidList((sort S to S')) = ('sort S 'to S') .

  eq maps2QidList(((label L to L'), RS))
    = ('label L 'to L' '`, '\s maps2QidList(RS))
    [owise] .
  eq maps2QidList((label L to L')) = ('label L 'to L') .

  eq maps2QidList(((msg F to F'), RS))
    = ('msg F 'to F' '`, '\s maps2QidList(RS))
    [owise] .
  eq maps2QidList((msg F to F')) = ('msg F 'to F') .

  eq maps2QidList(((msg F : TyL  -> Ty to F'), RS))
    = ('msg F ': typeList2QidList(TyL) '-> Ty 'to F' '`, '\s
       maps2QidList(RS))
    [owise] .
  eq maps2QidList((msg F : TyL -> Ty to F'))
    = ('msg F ': typeList2QidList(TyL) '-> Ty 'to F') .

  eq maps2QidList(((strat F to F'), RS))
    = ('strat F 'to F' '`, '\s maps2QidList(RS))
    [owise] .
  eq maps2QidList((strat F to F')) = ('msg F 'to F') .

  eq maps2QidList(((strat F : TyL  @ Ty to F'), RS))
    = ('strat F ': typeList2QidList(TyL) '@ Ty 'to F' '`, '\s
       maps2QidList(RS))
    [owise] .
  eq maps2QidList((strat F : TyL @ Ty to F'))
    = ('strat F ': typeList2QidList(TyL) '@ Ty 'to F') .

  eq maps2QidList(((class S to S'), RS))
    = ('class S 'to S' '`, '\s maps2QidList(RS))
    [owise] .
  eq maps2QidList((class S to S')) = ('class S 'to S') .

  eq maps2QidList(((attr QI . S to QI'), RS))
    = ('attr S '. QI 'to QI' '`, '\s maps2QidList(RS))
    [owise] .
  eq maps2QidList((attr QI . S to QI')) = ('attr S '. QI 'to QI') .

  eq maps2QidList(none) = nil .

  eq attrSet2QidList(none) = nil .
  eq attrSet2QidList((assoc AtS)) = ('assoc attrSet2QidList(AtS)) .
  eq attrSet2QidList((comm AtS))  = ('comm attrSet2QidList(AtS)) .
  eq attrSet2QidList((idem AtS))  = ('idem attrSet2QidList(AtS)) .
  eq attrSet2QidList((iter AtS))  = ('iter attrSet2QidList(AtS)) .
  eq attrSet2QidList((id(T) AtS))
    = ('id: termList2QidList(T) attrSet2QidList(AtS)) .
  eq attrSet2QidList((right-id(T) AtS))
    = ('right-id: termList2QidList(T) attrSet2QidList(AtS)) .
  eq attrSet2QidList((left-id(T) AtS))
    = ('left-id: termList2QidList(T) attrSet2QidList(AtS)) .
  eq attrSet2QidList((poly(NL) AtS))
    = ('poly '`( intList2QidList(NL) '`) attrSet2QidList(AtS)) .
  eq attrSet2QidList((strat(NL) AtS))
    = ('strat '`( intList2QidList(NL) '`) attrSet2QidList(AtS)) .
  eq attrSet2QidList((memo AtS))  = ('memo attrSet2QidList(AtS)) .
  eq attrSet2QidList((prec(N) AtS))
    = ('prec intList2QidList(N) attrSet2QidList(AtS)) .
  eq attrSet2QidList((gather(QIL) AtS))
    = ('gather QIL attrSet2QidList(AtS)) .
  eq attrSet2QidList((format(QIL) AtS))
    = ('format QIL attrSet2QidList(AtS)) .
  eq attrSet2QidList((ctor AtS))  = ('ctor attrSet2QidList(AtS)) .
  eq attrSet2QidList((frozen(NL) AtS))
    = ('frozen '`( intList2QidList(NL) '`) attrSet2QidList(AtS)) .
  eq attrSet2QidList((config AtS))  = ('config attrSet2QidList(AtS)) .
  eq attrSet2QidList((object AtS))  = ('object attrSet2QidList(AtS)) .
  eq attrSet2QidList((msg AtS))  = ('msg attrSet2QidList(AtS)) .
  eq attrSet2QidList((special(HkL) AtS))
    = ('special '`( hookList2QidList(HkL) '`) attrSet2QidList(AtS)) .
  eq attrSet2QidList((none).AttrSet) = nil .
  eq attrSet2QidList((metadata(St) AtS)) = (('metadata qid("\"" + St + "\"")) attrSet2QidList(AtS)) .
  eq attrSet2QidList((nonexec AtS))  = ('nonexec attrSet2QidList(AtS)) .
  eq attrSet2QidList((variant AtS))  = ('variant attrSet2QidList(AtS)) .

  eq hookList2QidList((id-hook(QI, QIL) HkL))
    = ('id-hook QI '`, '`( QIL '`) hookList2QidList(HkL)) .
  eq hookList2QidList((op-hook(QI, QI', QIL, QI'') HkL))
    = ('op-hook QI '`( QI' ': QIL '-> QI'' '`) hookList2QidList(HkL)) .
  eq hookList2QidList((term-hook(QI, T) HkL))
    = ('term-hook '`( QI '`, termList2QidList(T) '`) hookList2QidList(HkL)) .

  eq termList2QidList(QI) = QI .
  eq termList2QidList(F[TL]) = (F '`( termList2QidList(TL) '`)) .
  ceq termList2QidList((T, TL))
    = (termList2QidList(T) '`, termList2QidList(TL))
    if TL =/= empty .

  eq intList2QidList((N NL)) = (qid(string(N, 10)) intList2QidList(NL)) .
  eq intList2QidList(nil) = nil .

  eq typeList2QidList(Ty TyL) = type2qid(Ty) typeList2QidList(TyL) .
  eq typeList2QidList(nil) = nil .

*** Let us now give the equations for \texttt{setUpModExpDeps} on the
*** renaming module expression.  Given a module expression of the form
*** \verb~ME *< RS >~ such that \texttt{ME} is in the database, we just need
*** to add \verb~ME *< RS >~ to the set of names of the modules depending on
*** \texttt{ME}. In this way, if \texttt{ME} is redefined or removed from the
*** database, \verb~ME *< RS >~ will be removed as well.

  eq setUpModExpDeps(ME * (RS),
       db(< ME ; DT ; U ; U' ; M ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = db(< ME ; DT ; U ; U' ; M ; VDS ; MNS . ME * (RS) ; VES > MIS,
         MNS', VIS, VES', MNS'', MNS3, MNS4, QIL) .
  eq setUpModExpDeps(ME * (RS),
       db(< ME ; DM ; U ; U' ; M ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = db(< ME ; DM ; U ; U' ; M ; VDS ; MNS . ME * (RS) ; VES > MIS,
         MNS', VIS, VES', MNS'', MNS3, MNS4, QIL) .
  ceq setUpModExpDeps(ME * (RS), DB)
    = warning(DB, '\r 'Error: '\o 'Module header2QidList(ME) 'not 'in 'database. '\n)
    if not unitInDb(ME, DB) .

*** The definition of the \texttt{prepHeader} function on a renaming module
*** expression must take into account the possibility of having parameterized
*** sorts or parameterized class names in the maps of a renaming module
*** expression.  The preparation of a renaming module expression must take
*** into account this fact and prepare accordingly all parameterized sorts and
*** classes appearing in it.

  op prepare : RenamingSet Set{Tuple{ViewExpression,ViewExpression}} -> RenamingSet .

  op prepare : TypeList Set{Tuple{ViewExpression,ViewExpression}} -> TypeList .

  eq prepModExp(ME * (RS), VEPS)
    = _*`(_`)(prepModExp(ME, VEPS), prepare(RS, VEPS)) .

*** For example, for sort maps the equation is as follows.

  eq prepare((sort S to S'), VEPS)
    = (sort prepSort(S, VEPS) to prepSort(S', VEPS)) .
  eq prepare(((sort S to S'), RS), VEPS)
    = ((sort prepSort(S, VEPS) to prepSort(S', VEPS)),
       prepare(RS, VEPS)) .


  eq prepare((class S to S'), VEPS)
    = (class prepSort(S, VEPS) to prepSort(S', VEPS)) .
  eq prepare(((class S to S'), RS), VEPS)
    = ((class prepSort(S, VEPS) to prepSort(S', VEPS)),
       prepare(RS, VEPS)) .
  eq prepare((attr QI . S to QI'), VEPS)
    = (attr QI . prepSort(S, VEPS) to QI') .
  eq prepare(((attr QI . S to QI'), RS), VEPS)
    = ((attr QI . prepSort(S, VEPS) to QI'), prepare(RS, VEPS)) .
  eq prepare((op F to F' [AtS]), VEPS) = (op F to F' [AtS]) .
  eq prepare(((op F to F' [AtS]), RS), VEPS)
    = ((op F to F' [AtS]), prepare(RS, VEPS)) .
  eq prepare((op F : TyL -> Ty to F' [AtS]), VEPS)
    = (op F : prepare(TyL, VEPS) -> prepSort(Ty, VEPS) to F' [AtS]) .
  eq prepare(((op F : TyL -> Ty to F' [AtS]), RS), VEPS)
    = (op F : prepare(TyL, VEPS) -> prepSort(Ty, VEPS) to F' [AtS],
       prepare(RS, VEPS)) .
  eq prepare((label L to L'), VEPS) = (label L to L') .
  eq prepare(((label L to L'), RS), VEPS)
    = ((label L to L'), prepare(RS, VEPS)) .
  eq prepare((msg F to F'), VEPS) = (msg F to F') .
  eq prepare(((msg F to F'), RS), VEPS)
    = ((msg F to F'), prepare(RS, VEPS)) .
  eq prepare((msg F : TyL -> Ty to F'), VEPS)
    = (msg F : prepare(TyL, VEPS) -> prepSort(Ty, VEPS) to F') .
  eq prepare(((msg F : TyL -> Ty to F'), RS), VEPS)
    = ((msg F : prepare(TyL, VEPS) -> prepSort(Ty, VEPS) to F'),
       prepare(RS, VEPS)) .
  eq prepare(strat F to F', VEPS) = (strat F to F') .
  eq prepare((strat F to F', RS), VEPS)
    = strat F to F', prepare(RS, VEPS) .
  eq prepare(strat F : TyL @ Ty to F', VEPS)
    = strat F : prepare(TyL, VEPS) @ prepSort(Ty, VEPS) to F' .
  eq prepare((strat F : TyL @ Ty to F', RS), VEPS)
    = strat F : prepare(TyL, VEPS) @ prepSort(Ty, VEPS) to F',
      prepare(RS, VEPS) .
  eq prepare((none).RenamingSet, VEPS) = none .

  eq prepare((Ty TyL), VEPS) = (prepSort(Ty, VEPS) prepare(TyL, VEPS)) .
  eq prepare(nil, VEPS) = nil .

  eq header2Qid(ME * (RS))
    = qid(string(header2Qid(ME))
          + " * (" + string(qidList2Qid(maps2QidList(RS))) + ")")
    [owise] .

  ceq header2QidList(ME * (RS))
    = (if QI == '\s then QIL QI else QIL QI '\s fi
       '* '\s '`( maps2QidList(RS) '`))
    if QIL QI := header2QidList(ME)
    [owise] .

endfm

*******************************************************************************

***
*** The Union Module Expression
***

*** The syntax used for the union of module expressions is

***   op _+_ : ModuleExpression ModuleExpression -> ModuleExpression
***       [assoc prec 42] .

*** Its evaluation consists in generating a unit importing the two module
*** expressions given as arguments~\cite{Winkler91,OBJ92}.

*** As we explained in Sections~\ref{instantiation} and~\ref{renaming} for the
*** cases of the instantiation and the renaming module expressions,
*** respectively, the declaration of any new kind of module expression must
*** come together with the definition of the functions \texttt{evalModExp},
*** \texttt{header2QidList}, and \texttt{setUpModExpDeps} on the new
*** module operator. As discussed in Sections~\ref{instantiation}
*** and~\ref{parsing-unit-declarations}, equations for the \texttt{prepHeader}
*** and \texttt{parseModExp} functions have to be given as well.

fmod UNION-EXPR is
  inc MOD-EXPR .
  pr FM-INST-EXPR-EVALUATION .
  pr FM-RENAMING-EXPR-EVALUATION .
  pr FM-EVALUATION .

  vars QI X : Qid .
  var  PDL : ParameterDeclList .
  vars DB DB' DB'' : Database .
  vars T T' : Term .
  vars DT DT' : Default{Term} .
  var  IL : ImportList .
  var  VEPS : Set{Tuple{ViewExpression,ViewExpression}} .
  vars ME ME' ME'' ME3 : ModuleExpression .
  vars PU PU' U U' U'' U3 DM DM' : Module .
  vars M M' M'' M3 : Module .
  vars MNS MNS' MNS'' MNS3 MNS4 MNS5 : Set{ModuleName} .
  vars VES VES' VES'' : Set{ViewExpression} .
  vars PDS PDS' PDS'' : Set{ParameterDecl} .
  vars MIS MIS' : Set{ModuleInfo} .
  var  VIS : Set{ViewInfo} .
  vars QIL QIL' : QidList .
  var  VDS VDS' : VariableSet .
  var  B : Bool .
  var  MAPS : RenamingSet .

*** As mentioned above, the evaluation of a union module expression consists
*** in the creation of a new unit, with such a module expression as name,
*** which imports the two module expressions being united. Note, however,
*** that the unit being created has to be of the right type. The new unit
*** will be generated having one type or another, depending on the types of
*** the arguments of the union module expression.

*** The function \texttt{rightEmptyModule} generates an empty unit of the
*** lowest of the sorts of its two arguments. In case of having a nonstructured
*** module as argument, the corresponding structured one is considered. If one
*** of the two module expressions corresponds to a theory, then a theory is
*** generated, and the lowest sort is taken between the sort of such a theory
*** and the \texttt{Module} sort immediately above the sort of the other unit;
*** that is, sorts \texttt{FModule}, \texttt{SModule}, or \texttt{OModule} are
*** considered to do the comparison.

  ceq evalModExp(ME + ME', PDL, DB)
    = if unitInDb(ME'', DB') or-else not summandsInDB(ME'', DB')
      then < DB' ; ME'' >
      else < evalModule(
               addImports(unfoldSummands(ME''),
                 setName(rightEmptyModule(ME'', DB'), ME'')),
               none,
               DB')
             ; ME'' >
      fi
    if < DB' ; ME'' > := evalModExp+(ME + ME', PDL, DB) .

  op summandsInDB : ModuleExpression Database -> Bool .
  eq summandsInDB(ME + ME', DB)
    = summandsInDB(ME, DB) and-then summandsInDB(ME', DB) .
  eq summandsInDB(ME, DB) = unitInDb(ME, DB) [owise] .

  op unfoldSummands : ModuleExpression -> ImportList .
  eq unfoldSummands(ME + ME') = unfoldSummands(ME) unfoldSummands(ME') .
  eq unfoldSummands(ME) = (including ME .) [owise] .

  op rightEmptyModule : ModuleExpression Database -> Module .
  eq rightEmptyModule(ME, DB) = emptyModule(kindOfModule(ME, DB)) .

  op evalModExp+ : ModuleExpression ParameterDeclList Database -> Tuple{Database, ModuleExpression} .
  eq evalModExp+(ME + ME', PDL, DB)
    = < database(evalModExp+(ME', PDL, database(evalModExp+(ME, PDL, DB))))
      ; modExp(evalModExp+(ME', PDL, database(evalModExp+(ME, PDL, DB))))
        + modExp(evalModExp+(ME, PDL, DB)) > .
  eq evalModExp+(ME, PDL, DB) = evalModExp(ME, PDL, DB) [owise] .

  op kindOfModule : ModuleExpression Database -> Qid .
  eq kindOfModule(ME + ME', DB) = greaterLowest(kindOfModule(ME, DB), kindOfModule(ME', DB)) .
  eq kindOfModule(ME, DB) = kindOfModule(getTopModule(ME, DB)) [owise] .

  op kindOfModule : Module -> Qid .
  eq kindOfModule(U:OModule)
    = if U:OModule :: FModule
      then 'fmod
      else if U:OModule :: SModule
           then 'mod
           else if U:OModule :: StratModule
                then 'smod
                else 'omod
                fi
           fi
      fi .
  eq kindOfModule(U:OTheory)
    = if U:OTheory :: FTheory
      then 'fmod
      else if U:OTheory :: STheory
           then 'mod
           else if U:OTheory :: StratTheory
                then 'smod
                else 'omod
                fi
           fi
      fi .
  eq kindOfModule(unitError(QIL)) = qidError(QIL) .

  op greaterLowest : Qid Qid ~> Qid [comm] .
  eq greaterLowest('fmod, 'fmod) = 'fmod .
  eq greaterLowest('fmod, 'fth) = 'fth .
  eq greaterLowest('fth, 'fth) = 'fth .
  eq greaterLowest('mod, 'fmod) = 'mod .
  eq greaterLowest('mod, 'mod) = 'mod .
  eq greaterLowest('mod, 'fth) = 'th .
  eq greaterLowest('fmod, 'th) = 'th .
  eq greaterLowest('mod, 'th) = 'th .
  eq greaterLowest('th, 'th) = 'th .
  eq greaterLowest('omod, 'fmod) = 'omod .
  eq greaterLowest('omod, 'mod) = 'omod .
  eq greaterLowest('omod, 'omod) = 'omod .
  eq greaterLowest('omod, 'fth) = 'oth .
  eq greaterLowest('omod, 'th) = 'oth .
  eq greaterLowest('omod, 'oth) = 'oth .
  eq greaterLowest('fmod, 'oth) = 'oth .
  eq greaterLowest('mod, 'oth) = 'oth .
  eq greaterLowest('oth, 'th) = 'oth .
  eq greaterLowest('oth, 'fth) = 'oth .
  eq greaterLowest('oth, 'oth) = 'oth .

  op emptyModule : Qid ~> Module .
  eq emptyModule('fmod) = emptyFModule .
  eq emptyModule('fth) = emptyFTheory .
  eq emptyModule('mod) = emptySModule .
  eq emptyModule('th) = emptySTheory .
  eq emptyModule('omod) = emptyOModule .
  eq emptyModule('oth) = emptyOTheory .

*** As pointed out in Section~\ref{module-names}, for each new module
*** expression operator being introduced, we need to add equations for the
*** \texttt{header2Qid} function. For the union module expression we only
*** need the following equation:

  eq header2Qid(ME + ME')
    = qidList2Qid(header2QidList(ME) '+ header2QidList(ME')) .
  eq header2Qid(_*`(_`)(ME + ME', MAPS))
    = qid("(" + string(header2Qid(ME + ME')) + ")"
          + " * (" + string(qidList2Qid(maps2QidList(MAPS))) + ")") .

  eq header2QidList(ME + ME')
    = (header2QidList(ME) '+ header2QidList(ME')) .
  ceq header2QidList(_*`(_`)(ME + ME', MAPS))
    = (if QI == '\s then '`( QIL '`) QI else '`( QIL QI '`) '\s fi
       '* '\s '`( maps2QidList(MAPS) '`))
    if QIL QI := header2QidList(ME + ME') .

*** Given a module
*** expression of the form \verb~ME + ME'~ such that \texttt{ME} and
*** \texttt{ME'} are in the database, we need to add \verb~ME + ME'~ to
*** the set of names of the modules depending on \texttt{ME} and \texttt{ME'}.
*** In this way, if \texttt{ME} or \texttt{ME'} are redefined or removed from
*** the database, \verb~ME + ME'~ will be removed as well.

  op setUpModExpDepsAux : ModuleExpression ModuleExpression Database -> Database .
  eq setUpModExpDeps(ME + ME', DB) = setUpModExpDepsAux(ME + ME', ME + ME', DB) .

  eq setUpModExpDepsAux(ME, ME' + ME'', DB)
   = setUpModExpDepsAux(ME, ME', setUpModExpDepsAux(ME, ME'', DB)) .
  eq setUpModExpDepsAux(ME, ME',
      db(< ME' ; DT ; U ; U' ; M ; VDS ; MNS ; VES > MIS, MNS'', VIS, VES'', MNS3, MNS4, MNS5, QIL))
   = db(< ME' ; DT ; U ; U' ; M ; VDS ; MNS . ME ; VES > MIS, MNS'', VIS, VES'', MNS3, MNS4, MNS5, QIL)
   [owise] .
  eq setUpModExpDepsAux(ME, ME',
      db(< ME' ; DM ; U ; U' ; M ; VDS ; MNS ; VES > MIS, MNS'', VIS, VES'', MNS3, MNS4, MNS5, QIL))
   = db(< ME' ; DM ; U ; U' ; M ; VDS ; MNS . ME ; VES > MIS, MNS'', VIS, VES'', MNS3, MNS4, MNS5, QIL)
   [owise] .

---(  eq setUpModExpDeps((ME + ME'),
      db((< ME ; DT ; U ; U' ; M ; VDS ; MNS ; VES >
          < ME' ; DT' ; U'' ; U3 ; M' ; VDS' ; MNS' ; VES' > MIS),
         MNS'', VIS, VES'', MNS3, MNS4, MNS5, QIL))
   = db((< ME ; DT ; U ; U' ; M ; VDS ; MNS . (ME + ME') ; VES >
         < ME' ; DT' ; U'' ; U3 ; M' ; VDS' ; MNS' . (ME + ME') ; VES' >
         MIS),
        MNS'', VIS, VES'', MNS3, MNS4, MNS5, QIL) .
  eq setUpModExpDeps((ME + ME'),
      db((< ME ; DT ; U ; U' ; M ; VDS ; MNS ; VES >
          < ME' ; DM ; U'' ; U3 ; M' ; VDS' ; MNS' ; VES' > MIS),
         MNS'', VIS, VES'', MNS3, MNS4, MNS5, QIL))
   = db((< ME ; DT ; U ; U' ; M ; VDS ; MNS . (ME + ME') ; VES >
         < ME' ; DM ; U'' ; U3 ; M' ; VDS' ; MNS' . (ME + ME') ; VES' >
         MIS),
        MNS'', VIS, VES'', MNS3, MNS4, MNS5, QIL) .
  eq setUpModExpDeps((ME + ME'),
      db((< ME ; DM ; U ; U' ; M ; VDS ; MNS ; VES >
          < ME' ; DT ; U'' ; U3 ; M' ; VDS' ; MNS' ; VES' > MIS),
         MNS'', VIS, VES'', MNS3, MNS4, MNS5, QIL))
   = db((< ME ; DM ; U ; U' ; M ; VDS ; MNS . (ME + ME') ; VES >
         < ME' ; DT ; U'' ; U3 ; M' ; VDS' ; MNS' . (ME + ME') ; VES' >
         MIS),
        MNS'', VIS, VES'', MNS3, MNS4, MNS5, QIL) .
  eq setUpModExpDeps((ME + ME'),
      db((< ME ; DM ; U ; U' ; M ; VDS ; MNS ; VES >
          < ME' ; DM' ; U'' ; U3 ; M' ; VDS' ; MNS' ; VES' > MIS),
         MNS'', VIS, VES'', MNS3, MNS4, MNS5, QIL))
   = db((< ME ; DM ; U ; U' ; M ; VDS ; MNS . (ME + ME') ; VES >
         < ME' ; DM' ; U'' ; U3 ; M' ; VDS' ; MNS' . (ME + ME') ; VES' >
         MIS),
        MNS'', VIS, VES'', MNS3, MNS4, MNS5, QIL) .
  ceq setUpModExpDeps((ME + ME'), DB)
    = warning(DB, ('\r 'Error: '\o 'Module header2QidList(ME) 'not 'in 'database. '\n))
    if not unitInDb(ME, DB) .
  ceq setUpModExpDeps((ME + ME'), DB)
    = warning(DB, ('\r 'Error: '\o 'Module header2QidList(ME') 'not 'in 'database. '\n))
    if not unitInDb(ME', DB) .
---)

*** The \texttt{prepHeader} function on a union module expression makes
*** recursive calls with each of the module expressions given as arguments.

  eq prepModExp(ME + ME', VEPS)
    = prepModExp(ME, VEPS) + prepModExp(ME', VEPS) .

*** Finally, the equation for the \texttt{parseModExp} function is as follows:

  eq labelInModExp(X, ME + ME')
    = labelInModExp(X, ME) or-else labelInModExp(X, ME') .
endfm

*******************************************************************************

***
*** The $n$-tuple Module Expression
***

*** The syntax used for the $n$-tuple module expression is as follows:

***   op TUPLE[_] : Token -> ModuleExpression .

*** Its evaluation consists in the generation of a parameterized functional
*** module with the number of \texttt{TRIV} parameters specified by the
*** argument. A sort for tuples of such size, and the corresponding constructor
*** and selector operators, are also defined. Note that the \texttt{TRIV}
*** theory is predefined in Full Maude (see Sections~\ref{main-module}
*** and~\ref{non-built-in-predefined}). For example, the module expression
*** \verb~TUPLE[3]~ produces the following module.

*** fmod TUPLE[3][C1 :: TRIV, C2 :: TRIV, C3 :: TRIV] is
***    sorts 3Tuple .
***    op (_,_,_) : Elt.C1 Elt.C2 Elt.C3 -> 3Tuple .
***    op p1_ : 3Tuple -> Elt.C1 .
***    op p2_ : 3Tuple -> Elt.C2 .
***    op p3_ : 3Tuple -> Elt.C3 .
***    var E1 : Elt.C1 .
***    var E2 : Elt.C2 .
***    var E3 : Elt.C3 .
***    eq p1(E1, E2, E3) = E1 .
***    eq p2(E1, E2, E3) = E2 .
***    eq p3(E1, E2, E3) = E3 .
*** endfm

*** Even though the $n$-tuple module expression is in principle of a completely
*** different nature, the way of handling it is the same as the way of handling
*** any other module expression. Its evaluation produces a new unit, a
*** parameterized functional module in this case, wtupleParList(N)ith the module expression as
*** name. New equations defining the semantics of functions
*** \texttt{evalModExp}, \texttt{header2QidList},
*** \texttt{setUpModExpDeps}, \texttt{prepHeader}, and
*** \texttt{parseModExp} are given for this module expression.


fmod N-TUPLE-EXPR is
  inc MOD-EXPR .
  pr FM-INST-EXPR-EVALUATION .
  pr FM-EVALUATION .

  vars N N' : NzNat .
  var  PDL : ParameterDeclList .
  var  DB : Database .
  var  T : Term .
  var  IL : ImportList .
  var  VEPS : Set{Tuple{ViewExpression,ViewExpression}} .
  var  X : Qid .
  var  S : Sort .

*** The equation for the \texttt{evalModExp} is reduced to the creation of a
*** module as indicated above. Some auxiliary functions are defined in order
*** to generate the different declarations in the module.

  op tupleParList : NzNat -> ParameterDeclList .
  op tupleImportList : NzNat -> ImportList .
  op createCopyPars : NzNat Database -> Database .
  op tupleOps : NzNat -> OpDeclSet .
  op tupleOpsCtor : NzNat -> OpDecl .
  op tupleOpsCtorName : NzNat -> String .
  op tupleOpsCtorArity : NzNat -> QidList .
  op tupleOpsSelectors : NzNat NzNat -> OpDeclSet .
  op tupleEqSet : NzNat -> EquationSet .
  op tupleEqSetAux : NzNat Term -> EquationSet .
  op tupleTermArgs : NzNat -> TermList .
  ops tupleSort tupleSortAux : NzNat -> Sort .

  eq evalModExp(TUPLE[N], PDL, DB)
    = if unitInDb(TUPLE[N], DB)
      then < DB ; TUPLE[N] >
      else < evalModule(
               fmod TUPLE[N]{tupleParList(N)} is
                 nil  ---- tupleImportList(N)
                 sorts tupleSort(N) .
                 none
                 tupleOps(N)
                 none
                 tupleEqSet(N)
               endfm,
               none,
               createCopyPars(N, DB)) ;
             TUPLE[N] >
      fi .

  eq createCopyPars(N, DB)
    = if N == 1
      then createCopy((qid("C" + string(N, 10)) :: 'TRIV), DB)
      else createCopyPars(_-_(N, 1),
             createCopy((qid("C" + string(N, 10)) :: 'TRIV), DB))
      fi .

  eq tupleParList(N)
    = if N == 1
      then (qid("C" + string(N, 10)) :: 'TRIV)
      else (tupleParList(_-_(N, 1)), (qid("C" + string(N, 10)) :: 'TRIV))
      fi .

  eq tupleImportList(N)
    = if N == 1
      then (including pd(qid("C" + string(N, 10)) :: 'TRIV) .)
      else (tupleImportList(_-_(N, 1))
            (including pd(qid("C" + string(N, 10)) :: 'TRIV) .))
      fi .

  eq tupleSort(N) = makeSort('Tuple, tupleSortAux(N)) .

  eq tupleSortAux(N)
    = if N == 1
      then qid("C" + string(N, 10))
      else (tupleSortAux(_-_(N, 1)), qid("C" + string(N, 10)))
      fi .

  eq tupleOps(N)
    = (tupleOpsCtor(N) tupleOpsSelectors(N, N)) .

  eq tupleOpsCtor(N)
    = (op qid("(" + tupleOpsCtorName(N) + ")") :
            tupleOpsCtorArity(N) -> tupleSort(N) [none] .) .

  eq tupleOpsCtorName(N)
    = if N == 1
      then "_"
      else "_," + tupleOpsCtorName(_-_(N, 1))
      fi .

  eq tupleOpsCtorArity(N)
    = if N == 1
      then qid("C" + string(N, 10) + "$Elt")
      else tupleOpsCtorArity(_-_(N, 1)) qid("C" + string(N, 10) + "$Elt")
      fi .

  eq tupleOpsSelectors(N, N')
    = if N == 1
      then (op qid("p" + string(N, 10) + "_") :
                 tupleSort(N') -> qid("C" + string(N, 10) + "$Elt") [none] .)
      else (tupleOpsSelectors(_-_(N, 1), N')
            (op qid("p" + string(N, 10) + "_") :
                  tupleSort(N') -> qid("C" + string(N, 10) + "$Elt") [none] .))
      fi .

  eq tupleEqSet(N)
    = tupleEqSetAux(N,
        (qid("(" + tupleOpsCtorName(N) + ")") [ tupleTermArgs(N) ])) .

  eq tupleTermArgs(N)
    = if N == 1
      then qid("V" + string(N, 10) + ":C" + string(N, 10) + "$Elt")
      else (tupleTermArgs(_-_(N, 1)),
            qid("V" + string(N, 10) + ":C" + string(N, 10) + "$Elt"))
      fi .

  eq tupleEqSetAux(N, T)
    = if N == 1
      then (eq qid("p" + string(N, 10) + "_")[T]
              = qid("V" + string(N, 10) + ":C" + string(N, 10) + "$Elt")
              [none] .)
      else (tupleEqSetAux(_-_(N, 1), T)
            (eq qid("p" + string(N, 10) + "_")[T]
               = qid("V" + string(N, 10) + ":C" + string(N, 10) + "$Elt")
               [none] .))
      fi .

*** The equations for the \texttt{header2QidList},
*** \texttt{parseModExp}, \texttt{prepHeader}, and
*** \texttt{setUpModExpDeps} functions on the $n$-tuple module
*** expression are as follows:

  eq header2Qid(TUPLE[N]) = qid("TUPLE[" + string(N, 10) + "]") .
  eq header2QidList(TUPLE[N]) = ('TUPLE '`[ qid(string(N, 10)) '`]) .

  eq prepModExp(TUPLE[N], VEPS) = TUPLE[N] .

  eq setUpModExpDeps(TUPLE[N], DB) = DB .

endfm

fmod N-POWER-EXPR is
  inc MOD-EXPR .
  pr FM-INST-EXPR-EVALUATION .
  pr FM-EVALUATION .

  vars N N' : NzNat .
  var  PDL : ParameterDeclList .
  var  DB : Database .
  var  T : Term .
  var  IL : ImportList .
  var  VEPS : Set{Tuple{ViewExpression,ViewExpression}} .
  var  X : Qid .
  var  S : Sort .

*** As for TUPLE, the equation for the \texttt{evalModExp} is reduced to the
*** creation of a new module. A module expression POWER[n]{Nat} produces a
*** module
***
*** fmod POWER[n]{X :: TRIV} is
***   inc TUPLE[n]{X, X, ..., X} .
*** endfm
***
*** which is then instantiated by the Nat view.

*** Some auxiliary functions are defined in order
*** to generate the different declarations in the module.

  op powImportList : NzNat -> ImportList .
  op powTupleImportation : NzNat -> ViewExpression .

  eq evalModExp(POWER[N], PDL, DB)
    = if unitInDb(POWER[N], DB)
      then < DB ; POWER[N] >
      else < evalModule(
               fmod POWER[N]{'X :: 'TRIV} is
                 powImportList(N)
                 sorts none .
                 none
                 none
                 none
                 none
               endfm,
               none,
               createCopy('X :: 'TRIV, DB)) ;
             POWER[N] >
      fi .

  eq powImportList(N)
    = (including TUPLE[N]{powTupleImportation(N)} .) .

  eq powTupleImportation(N)
    = if N == 1
      then 'X
      else ('X, powTupleImportation(sd(N, 1)))
      fi .

*** The equations for the \texttt{header2QidList},
*** \texttt{parseModExp}, \texttt{prepHeader}, and
*** \texttt{setUpModExpDeps} functions on the $n$-tuple module
*** expression are as follows:

  eq header2Qid(POWER[N]) = qid("POWER[" + string(N, 10) + "]") .
  eq header2QidList(POWER[N]) = ('POWER '`[ qid(string(N, 10)) '`]) .

  eq prepModExp(POWER[N], VEPS) = POWER[N] .

  eq setUpModExpDeps(POWER[N], DB) = DB .

endfm

*******************************************************************************

***
*** 8 Input/Output Processing
***

*** In this section we discuss how the preterm resulting from the call to the
*** function \texttt{metaParse} with the input and the top-level signature of
*** Full Maude is transformed into a term of sort \texttt{Module}, representing
*** a preunit or a term of sort \texttt{PreView}. In the case of commands,
*** they are evaluated giving the corresponding results in the appropriate
*** form.

***
*** 8.1 Input Parsing
***

*** Let us recall here the example presented in Section~\ref{bubbles}. Calling
*** \texttt{metaParse} with the module \texttt{NAT3} given there and the
*** signature of Full Maude presented in Section~\ref{sec:signature}, we
*** obtain the following term.

***    'fmod_is_endfm[
***       'token[{''NAT3}'Qid],
***       '__['sort_.['token[{''Nat3}'Qid]],
***           '__['op_:_->_.['token[{''s_}'Qid],
***                          'neTokenList[{''Nat3}'Qid],
***                          'token[{''Nat3}'Qid]],
***               '__['op_:`->_.['token[{''0}'Qid],
***                              'token[{''Nat3}'Qid]],
***                   'eq_=_.['bubble['__[{''s}'Qid, {''s}'Qid,
***                                       {''s}'Qid, {''0}'Qid]],
***                           'bubble[{''0}'Qid]]]]]]

*** Given each one of the subterms representing declarations in terms
*** representing modules as the previous one, the function \texttt{parseDecl}
*** generates the corresponding declaration, with no bubbles in it, and the
*** corresponding predeclaration, with the bubbles appearing in the term. For
*** example, for the term
***
***   'op_:_->_.['token[{''s_}'Qid],
***              'neTokenList[{''Nat3}'Qid],
***              'token[{''Nat3}'Qid]]
***
*** the following operator declaration is generated:
***
***   op 's_ : 'Nat3 -> 'Nat3 [none] .
***
*** Note that in this case, since the operator is declared without identity
*** element (the only place a bubble might appear), the declaration and the
*** predeclaration generated by \texttt{parseDecl} coincide.

*** In the following sections we shall see how this approach is followed for
*** declarations appearing in units and in views.

***
*** 8.1.1 Parsing of Module Declarations
***

*** The \texttt{parseDecl} function takes a term (which corresponds to a
*** declaration to be parsed), a preunit (to which the parsed declaration with
*** its bubbles in it will be added), and a unit (to which the parsed
*** declaration without bubbles will be added to build up the signature). For
*** example, a term corresponding to an unconditional equation, that is, a term
*** of the form \verb~'eq_=_.[T, T']~ will be added to the set of equations of
*** the preunit as \verb~eq T = T' .~, but nothing will be added to the unit.
*** Note that according to the signature used in the call to
*** \texttt{metaParse} (see Sections~\ref{sec:signature}
*** and~\ref{main-module}), \texttt{T} and \texttt{T'} are bubbles.
*** Declarations of sorts, subsort relations, operators, classes, subclass
*** relations, messages, and variables will be added to both of them. In the
*** case of operator declarations, identity element attributes, which in
*** general can be terms, are not included in the added declaration.

*** As in Core Maude, declarations in a module can be given in any order, and
*** therefore we follow a two-step approach consisting in first building the
*** signature to parse the bubbles, and then generating the unit without
*** bubbles in it. It could be different for other languages. For example, in
*** some languages we may be able to assume that each operator and sort has
*** been defined before being used, allowing then an incremental processing of
*** the input.

---- fmod MAYBE{X :: TRIV} is
----   sort Maybe{X} .
----   subsort X$Elt < Maybe{X} .
----   op maybe : -> Maybe{X} .
---- endfm

fmod UNIT-DECL-PARSING is
  pr DATABASE .
  pr MOVE-DOWN .
  pr FM-INST-EXPR-EVALUATION .
  pr FM-RENAMING-EXPR-EVALUATION .
  pr UNION-EXPR .
  pr N-TUPLE-EXPR .
  pr N-POWER-EXPR .
  pr DEFAULT-VALUE{Term} .
  pr META-FULL-MAUDE-SIGN .
  pr UNIT-BUBBLE-PARSING .

  vars PU U : Module .
  vars T T' T'' T''' T3 T4 : Term .
  vars QI QI' QI'' L F : Qid .
  vars QIL QIL' : QidList .
  vars S S' : Sort .
  vars SS SS' : TypeSet .
  vars TyL TyL' : TypeList .
  var  TSL : TypeSetList .
  var  AtS : AttrSet .
  vars TL TL' TL'' : TermList .
  var  Ct : Constant .
  var  VDS : VariableSet .
  vars Ty Tp : Type .
  var  N : Nat .
  var  DT : Default{Term} .

*** Similarly, auxiliary functions parsing other elements in units
*** are defined.

  op parsePreAttrs : Term Nat -> AttrSet .
  op parsePreHookList : Term -> HookList .
  op parseVars : QidList [Type] -> VariableSet .
  op parseSubsortRel : Term -> TypeListSet .
  op parseAttrDeclList : Term -> AttrDeclSet .

  eq parseSubsortRel('_<_[T, T'])
    = _l_(parseSortSet(T), parseSubsortRel(T')) .
  eq parseSubsortRel('__[T, T']) = parseSortSet('__[T, T']) .
  eq parseSubsortRel('sortToken[T]) = downQid(T) .
  eq parseSubsortRel('_`{_`}['sortToken[T], T'])
    = makeSort(downQid(T), parseParameterList(T')) .
  eq parseSubsortRel('_`{_`}['_`{_`}[T, T'], T''])
    = makeSort(parseSubsortRel('_`{_`}[T, T']), parseParameterList(T'')) .

  op unfoldOpDecl : QidList TypeList Sort AttrSet -> OpDeclSet .
  eq unfoldOpDecl((QI QIL), TyL, Ty, AtS)
    = ((op QI : TyL -> Ty [AtS] .) unfoldOpDecl(QIL, TyL, Ty, AtS)) .
  eq unfoldOpDecl(nil, TyL, Ty, AtS) = none .

  op unfoldMultipleMsgDecl : QidList TypeList Sort -> MsgDeclSet .
  eq unfoldMultipleMsgDecl((QI QIL), TyL, Ty)
    = ((msg QI : TyL -> Ty .) unfoldMultipleMsgDecl(QIL, TyL, Ty)) .
  eq unfoldMultipleMsgDecl(nil, TyL, Ty) = none .

  op unfoldSubsortRel : TypeSetList ~> SubsortDeclSet .
  eq unfoldSubsortRel(_l_((S ; SS), (S' ; SS'), TSL))
    = ((subsort S < S' .)
       unfoldSubsortRel(_l_(S, SS'))
       unfoldSubsortRel(_l_(SS, (S' ; SS')))
       unfoldSubsortRel(_l_((S' ; SS'), TSL))) .
  eq unfoldSubsortRel(_l_(SS, none)) = none .
  eq unfoldSubsortRel(_l_(none, SS)) = none .
  eq unfoldSubsortRel(SS) = none .
  eq unfoldSubsortRel(qidError(QIL)) = subsortDeclError(QIL) .

  op unfoldSubclassRel : TypeSetList ~> SubclassDeclSet .
  eq unfoldSubclassRel(_l_((S ; SS), (S' ; SS'), TSL))
    = ((subclass S < S' .)
       unfoldSubclassRel(_l_(S, SS'))
       unfoldSubclassRel(_l_(SS, (S' ; SS')))
       unfoldSubclassRel(_l_((S' ; SS'), TSL))) .
  eq unfoldSubclassRel(_l_(SS, none)) = none .
  eq unfoldSubclassRel(_l_(none, SS)) = none .
  eq unfoldSubclassRel(SS) = none .
  eq unfoldSubclassRel(qidError(QIL)) = subclassDeclError(QIL) .

  op unfoldStratDecl : QidList TypeList Sort AttrSet -> StratDeclSet .
  eq unfoldStratDecl((QI QIL), TyL, Ty, AtS)
    = ((strat QI : TyL @ Ty [AtS] .) unfoldStratDecl(QIL, TyL, Ty, AtS)) .
  eq unfoldStratDecl(nil, TyL, Ty, AtS) = none .

  eq parseVars((QI QIL), Tp)
    = (qid(string(QI) + ":" + string(Tp)) ; parseVars(QIL, Tp)) .
  eq parseVars(nil, Tp) = none .
  eq parseVars(QIL, qidError(QIL')) = variableSetError(QIL') .

  eq parsePreAttrs('__[T, T'], N)
    = (parsePreAttrs(T, N) parsePreAttrs(T', N)) .
  eq parsePreAttrs('assoc.@Attr@, N) = assoc .
  eq parsePreAttrs('associative.@Attr@, N) = assoc .
  eq parsePreAttrs('comm.@Attr@, N) = comm .
  eq parsePreAttrs('commutative.@Attr@, N) = comm .
  eq parsePreAttrs('idem.@Attr@, N) = idem .
  eq parsePreAttrs('idempotent.@Attr@, N) = idem .
  eq parsePreAttrs('id:_[T], N) = id(T) .
  eq parsePreAttrs('identity:_[T], N) = id(T) .
  eq parsePreAttrs('left`id:_[T], N) = left-id(T) .
  eq parsePreAttrs('left`identity:_[T], N) = left-id(T) .
  eq parsePreAttrs('right`id:_[T], N) = right-id(T) .
  eq parsePreAttrs('right`identity:_[T], N) = right-id(T) .
  eq parsePreAttrs('poly`(_`)[T], N) = poly(parseInt(T)) .
  eq parsePreAttrs('strat`(_`)[T], N) = strat(parseInt(T)) .
  eq parsePreAttrs('strategy`(_`)[T], N) = strat(parseInt(T)) .
  eq parsePreAttrs('frozen.@Attr@, N)
    = if N == 0
      then none
      else frozen(from 1 to N list)
      fi .
  eq parsePreAttrs('frozen`(_`)[T], N) = frozen(parseInt(T)) .
  eq parsePreAttrs('memo.@Attr@, N) = memo .
  eq parsePreAttrs('memoization.@Attr@, N) = memo .
  eq parsePreAttrs('ctor.@Attr@, N) = ctor .
  eq parsePreAttrs('constructor.@Attr@, N) = ctor .
  eq parsePreAttrs('prec_['token[T]], N) = prec(parseNat(T)) .
  eq parsePreAttrs('gather`(_`)['neTokenList[T]], N) = gather(downQidList(T)) .
  eq parsePreAttrs('special`(_`)[T], N) = special(parsePreHookList(T)) .
  eq parsePreAttrs('format`(_`)['neTokenList[T]], N) = format(downQidList(T)) .
  eq parsePreAttrs('iter.@Attr@, N) = iter .
  eq parsePreAttrs('ditto.@Attr@, N) = ditto .
  eq parsePreAttrs('config.@Attr@, N) = config .
  eq parsePreAttrs('object.@Attr@, N) = object .
  eq parsePreAttrs('msg.@Attr@, N) = msg .
  eq parsePreAttrs('message.@Attr@, N) = msg .
  eq parsePreAttrs('metadata_['token[T]], N) = metadata(downString(downQid(T))) .
  eq parsePreAttrs('nonexec.@Attr@, N) = nonexec .
  eq parsePreAttrs('variant.@Attr@, N) = variant .

  eq parsePreHookList('__[T, TL]) = parsePreHookList(T) parsePreHookList(TL) .
  eq parsePreHookList('id-hook_['token[T]]) = id-hook(downQid(T), nil) .
  eq parsePreHookList('id-hook_`(_`)['token[T], 'neTokenList[T']])
    = id-hook(downQid(T), downQidList(T')) .
  eq parsePreHookList(
       'op-hook_`(_:_->_`)[
          'token[T], 'token[T'], 'neTokenList[T''], 'token[T3]])
    = op-hook(downQid(T), downQid(T'), downTypes(T''), downQid(T3)) .
  eq parsePreHookList('op-hook_`(_:`->_`)['token[T], 'token[T'], 'token[T'']])
    = op-hook(downQid(T), downQid(T'), nil, downQid(T'')) .
  eq parsePreHookList(
       'op-hook_`(_:_~>_`)[
          'token[T], 'token[T'], 'neTokenList[T''], 'token[T3]])
    = op-hook(downQid(T), downQid(T'), downTypes(T''), downQid(T3)) .
  eq parsePreHookList('op-hook_`(_:`~>_`)['token[T], 'token[T'], 'token[T'']])
    = op-hook(downQid(T), downQid(T'), nil, downQid(T'')) .
  eq parsePreHookList('term-hook_`(_`)['token[T], T'])
    = term-hook(downQid(T), T') .

  eq parseAttrDeclList('_`,_[T, T'])
    = (parseAttrDeclList(T), parseAttrDeclList(T')) .
  eq parseAttrDeclList('_:_['token[T], T'])
    = (attr downQid(T) : parseType(T')) .

*** Given a term representing a declaration or a predeclaration, the function
*** \texttt{parseDecl} must generate and update both the unit and the preunit
*** that it takes as arguments. Note that in the case of rules, for example,
*** only a prerule is generated.

*** Since the preunit and the unit may be modified, they have to be returned as
*** a pair, which will be used to extract the corresponding arguments for the
*** following calls. Note that the \texttt{parseDecl} functions are in fact
*** partial functions. Each parsing function assumes that it is possible to
*** parse the given term.

  sort ParseDeclResult .
  op <_;_;_> : Module Module VariableSet -> ParseDeclResult .
  op preModule : ParseDeclResult -> Module .
  op unit : ParseDeclResult -> Module .
  op vars : ParseDeclResult -> VariableSet .

  eq preModule(< PU ; U ; VDS >) = PU .
  eq preModule(< unitError(QIL) ; V:[Module] ; V:[VariableSet] >) = unitError(QIL) .
  eq preModule(< V:[Module] ; unitError(QIL) ; V:[VariableSet] >) = unitError(QIL) .
  eq preModule(< V:[Module] ; V':[Module] ; variableSetError(QIL) >) = unitError(QIL) .
  eq unit(< PU ; U ; VDS >) = U .
  eq unit(< unitError(QIL) ; V':[Module] ; V:[VariableSet] >) = unitError(QIL) .
  eq unit(< V:[Module] ; unitError(QIL) ; V:[VariableSet] >) = unitError(QIL) .
  eq unit(< V:[Module] ; V':[Module] ; variableSetError(QIL) >) = unitError(QIL) .
  eq vars(< PU ; U ; VDS >) = VDS .
  eq vars(< unitError(QIL) ; V:[Module] ; V:[VariableSet] >) = variableSetError(QIL) .
  eq vars(< V:[Module] ; unitError(QIL) ; V:[VariableSet] >) = variableSetError(QIL) .
  eq vars(< V:[Module] ; V':[Module] ; variableSetError(QIL) >) = variableSetError(QIL) .

  op parseDecl : Term Module Module VariableSet -> ParseDeclResult .

*** changed 03/27/02
*** In the case of importation declarations, since internally only the
*** \texttt{including} mode is handled, all importations are generated in
*** this mode, independently of the keyword used in the input.

  eq parseDecl('inc_.[T], PU, U, VDS)
    = parseDecl('including_.[T], PU, U, VDS) .
  eq parseDecl('ex_.[T], PU, U, VDS)
    = parseDecl('extending_.[T], PU, U, VDS) .
  eq parseDecl('pr_.[T], PU, U, VDS)
    = parseDecl('protecting_.[T], PU, U, VDS) .
  eq parseDecl('including_.[T], PU, U, VDS)
    = < addImports((including parseModExp(T) .), PU) ; U ; VDS > .
  eq parseDecl('extending_.[T], PU, U, VDS)
    = < addImports((extending parseModExp(T) .), PU) ; U ; VDS > .
  eq parseDecl('protecting_.[T], PU, U, VDS)
    = < addImports((protecting parseModExp(T) .), PU) ; U ; VDS > .

  eq parseDecl('sort_.[T], PU, U, VDS) = parseDecl('sorts_.[T], PU, U, VDS) .
  eq parseDecl('sorts_.[T], PU, U, VDS)
    = < addSorts(parseSortSet(T), PU) ; addSorts(parseSortSet(T), U) ; VDS > .

  eq parseDecl('subsort_.[T], PU, U, VDS)
    = parseDecl('subsorts_.[T], PU, U, VDS) .
  eq parseDecl('subsorts_.[T], PU, U, VDS)
    = < addSubsorts(unfoldSubsortRel(parseSubsortRel(T)), PU) ;
        addSubsorts(unfoldSubsortRel(parseSubsortRel(T)), U) ; VDS > .

*** As pointed out in Section~\ref{SyntacticalRequirementsAndCaveats}, the
*** name of operators in operator declaration has to be given as a single
*** token identifier (see Section~\ref{order-sorted}). We assume that when
*** declaring a multitoken operator, its name is given as a single quoted
*** identifier in which each token is preceded by a backquote. Thus, the name
*** of an operator \verb~_(_)~, for example, is given as \verb~_`(_`)~.

  eq parseDecl('op_:`->_.['token[T], T'], PU, U, VDS)
    = < addOps((op downQid(T) : nil -> parseType(T') [none] .), PU) ;
        addOps((op downQid(T) : nil -> parseType(T') [none] .), U) ;
        VDS > .
  eq parseDecl('op_:`->_`[_`].['token[T], T', T''], PU, U, VDS)
    = < addOps(
          (op downQid(T) : nil -> parseType(T') [parsePreAttrs(T'', 0)] .),
          PU) ;
        addOps(
          (op downQid(T) : nil -> parseType(T') [parseAttrs(T'')] .),
          U) ;
        VDS > .
  eq parseDecl('op_:_->_.['token[T], T', T''], PU, U, VDS)
    = < addOps(
          (op downQid(T) : parseTypeList(T') -> parseType(T'') [none] .),
          PU) ;
        addOps(
          (op downQid(T) : parseTypeList(T') -> parseType(T'') [none] .),
          U) ;
        VDS > .
  eq parseDecl('op_:_->_`[_`].['token[T], T', T'', T3], PU, U, VDS)
    = < addOps(
          (op downQid(T) : parseTypeList(T') -> parseType(T'')
               [parsePreAttrs(T3, size(parseTypeList(T')))] .), PU) ;
        addOps(
          (op downQid(T) : parseTypeList(T') -> parseType(T'')
               [parseAttrs(T3)] .), U) ;
        VDS > .

  ceq parseDecl('op_:`->_.[F[TL], T], PU, U, VDS)
    = < PU ; U ; VDS >
    if F =/= 'token .
  ceq parseDecl('op_:`->_`[_`].[F[TL], T, T'], PU, U, VDS)
    = < PU ; U ; VDS >
    if F =/= 'token .
  ceq parseDecl('op_:_->_.[F[TL], T, T'], PU, U, VDS)
    = < PU ; U ; VDS >
    if F =/= 'token .
  ceq parseDecl('op_:_->_`[_`].[F[TL], T, T', T''], PU, U, VDS)
    = < PU ; U ; VDS >
    if F =/= 'token .

  eq parseDecl('ops_:`->_.['neTokenList[T], T'], PU, U, VDS)
    = < addOps(
          unfoldOpDecl(downTypes(T), nil, parseType(T'), none), PU) ;
        addOps(
          unfoldOpDecl(downTypes(T), nil, parseType(T'), none), U) ;
        VDS > .
  eq parseDecl('ops_:`->_`[_`].['neTokenList[T], T', T''], PU, U, VDS)
    = < addOps(
          unfoldOpDecl(downTypes(T), nil, parseType(T'),
            parsePreAttrs(T'', 0)),
          PU) ;
        addOps(
          unfoldOpDecl(downTypes(T), nil, parseType(T'),
            parseAttrs(T'')),
          U) ;
        VDS > .
  eq parseDecl('ops_:_->_.['neTokenList[T], T', T''], PU, U, VDS)
    = < addOps(
          unfoldOpDecl(downTypes(T), parseTypeList(T'),
            parseType(T''), none),
          PU) ;
        addOps(
          unfoldOpDecl(downTypes(T), parseTypeList(T'),
            parseType(T''), none),
          U) ;
        VDS > .
  eq parseDecl('ops_:_->_`[_`].['neTokenList[T], T', T'', T3], PU, U, VDS)
    = < addOps(
          unfoldOpDecl(downTypes(T), parseTypeList(T'), parseType(T''),
            parsePreAttrs(T3, size(parseTypeList(T')))), PU) ;
        addOps(
          unfoldOpDecl(downTypes(T),
            parseTypeList(T'), parseType(T''), parseAttrs(T3)), U) ;
        VDS > .

  eq parseDecl('op_:`~>_.['token[T], T'], PU, U, VDS)
    = < addOps((op downQid(T) : nil -> kind(parseType(T')) [none] .), PU) ;
        addOps((op downQid(T) : nil -> kind(parseType(T')) [none] .), U) ;
        VDS > .
  eq parseDecl('op_:`~>_`[_`].['token[T], T', T''], PU, U, VDS)
    = < addOps((op downQid(T) : nil -> kind(parseType(T'))
                    [parsePreAttrs(T'', 0)] .), PU) ;
        addOps((op downQid(T) : nil -> kind(parseType(T'))
                    [parseAttrs(T'')] .), U) ;
        VDS > .
  eq parseDecl('op_:_~>_.['token[T], T', T''], PU, U, VDS)
    = < addOps((op downQid(T) : kind(parseTypeList(T')) -> kind(parseType(T''))
                    [none] .), PU) ;
        addOps((op downQid(T) : kind(parseTypeList(T')) -> kind(parseType(T''))
                    [none] .), U) ;
        VDS > .
  eq parseDecl('op_:_~>_`[_`].['token[T], T', T'', T3], PU, U, VDS)
    = < addOps((op downQid(T) : kind(parseTypeList(T')) -> kind(parseType(T''))
                   [parsePreAttrs(T3, size(parseTypeList(T')))] .), PU) ;
        addOps((op downQid(T) : kind(parseTypeList(T')) -> kind(parseType(T''))
                   [parseAttrs(T3)] .), U) ;
        VDS > .

  ceq parseDecl('op_:`~>_.[F[TL], T], PU, U, VDS)
    = < PU ; U ; VDS >
    if F =/= 'token .
  ceq parseDecl('op_:`~>_`[_`].[F[TL], T, T'], PU, U, VDS)
    = < PU ; U ; VDS >
    if F =/= 'token .
  ceq parseDecl('op_:_~>_.[F[TL], T, T'], PU, U, VDS)
    = < PU ; U ; VDS >
    if F =/= 'token .
  ceq parseDecl('op_:_~>_`[_`].[F[TL], T, T', T''], PU, U, VDS)
    = < PU ; U ; VDS >
    if F =/= 'token .

  eq parseDecl('ops_:`~>_.['neTokenList[T], T'], PU, U, VDS)
    = < addOps(
          unfoldOpDecl(downTypes(T), nil, kind(parseType(T')), none),
          PU) ;
        addOps(
          unfoldOpDecl(downTypes(T), nil, kind(parseType(T')), none),
          U) ;
        VDS > .
  eq parseDecl('ops_:`~>_`[_`].['neTokenList[T], T', T''], PU, U, VDS)
    = < addOps(
          unfoldOpDecl(downTypes(T), nil, kind(parseType(T')),
            parsePreAttrs(T'', 0)),
          PU) ;
        addOps(
          unfoldOpDecl(downTypes(T), nil, kind(parseType(T')),
            parseAttrs(T'')), U) ;
        VDS > .
  eq parseDecl('ops_:_~>_.['neTokenList[T], T', T''], PU, U, VDS)
    = < addOps(
          unfoldOpDecl(downTypes(T), parseTypeList(T'),
            kind(parseType(T'')), none),
          PU) ;
        addOps(
          unfoldOpDecl(downTypes(T), parseTypeList(T'),
            kind(parseType(T'')), none),
          U) ;
        VDS > .
  eq parseDecl('ops_:_~>_`[_`].['neTokenList[T], T', T'', T3], PU,
       U, VDS)
    = < addOps(
          unfoldOpDecl(downTypes(T), parseTypeList(T'), parseType(T''),
            parsePreAttrs(T3, size(parseTypeList(T')))),
          PU) ;
        addOps(
          unfoldOpDecl(downTypes(T),
            parseTypeList(T'), parseType(T''), parseAttrs(T3)), U) ;
        VDS > .

  eq parseDecl('var_:_.['neTokenList[T], T'], PU, U, VDS)
    = parseDecl('vars_:_.['neTokenList[T], T'], PU, U, VDS) .
  eq parseDecl('vars_:_.['neTokenList[T], T'], PU, U, VDS)
    = < PU ; U ; (VDS ; parseVars(downQidList(T), parseType(T'))) > .

  eq parseDecl('mb_:_.['rbubble[T], 'rbubble[T']], PU, U, VDS)
    = < addMbs((mb T : getSort(breakMb(T', VDS)) [getAttrSet(breakMb(T', VDS))] .), PU) ; U ; VDS > .
  eq parseDecl('cmb_:_if_.['rbubble[T], T', 'rbubble[T'']], PU, U, VDS)
    = < addMbs(
          (cmb T : parseType(T')
             if term(pullStmtAttrOut(T'', VDS)) = 'true.Bool
             [attrSet(pullStmtAttrOut(T'', VDS))] .), PU) ; U ; VDS > .

  op breakMb : Term VariableSet -> [Tuple{Sort,AttrSet}] .
  op breakMbAux : TermList AttrSet VariableSet -> [Tuple{Sort,AttrSet}] .

  pr (2TUPLE * (op `(_`,_`) to <_`,_>, op p1_ to getSort, op p2_ to getAttrSet)) {Sort,AttrSet} .

  eq breakMb('__[TL, QI], VDS)
    = if QI == ''`].Qid
      then breakMbAux(TL, none, VDS)
      else < parseType(getTerm(metaParse(GRAMMAR, none, downQidList('__[TL, QI]), '@Sort@))), none >
      fi .
----  eq breakMb('sortToken[T], VDS) = < parseType('sortToken[T]), none > [owise] .
----  eq breakMb('_`{_`}[T, T'], VDS) = < parseType('_`{_`}[T, T']), none > [owise] .
  eq breakMb(QI, VDS) = < downQid(QI), none > [owise] .

  eq breakMbAux((TL, ''`[.Qid), AtS, VDS)
    = < parseType(getTerm(metaParse(GRAMMAR, VDS, downQidList('__[TL]), '@Sort@))), AtS > .
  eq breakMbAux((TL, QI, ''nonexec.Qid), AtS, VDS)
    = breakMbAux((TL, QI), AtS nonexec, VDS) .
  eq breakMbAux((TL, QI, ''variant.Qid), AtS, VDS)
    = breakMbAux((TL, QI), AtS variant, VDS) .
  eq breakMbAux((TL, QI, ''owise.Qid), AtS, VDS)
    = breakMbAux((TL, QI), AtS owise, VDS) .
  eq breakMbAux((TL, QI, ''otherwise.Qid), AtS, VDS)
    = breakMbAux((TL, QI), AtS owise, VDS) .
  eq breakMbAux((TL, QI, ''label.Qid, QI'), AtS, VDS)
    = if downQid(QI') :: Qid
      then breakMbAux((TL, QI), AtS label(downQid(QI')), VDS)
      else < qidError('Error: 'Invalid 'label), none >
      fi .
  eq breakMbAux((TL, QI, ''metadata.Qid, QI'), AtS, VDS)
    = if downString(downQid(QI')) :: String
      then breakMbAux((TL, QI), AtS metadata(downString(downQid(QI'))), VDS)
      else < qidError('Error: 'Invalid 'metadata), none >
      fi .
  ceq breakMbAux((TL, QI, ''`[.Qid, TL', ''print.Qid, TL''), AtS, VDS)
    = breakMbAux((TL, QI, ''`[.Qid, TL'), AtS print(printArg(TL'', VDS)), VDS)
    if printArg(TL'', VDS) : QidList .
  eq breakMbAux(TL, AtS, VDS) = < qidError('Error: 'Invalid 'sort), none > [owise] .

  op breakTermSort : Term ~> ResultPair .
  eq breakTermSort('_:_[T, T']) = {T, parseType(T')} .

  eq parseDecl('eq_=_.[T, T'], PU, U, VDS)
    = < addEqs((eq T = T' [none] .), PU) ; U ; VDS > .
  eq parseDecl('ceq_=_if_.[T, T', T''], PU, U, VDS)
    = < addEqs((ceq T = T' if T'' = 'true.Bool [none] .), PU) ; U ; VDS > .
  eq parseDecl('cq_=_if_.[T, T', T''], PU, U, VDS)
    = < addEqs((ceq T = T' if T'' = 'true.Bool [none] .), PU) ; U ; VDS > .

  eq parseDecl('rl_=>_.[T, T'], PU, U, VDS)
    = < addRls((rl T => T' [none] .), PU) ; U ; VDS > .
  eq parseDecl('crl_=>_if_.[T, T', T''], PU, U, VDS)
    = < addRls((crl T => T' if T'' = 'true.Bool [none] .), PU) ; U ; VDS > .

  eq parseDecl('class_|`.[T], PU, U, VDS)
    = parseDecl('class_.[T], PU, U, VDS) .
  eq parseDecl('class_.[T], PU, U, VDS)
    = < addClasses((class parseType(T) | none .), PU) ;
        addClasses((class parseType(T) | none .), U) ; VDS > .
  eq parseDecl('class_|_.[T, T'], PU, U, VDS)
    = < addClasses((class parseType(T) | parseAttrDeclList(T') .), PU) ;
        addClasses((class parseType(T) | parseAttrDeclList(T') .), U) ; VDS > .

  eq parseDecl('subclass_.[T], PU, U, VDS)
    = < addSubclasses(unfoldSubclassRel(parseSubsortRel(T)), PU) ;
        addSubclasses(unfoldSubclassRel(parseSubsortRel(T)), U) ; VDS > .
  eq parseDecl('subclasses_.[T], PU, U, VDS)
    = < addSubclasses(unfoldSubclassRel(parseSubsortRel(T)), PU) ;
        addSubclasses(unfoldSubclassRel(parseSubsortRel(T)), U) ; VDS > .

  eq parseDecl('msg_:_->_.['token[T], T', T''], PU, U, VDS)
    = < addMsgs((msg downQid(T) : parseTypeList(T') -> parseType(T'') .), PU)
        ;
        addMsgs((msg downQid(T) : parseTypeList(T') -> parseType(T'') .), U)
        ;
        VDS > .
  eq parseDecl('msg_:`->_.['token[T], T'], PU, U, VDS)
    = < addMsgs((msg downQid(T) : nil -> parseType(T') .), PU) ;
        addMsgs((msg downQid(T) : nil -> parseType(T') .), U) ; VDS > .
  eq parseDecl('msgs_:_->_.['neTokenList[T], T', T''], PU, U, VDS)
    = < addMsgs(unfoldMultipleMsgDecl(downQidList(T), parseTypeList(T'), parseType(T'')), PU) ;
        addMsgs(unfoldMultipleMsgDecl(downQidList(T), parseTypeList(T'), parseType(T'')), U) ;
        VDS > .
  eq parseDecl('msgs_:`->_.['neTokenList[T], T'], PU, U, VDS)
    = < addMsgs(unfoldMultipleMsgDecl(downQidList(T), nil, parseType(T')), PU) ;
        addMsgs(unfoldMultipleMsgDecl(downQidList(T), nil, parseType(T')), U) ; VDS > .

  eq parseDecl('strat_@_.['token[T], T'], PU, U, VDS)
    = < addStratDcls(strat downQid(T) : nil @ parseType(T') [none] ., PU) ;
        U ; ---- addOps(op downQid(T) : nil -> '@CallStrategy@ [none] ., U) ;
        VDS > .
  eq parseDecl('strat_:`@_`[_`].['token[T], T', T''], PU, U, VDS)
    = < addStratDcls(strat downQid(T) : nil @ parseType(T') [parseAttrs(T'')] ., PU) ;
        U ; ---- addOps(op downQid(T) : nil -> '@CallStrategy@ [parsePreAttrs(T'', 0)] ., U) ;
        VDS > .
  eq parseDecl('strat_:_@_.['token[T], T', T''], PU, U, VDS)
    = < addStratDcls(strat downQid(T) : parseTypeList(T') @ parseType(T'') [none] ., PU) ;
        U ; ---- addOps(op downQid(T) : parseTypeList(T') -> '@CallStrategy@ [none] ., U) ;
        VDS > .
  eq parseDecl('strat_:_@_`[_`].['token[T], T', T'', T3], PU, U, VDS)
    = < addStratDcls(strat downQid(T) : parseTypeList(T') @ parseType(T'') [parseAttrs(T3)] ., PU) ;
        U ; ---- addOps(op downQid(T) : parseTypeList(T') -> '@CallStrategy@ [parsePreAttrs(T3, size(parseTypeList(T')))] ., U) ;
        VDS > .
  ceq parseDecl('strat_:`@_.[F[TL], T], PU, U, VDS)
    = < PU ; U ; VDS >
    if F =/= 'token .
  ceq parseDecl('strat_:`@_`[_`].[F[TL], T, T'], PU, U, VDS)
    = < PU ; U ; VDS >
    if F =/= 'token .
  ceq parseDecl('strat_:_@_.[F[TL], T, T'], PU, U, VDS)
    = < PU ; U ; VDS >
    if F =/= 'token .
  ceq parseDecl('op_:_@_`[_`].[F[TL], T, T', T''], PU, U, VDS)
    = < PU ; U ; VDS >
    if F =/= 'token .

  eq parseDecl('strats_@_.['neTokenList[T], T'], PU, U, VDS)
    = < addStratDcls(unfoldStratDecl(downTypes(T), nil, parseType(T'), none), PU) ;
        U ; ---- addOps(unfoldOpDecl(downTypes(T), nil, '@CallStrategy@, none), U) ;
        VDS > .
  eq parseDecl('strats_@_`[_`].['neTokenList[T], T', T''], PU, U, VDS)
    = < addStratDcls(unfoldStratDecl(downTypes(T), nil, parseType(T'), parseAttrs(T'')), PU) ;
        U ; ---- addOps(unfoldOpDecl(downTypes(T), nil, '@CallStrategy@, parsePreAttrs(T'', 0)), U) ;
        VDS > .
  eq parseDecl('strats_:_@_.['neTokenList[T], T', T''], PU, U, VDS)
    = < addStratDcls(unfoldStratDecl(downTypes(T), parseTypeList(T'), parseType(T''), none), PU) ;
        U ; ---- addOps(unfoldOpDecl(downTypes(T), parseTypeList(T'), '@CallStrategy@, none), U) ;
        VDS > .
  eq parseDecl('strats_:_@_`[_`].['neTokenList[T], T', T'', T3], PU, U, VDS)
    = < addStratDcls(unfoldStratDecl(downTypes(T), parseTypeList(T'), parseType(T''), parseAttrs(T3)), PU) ;
        U ; ---- addOps(
            ----   unfoldOpDecl(downTypes(T), parseTypeList(T'), '@CallStrategy@, parsePreAttrs(T3, size(parseTypeList(T')))), U) ;
        VDS > .

  eq parseDecl('sd_:=_.[T, T'], PU, U, VDS)
    = < addStratDefs(sd T := T' [none] ., PU) ; U ; VDS > .
  eq parseDecl('csd_:=_if_.[T, T', T''], PU, U, VDS)
    = < addStratDefs(csd T := T' if T'' = 'true.Bool [none] ., PU) ; U ; VDS > .
endfm

*******************************************************************************

***
*** 8.1.2 Parsing of View Declarations
***

*** A similar approach is followed for the parsing of declarations in views.

fmod VIEW-DECL-PARSING is
  pr PRE-VIEW .
  pr VIEW .
  pr FM-UNIT .
  pr UNIT-DECL-PARSING .

  vars T T' : Term .
  var  OPDS : OpDeclSet .
  var  MDS : MsgDeclSet .
  var  M : Module .
  vars F F' : Qid .
  vars S S' : Sort .
  vars Ty Ty' : Type .
  vars TyL TyL' : TypeList .
  vars T'' T3 : Term .
  var  PV : PreView .
  var  OPD : OpDecl .
  var  OPDS' : OpDeclSet .
  var  AtS : AttrSet .
  var  MD : MsgDecl .
  var  MDS' : MsgDeclSet .
  var  VDS : OpDeclSet .
  vars StratDcls StratDcls' : StratDeclSet .
  var  StratDcl : StratDecl .

*** Operator and message name maps of the form \verb~F to F'~ are substituted
*** by an equivalent set of maps of the form \verb~F : TyL -> S to F'~. One
*** of these maps is added for each family of subsort-overloaded operators in
*** the source theory of the view.

*** The following functions \texttt{genOpMaps} and \texttt{genMsgMaps}
*** take, respectively, an operator and a message map of the form
*** \verb~F to F'~, a set of operator or message declarations, and a term of
*** sort \texttt{Module}, and return, respectively, a set of operator maps and
*** a set of message maps, with each of the members of those sTS having the
*** general form \verb~F : TyL -> S to F'~. One of these maps is generated
*** for each family of subsort-overloaded operators or messages with name
*** \texttt{F} in the module given as argument.

  op genOpMaps : OpMapping OpDeclSet Module -> OpMappingSet .
  op genMsgMaps : OpMapping MsgDeclSet Module -> OpMappingSet .
  op genStratMaps : StratMapping StratDeclSet Module -> StratMappingSet .

  op genOpMapsAux : OpDeclSet Qid -> OpMappingSet .
  op genMsgMapsAux : MsgDeclSet Qid -> OpMappingSet .
  op genStratMapsAux : StratDeclSet Qid -> StratMappingSet .

  op getOpDeclSet : Qid Module -> OpDeclSet .
  op getOpDeclSetAux : Qid OpDeclSet -> OpDeclSet .
  *** getOpDeclSet(F, U) returns the set of declarations of operators with
  *** name F in the unit U
  op getMsgDeclSet : Qid Module -> MsgDeclSet .
  op getMsgDeclSetAux : Qid MsgDeclSet -> MsgDeclSet .
  *** getMsgDeclSet(F, U) returns the set of declarations of messages with
  *** name F in the unit U
  op getStratDeclSet : Qid Module -> StratDeclSet .
  op getStratDeclSetAux : Qid StratDeclSet -> StratDeclSet .
  *** getMsgDeclSet(F, U) returns the set of declarations of messages with
  *** name F in the unit U
  op gTSubsortOverloadedFamilies : OpDeclSet OpDeclSet Module -> OpDeclSet .
  op gTSubsortOverloadedFamilies : MsgDeclSet MsgDeclSet Module -> MsgDeclSet .
  op gTSubsortOverloadedFamilies : StratDeclSet StratDeclSet Module -> StratDeclSet .
  *** gTSubsortOverloadedFamilies returns a declaration of operator or
  *** message for each family of subsort-overloaded operators or messages.
  op selectOpDeclSet : Qid OpDeclSet -> OpDeclSet .
  op selectMsgDeclSet : Qid MsgDeclSet -> MsgDeclSet .
  op selectStratDeclSet : Qid StratDeclSet -> StratDeclSet .
  *** selectOpDeclSet and selectMsgDeclSet returns, respectively, the subset
  *** of those declarations  of ops and msgs which name coincides with the
  *** qid given ar argument.
  op opFamilyIn : OpDecl OpDeclSet Module -> Bool .
  op msgFamilyIn : MsgDecl MsgDeclSet Module -> Bool .
  op stratFamilyIn : StratDecl StratDeclSet Module -> Bool .
  *** Check whether the family of the subsort-overloaded operator given as
  *** argument has already a  representative in the set of declarations given.

  eq genOpMaps(op F to F' ., OPDS, M)
    = genOpMapsAux(
         gTSubsortOverloadedFamilies(selectOpDeclSet(F, OPDS), none, M),
         F') .
  eq genMsgMaps(msg F to F' ., MDS, M)
    = genMsgMapsAux(
         gTSubsortOverloadedFamilies(selectMsgDeclSet(F, MDS), none, M),
         F') .
  eq genStratMaps(strat F to F' ., StratDcls, M)
    = genStratMapsAux(
        gTSubsortOverloadedFamilies(selectStratDeclSet(F, StratDcls), none, M),
        F') .

  eq selectOpDeclSet(F, ((op F' : TyL -> Ty [AtS] .) OPDS))
    = ((if F == F'
        then (op F' : TyL -> Ty [AtS] .)
        else none
        fi)
       selectOpDeclSet(F, OPDS)) .
  eq selectOpDeclSet(F, none) = none .

  eq selectMsgDeclSet(F, ((msg F' : TyL -> Ty .) MDS))
    = ((if F == F'
        then (msg F' : TyL -> Ty .)
        else none
        fi)
       selectMsgDeclSet(F, MDS)) .
  eq selectMsgDeclSet(F, none) = none .

  eq selectStratDeclSet(F, ((strat F' : TyL @ Ty [AtS] .) StratDcls))
    = ((if F == F'
        then (strat F' : TyL @ Ty [AtS] .)
        else none
        fi)
       selectStratDeclSet(F, StratDcls)) .
  eq selectStratDeclSet(F, none) = none .

  eq genOpMapsAux(op F : TyL -> Ty [AtS] . OPDS, F')
    = (op F : TyL -> Ty to F' . genOpMapsAux(OPDS, F')) .
  eq genOpMapsAux(none, F') = none .

  eq genMsgMapsAux(((msg F : TyL -> Ty .) MDS), F')
    = (msg F : TyL -> Ty to F' . genMsgMapsAux(MDS, F')) .
  eq genMsgMapsAux(none, F') = none .

  eq genStratMapsAux(strat F : TyL @ Ty [AtS] . StratDcls, F')
    = (strat F : TyL @ Ty to F' . genStratMapsAux(StratDcls, F')) .
  eq genStratMapsAux(none, F') = none .

  eq gTSubsortOverloadedFamilies((OPD OPDS), OPDS', M)
    = if opFamilyIn(OPD, OPDS', M)
      then gTSubsortOverloadedFamilies(OPDS, OPDS', M)
      else gTSubsortOverloadedFamilies(OPDS, (OPD OPDS'), M)
      fi .
  eq gTSubsortOverloadedFamilies(none, OPDS, M) = OPDS .

  eq gTSubsortOverloadedFamilies((MD MDS), MDS', M)
    = if msgFamilyIn(MD, MDS', M)
      then gTSubsortOverloadedFamilies(MDS, MDS', M)
      else gTSubsortOverloadedFamilies(MDS, (MD MDS'), M)
      fi .
  eq gTSubsortOverloadedFamilies(none, MDS, M) = MDS .

  eq gTSubsortOverloadedFamilies((StratDcl StratDcls), StratDcls', M)
    = if stratFamilyIn(StratDcl, StratDcls', M)
      then gTSubsortOverloadedFamilies(StratDcls, StratDcls', M)
      else gTSubsortOverloadedFamilies(StratDcls, (StratDcl StratDcls'), M)
      fi .
  eq gTSubsortOverloadedFamilies(none, StratDcls, M) = StratDcls .

  eq opFamilyIn(
       (op F : TyL -> Ty [AtS] .), ((op F' : TyL' -> Ty' [AtS] .) OPDS), M)
    = ((F == F') and-then sameKind(M, TyL, TyL')) or-else
      opFamilyIn((op F : TyL -> Ty [AtS] .), OPDS, M) .
  eq opFamilyIn((op F : TyL -> Ty [AtS] .), none, M) = false .

  eq msgFamilyIn((msg F : TyL -> Ty .), ((msg F' : TyL' -> Ty' .) MDS), M)
    = ((F == F') and-then sameKind(M, TyL, TyL'))
      or-else
      msgFamilyIn((msg F : TyL -> Ty .), MDS, M) .
  eq msgFamilyIn((msg F : TyL -> Ty .), none, M) = false .

  eq stratFamilyIn(
       (strat F : TyL @ Ty [AtS] .), ((strat F' : TyL' @ Ty' [AtS] .) StratDcls), M)
    = ((F == F') and-then sameKind(M, TyL, TyL')) or-else
      stratFamilyIn((strat F : TyL @ Ty [AtS] .), StratDcls, M) .
  eq stratFamilyIn((strat F : TyL @ Ty [AtS] .), none, M) = false .

*** In the case of views, the \texttt{parseDecl} function takes the term
*** representing the corresponding declaration and a preview in which the
*** declarations are introduced. Note that in the case of views, the approach
*** followed in the evaluation is somewhat different. The only predeclarations
*** in a preview correspond to the term premaps of sort \texttt{PreTermMap},
*** for which, in addition to solving the bubbles in them, we have to convert
*** them into term maps of sort \texttt{TermMap} associating to them the set
*** of declarations of variables in the view which are used in them (see
*** Section~\ref{view-processing}).

*** The function \texttt{parseDecl} for declarations in views takes then the
*** term representing such declaration and a preview in which the result of
*** adding the declaration will be returned. To be able to generate the sTS
*** of equivalent operator and message maps as indicated above, the function
*** takes also as parameters the sTS of declarations of operators and messages
*** in the theory part of the source theory of the view in question, and the
*** signature of such theory to make the necessary sort comparisons.

  op parseDecl : Term PreView OpDeclSet MsgDeclSet StratDeclSet Module -> PreView .

  eq parseDecl('sort_to_.[T, T'], PV, OPDS, MDS, StratDcls, M)
    = addMaps(sort parseType(T) to parseType(T') ., PV) .

  eq parseDecl('class_to_.[T, T'], PV, OPDS, MDS, StratDcls, M)
    = addMaps(class parseType(T) to parseType(T') ., PV) .

  eq parseDecl('vars_:_.['neTokenList[T], T'], PV, OPDS, MDS, StratDcls, M)
    = addVars(parseVars(downQidList(T), parseType(T')), PV).
  eq parseDecl('var_:_.['neTokenList[T], T'], PV, OPDS, MDS, StratDcls, M)
    = addVars(parseVars(downQidList(T), parseType(T')), PV).

  eq parseDecl('op_to`term_.[T, T'], PV, OPDS, MDS, StratDcls, M)
    = addMaps(op_to`term_.(T, T'), PV) .

  eq parseDecl('op_to_.['token[T], 'token[T']], PV, OPDS, MDS, StratDcls, M)
    = addMaps(genOpMaps(op downQid(T) to downQid(T') ., OPDS, M), PV) .
  eq parseDecl('op_:_->_to_.['token[T], T', T'', 'token[T3]], PV, OPDS, MDS, StratDcls, M)
    = addMaps(op downQid(T) : parseTypeList(T') -> parseType(T'') to downQid(T3) ., PV) .
----  eq parseDecl('op_:`->_to_.['token[T], T', 'token[T'']], PV, OPDS, MDS, StratDcls, M)
----    = addMaps(op downQid(T) : nil -> parseType(T') to downQid(T'') ., PV) .

  eq parseDecl('msg_to_.['token[T], 'token[T']], PV, OPDS, MDS, StratDcls, M)
    = addMaps(genMsgMaps(msg downQid(T) to downQid(T') ., MDS, M), PV) .
  eq parseDecl('msg_:_->_to_.['token[T], T', T'', 'token[T3]], PV, OPDS, MDS, StratDcls, M)
    = addMaps(msg downQid(T) : parseTypeList(T') -> parseType(T'') to downQid(T3) ., PV) .
----  eq parseDecl('msg_:`->_to_.['token[T], T', 'token[T'']], PV, OPDS, MDS, StratDcls, M)
----    = addMaps(msg downQid(T) : nil -> parseType(T') to downQid(T'') ., PV) .

  eq parseDecl('attr_._to_.[T', 'token[T], 'token[T'']], PV, OPDS, MDS, StratDcls, M)
    = addMaps(attr downQid(T) . parseType(T') to downQid(T'') ., PV) .

  eq parseDecl('strat_to`expr_.[T, T'], PV, OPDS, MDS, StratDcls, M)
    = addMaps(strat_to`expr_.(T, T'), PV) .

  eq parseDecl('strat_to_.['token[T], 'token[T']], PV, OPDS, MDS, StratDcls, M)
    = addMaps(genStratMaps(strat downQid(T) to downQid(T') ., StratDcls, M), PV) .
  eq parseDecl('strat_:_@_to_.['token[T], T', T'', 'token[T3]], PV, OPDS, MDS, StratDcls, M)
    = addMaps(strat downQid(T) : parseTypeList(T') @ parseType(T'') to downQid(T3) ., PV) .

  eq parseDecl(T, PV, OPDS, MDS, StratDcls, M) = PV [owise] .
endfm

*******************************************************************************

***
*** 8.2 Meta Pretty Printing
***

*** To be able to show to the user the modules, theories, views, and terms
*** resulting from the different commands, the built-in function
*** \texttt{meta-pretty-print} is extended in the modules in this section to
*** deal with units and views.

***
*** 8.2.1 Meta Pretty Printing of Declarations
***

*** The predefined function \texttt{meta-pretty-print} is extended in the
*** following module \texttt{DECL-META-PRETTY-PRINT} to handle any declaration
*** that can appear in a unit. Note that the following
*** \texttt{meta-pretty-print} functions, as the built-in one, return a list
*** terms---such as equations, rules,* operator declarations with an identity
*** attribute, etc.---they have been defined with a term of operator
*** declarations with an identity attribute, etc.---they have been defined
*** with a term of sort \texttt{Module} as argument. In the other cases the
*** module is not necessary.

fmod DECL-META-PRETTY-PRINT is
  pr FM-EXT-DECL .
  pr FM-O-O-DECL .
  pr FM-UNIT .
  pr CONVERSION .
  pr FM-INT-LIST .
  pr FM-VIEW-EXPR-TO-QID .
  pr META-LEVEL .

  op metaPrettyPrintStrategy : Module Strategy ~> QidList .
  op metaPrettyPrintStrategy : Module Strategy PrintOptionSet ~> QidList .
  eq metaPrettyPrintStrategy(M:Module, Strat:Strategy)
   = metaPrettyPrintStrategy(M:Module, Strat:Strategy, mixfix flat format number rat) .
  eq metaPrettyPrintStrategy(M:Module, Strat:Strategy, POs:PrintOptionSet)
   = metaPrettyPrintStrategy(M:Module, none, Strat:Strategy, POs:PrintOptionSet) .

  eq metaPrettyPrint(
       smod ME is IL sorts SS . SSDS OPDS MAS EqS RlS StratDcls StratDefs endsm,
       T,
       POs:PrintOptionSet)
   = metaPrettyPrint(
       mod ME is IL sorts SS . SSDS OPDS MAS EqS RlS endm,
       T,
       POs:PrintOptionSet) .

  op eMetaPrettyPrint : Sort -> QidList .
  op eMetaPrettyPrint : SortSet -> QidList .
  op eMetaPrettyPrint : TypeList -> QidList .
  op eMetaPrettyPrint : SubsortDeclSet -> QidList .
  op eMetaPrettyPrint : ClassDeclSet -> QidList .
  op eMetaPrettyPrint : SubclassDeclSet -> QidList .
  op eMetaPrettyPrint : Module OpDeclSet -> QidList .
  op eMetaPrettyPrintVars : VariableSet -> QidList .
  op eMetaPrettyPrint : MsgDeclSet -> QidList .
  op eMetaPrettyPrint : Module MembAxSet -> QidList .
  op eMetaPrettyPrint : Module EquationSet -> QidList .
  op eMetaPrettyPrint : Module RuleSet -> QidList .
  op eMetaPrettyPrint : Module StratDeclSet -> QidList .
  op eMetaPrettyPrint : Module StratDefSet -> QidList .
  op eMetaPrettyPrint : Module Condition -> QidList .
  op eMetaPrettyPrint : Module Term -> QidList .

  ---- error handling

  eq eMetaPrettyPrint(U, T) = metaPrettyPrint(U, T) .
  eq eMetaPrettyPrint(U, qidError(QIL)) = QIL .
  eq eMetaPrettyPrint(qidError(QIL)) = QIL .

  op eMetaPrettyPrint : Module AttrSet -> QidList .
  op eMetaPrettyPrint : IntList -> QidList .
  op eMetaPrettyPrint : AttrDeclSet -> QidList .
  op eMetaPrettyPrint : Module HookList -> QidList .

  vars QI QI' QI'' F V L : Qid .
  var  QIL : QidList .
  var  St : String .
  var  M : Module .
  var  U : Module .
  vars VE VE' : ViewExpression .
  vars SS : SortSet .
  vars S S' : Sort .
  var  TyL : TypeList .
  var  Ty : Type .
  var  SSDS : SubsortDeclSet .
  var  OPDS : OpDeclSet .
  var  AtS : AttrSet .
  var  MAS : MembAxSet .
  var  EqS : EquationSet .
  var  RlS : RuleSet .
  var  Hk : Hook .
  var  HkL : HookList .
  var  I : Int .
  var  NL : IntList .
  vars T T' T'' T3 : Term .
  var  CDS : ClassDeclSet .
  var  SCDS : SubclassDeclSet .
  var  MDS : MsgDeclSet .
  var  ADS : AttrDeclSet .
  var  Cond : Condition .
  var  K : Kind .
  var  StratDcls : StratDeclSet .
  var  StratDefs : StratDefSet .
  var  CS : CallStrategy .
  var  Strat : Strategy .
  var  TL : TermList .
  var  ME : ModuleExpression .
  var  IL : ImportList .
  var  VDS : VariableSet .

  --- eq eMetaPrettyPrint(Ty) = Ty .

  eq eMetaPrettyPrint(S)
    = if getPars(S) == empty
      then S
      else getName(S) '`{ parameterList2QidList(getPars(S)) '`}
      fi .
  eq eMetaPrettyPrint(K) = '`[ eMetaPrettyPrint(getSort(K)) '`] .

  eq eMetaPrettyPrint((S ; SS))
    = (eMetaPrettyPrint(S) eMetaPrettyPrint(SS))
    [owise] .
  eq eMetaPrettyPrint((none).SortSet) = nil .

  eq eMetaPrettyPrint(Ty TyL)
    = eMetaPrettyPrint(Ty) eMetaPrettyPrint(TyL)
    [owise] .
  eq eMetaPrettyPrint((nil).TypeList) = nil .

  eq eMetaPrettyPrint(((subsort S < S' .) SSDS))
    = ('\s '\s '\b
       'subsort '\o eMetaPrettyPrint(S) '\b
           '< '\o eMetaPrettyPrint(S') '\b '. '\o '\n
       eMetaPrettyPrint(SSDS)) .
  eq eMetaPrettyPrint((none).SubsortDeclSet) = nil .

  eq eMetaPrettyPrint(M, ((op F : TyL -> Ty [none] .) OPDS))
    = ('\s '\s
       '\b 'op '\o F '\b ': '\o eMetaPrettyPrint(TyL)
       '\b '-> '\o eMetaPrettyPrint(Ty) '\b '. '\o '\n
       eMetaPrettyPrint(M, OPDS)) .
  eq eMetaPrettyPrint(M, ((op F : TyL -> Ty [AtS] .) OPDS))
    = ('\s '\s
       '\b 'op '\o F '\b ': '\o eMetaPrettyPrint(TyL)
       '\b '-> '\o eMetaPrettyPrint(Ty) '\n
       '\s '\s '\s '\s '\b '`[ '\o eMetaPrettyPrint(M, AtS) '\b '`] '\s '. '\o '\n
       eMetaPrettyPrint(M, OPDS))
    [owise] .
  eq eMetaPrettyPrint(M, (none).OpDeclSet)  = nil .

  eq eMetaPrettyPrintVars(V ; VDS)
    = ('\s '\s '\b 'var '\o getName(V) '\b ': '\o eMetaPrettyPrint(getType(V)) '\b '. '\o '\n
       eMetaPrettyPrintVars(VDS)) .
  eq eMetaPrettyPrintVars((none).VariableSet)  = nil .

  eq eMetaPrettyPrint(M, (mb T : S [none] .) MAS)
    = ('\s '\s '\b 'mb '\o eMetaPrettyPrint(M, T) '\b ': '\o eMetaPrettyPrint(S) '\b '. '\o '\n
       eMetaPrettyPrint(M, MAS)) .
  eq eMetaPrettyPrint(M, (mb T : S [AtS] .) MAS)
    = ('\s '\s '\b 'mb '\o eMetaPrettyPrint(M, T)
                   '\b ': '\o eMetaPrettyPrint(S)
               '\s '\b '`[ '\o eMetaPrettyPrint(M, AtS) '\b '`] '\s '. '\o '\n
       eMetaPrettyPrint(M, MAS))
    [owise] .
  eq eMetaPrettyPrint(M, (cmb T : S if Cond [none] .) MAS)
    = ('\s '\s '\b 'cmb '\o eMetaPrettyPrint(M, T)
                   '\b ': '\o eMetaPrettyPrint(S) '\n
       '\s '\s '\s '\s '\b 'if '\o eMetaPrettyPrint(M, Cond) '\b '. '\o '\n
       eMetaPrettyPrint(M, MAS)) .
  eq eMetaPrettyPrint(M, (cmb T : S if Cond [AtS] .) MAS)
    = ('\s '\s '\b 'cmb '\o eMetaPrettyPrint(M, T)
                   '\b ': '\o eMetaPrettyPrint(S) '\n
       '\s '\s '\s '\s '\b 'if '\o eMetaPrettyPrint(M, Cond)
           '\s '\b '`[ '\o eMetaPrettyPrint(M, AtS) '\b '`] '\s '. '\o '\n
       eMetaPrettyPrint(M, MAS))
    [owise] .
  eq eMetaPrettyPrint(M, (none).MembAxSet) = nil .

  eq eMetaPrettyPrint(M, ((eq T = T' [none] .) EqS))
    = ('\s '\s '\b 'eq '\s '\o eMetaPrettyPrint(M, T) '\n
       '\s '\s '\s '\s '\b '= '\s '\o eMetaPrettyPrint(M, T') '\b '\s '. '\n
       '\o
       eMetaPrettyPrint(M, EqS)) .
  eq eMetaPrettyPrint(M, ((eq T = T' [AtS] .) EqS))
    = ('\s '\s '\b 'eq '\s '\o eMetaPrettyPrint(M, T) '\n
       '\s '\s '\s '\s '\b '= '\s '\o eMetaPrettyPrint(M, T')
           '\s '\b '`[ '\o eMetaPrettyPrint(M, AtS) '\b '`] '\s '. '\o '\n
       eMetaPrettyPrint(M, EqS))
    [owise] .
  eq eMetaPrettyPrint(M, ((ceq T = T' if Cond [none] .) EqS))
    = ('\s '\s '\b 'ceq '\s '\o eMetaPrettyPrint(M, T) '\n
       '\s '\s '\s '\s '\b '= '\s '\o eMetaPrettyPrint(M, T') '\n
       '\s '\s '\s '\s '\b 'if '\o '\s eMetaPrettyPrint(M, Cond) '\b '\s '. '\o '\n
       eMetaPrettyPrint(M, EqS)) .
  eq eMetaPrettyPrint(M, ((ceq T = T' if Cond [AtS] .) EqS))
    = ('\s '\s '\b 'ceq '\s '\o eMetaPrettyPrint(M, T) '\n
       '\s '\s '\s '\s '\b '= '\s '\o eMetaPrettyPrint(M, T') '\n
       '\s '\s '\s '\s '\b 'if '\o '\s eMetaPrettyPrint(M, Cond)
           '\s '\b '`[ '\o eMetaPrettyPrint(M, AtS) '\b '`] '\s '. '\o '\n
       eMetaPrettyPrint(M, EqS))
    [owise] .
  eq eMetaPrettyPrint(M, (none).EquationSet) = nil .

  eq eMetaPrettyPrint(M, ((rl T => T' [none] .) RlS))
    = ('\s '\s '\b 'rl '\s '\o eMetaPrettyPrint(M, T) '\n
       '\s '\s '\s '\s '\b '=> '\o '\s eMetaPrettyPrint(M, T') '\b '\s '. '\n '\o
       eMetaPrettyPrint(M, RlS)) .
  eq eMetaPrettyPrint(M, ((rl T => T' [AtS] .) RlS))
    = ('\s '\s '\b 'rl '\s '\o eMetaPrettyPrint(M, T) '\n
       '\s '\s '\s '\s '\b '=> '\o '\s eMetaPrettyPrint(M, T')
           '\s '\b '`[ '\o eMetaPrettyPrint(M, AtS) '\b '`] '\s '. '\o '\n
       eMetaPrettyPrint(M, RlS))
    [owise] .
  eq eMetaPrettyPrint(M, ((crl T => T' if Cond [none] .) RlS))
    = ('\s '\s '\b 'crl '\s '\o eMetaPrettyPrint(M, T) '\n
       '\s '\s '\s '\s '\b '=> '\o '\s eMetaPrettyPrint(M, T') '\n
       '\s '\s '\s '\s '\b 'if '\o '\s eMetaPrettyPrint(M, Cond) '\b '\s '. '\o '\n
       eMetaPrettyPrint(M, RlS)) .
  eq eMetaPrettyPrint(M, ((crl T => T' if Cond [AtS] .) RlS))
    = ('\s '\s '\b 'crl '\s '\o eMetaPrettyPrint(M, T) '\n
       '\s '\s '\s '\s '\b '=> '\o '\s eMetaPrettyPrint(M, T') '\n
       '\s '\s '\s '\s '\b 'if '\o '\s eMetaPrettyPrint(M, Cond)
           '\s '\b '`[ '\o eMetaPrettyPrint(M, AtS) '\b '`] '\s '. '\o '\n
       eMetaPrettyPrint(M, RlS))
    [owise] .
  eq eMetaPrettyPrint(M, (none).RuleSet) = nil .

  eq eMetaPrettyPrint(M, ((strat F : TyL @ Ty [none] .) StratDcls))
    = ('\s '\s
       '\b 'strat '\o F '\b ': '\o eMetaPrettyPrint(TyL)
       '\b '@ '\o eMetaPrettyPrint(Ty) '\b '. '\o '\n
       eMetaPrettyPrint(M, StratDcls)) .
  eq eMetaPrettyPrint(M, ((strat F : TyL @ Ty [AtS] .) StratDcls))
    = ('\s '\s
       '\b 'strat '\o F '\b ': '\o eMetaPrettyPrint(TyL)
       '\b '@ '\o eMetaPrettyPrint(Ty) '\n
       '\s '\s '\s '\s '\b '`[ '\o eMetaPrettyPrint(M, AtS) '\b '`] '\s '. '\o '\n
       eMetaPrettyPrint(M, StratDcls))
    [owise] .
  eq eMetaPrettyPrint(M, (none).StratDeclSet)  = nil .

  eq eMetaPrettyPrint(M, ((sd CS := Strat [none] .) StratDefs))
    = ('\s '\s '\b 'sd '\s '\o metaPrettyPrintStrategy(M, CS) '\n
       '\s '\s '\s '\s '\b ':= '\o '\s metaPrettyPrintStrategy(M, Strat) '\b '\s '. '\n '\o
       eMetaPrettyPrint(M, StratDefs)) .
  eq eMetaPrettyPrint(M, ((sd CS := Strat [AtS] .) StratDefs))
    = ('\s '\s '\b 'sd '\s '\o eMetaPrettyPrint(M, CS) '\n
       '\s '\s '\s '\s '\b ':= '\o '\s metaPrettyPrintStrategy(M, Strat)
           '\s '\b '`[ '\o eMetaPrettyPrint(M, AtS) '\b '`] '\s '. '\o '\n
       eMetaPrettyPrint(M, StratDefs))
    [owise] .
  eq eMetaPrettyPrint(M, ((csd CS := Strat if Cond [none] .) StratDefs))
    = ('\s '\s '\b 'csd '\s '\o eMetaPrettyPrint(M, CS) '\n
       '\s '\s '\s '\s '\b ':= '\o '\s metaPrettyPrintStrategy(M, Strat) '\n
       '\s '\s '\s '\s '\b 'if '\o '\s eMetaPrettyPrint(M, Cond) '\b '\s '. '\o '\n
       eMetaPrettyPrint(M, StratDefs)) .
  eq eMetaPrettyPrint(M, ((csd CS := Strat if Cond [AtS] .) StratDefs))
    = ('\s '\s '\b 'csd '\s '\o eMetaPrettyPrint(M, CS) '\n
       '\s '\s '\s '\s '\b ':= '\o '\s metaPrettyPrintStrategy(M, Strat) '\n
       '\s '\s '\s '\s '\b 'if '\o '\s eMetaPrettyPrint(M, Cond)
           '\s '\b '`[ '\o eMetaPrettyPrint(M, AtS) '\b '`] '\s '. '\o '\n
       eMetaPrettyPrint(M, StratDefs))
    [owise] .
  eq eMetaPrettyPrint(M, (none).StratDefSet) = nil .

  op eMetaPrettyPrint : Module CallStrategy -> QidList .
  eq eMetaPrettyPrint(M, F[[TL]]) = F '`[ '`[ eMetaPrettyPrint(M, TL) '`] '`] .

  op eMetaPrettyPrint : Module TermList -> QidList .
  eq eMetaPrettyPrint(M, (T, TL)) = metaPrettyPrint(M, T) '`, eMetaPrettyPrint(M, TL) .
  eq eMetaPrettyPrint(M, (empty).TermList) = nil .

  eq eMetaPrettyPrint(M, T = T' /\ Cond)
    = (eMetaPrettyPrint(M, T) '\b '= '\o eMetaPrettyPrint(M, T') '\b
      '/\ '\o eMetaPrettyPrint(M, Cond))
    [owise] .
  eq eMetaPrettyPrint(M, T : S /\ Cond)
    = (eMetaPrettyPrint(M, T) '\b ': '\o eMetaPrettyPrint(S) '\b
      '/\ '\o eMetaPrettyPrint(M, Cond))
    [owise] .
  eq eMetaPrettyPrint(M, T := T' /\ Cond)
    = (eMetaPrettyPrint(M, T) '\b ':= '\o eMetaPrettyPrint(M, T') '\b
      '/\ '\o eMetaPrettyPrint(M, Cond))
    [owise] .
  eq eMetaPrettyPrint(M, T => T' /\ Cond)
    = (eMetaPrettyPrint(M, T) '\b '=> '\o eMetaPrettyPrint(M, T') '\b
      '/\ '\o eMetaPrettyPrint(M, Cond))
    [owise] .
  eq eMetaPrettyPrint(M, T = T')
    = (eMetaPrettyPrint(M, T) '\b '= '\o eMetaPrettyPrint(M, T')) .
  eq eMetaPrettyPrint(M, T : S)
    = (eMetaPrettyPrint(M, T) '\b ': '\o eMetaPrettyPrint(S)) .
  eq eMetaPrettyPrint(M, T := T')
    = (eMetaPrettyPrint(M, T) '\b ':= '\o eMetaPrettyPrint(M, T')) .
  eq eMetaPrettyPrint(M, T => T')
    = (eMetaPrettyPrint(M, T) '\b '=> '\o eMetaPrettyPrint(M, T')) .
  eq eMetaPrettyPrint(M, (nil).EqCondition) = nil .

  eq eMetaPrettyPrint(M, (assoc AtS))
    = ('\b 'assoc '\o eMetaPrettyPrint(M, AtS)) .
  eq eMetaPrettyPrint(M, (comm AtS))
    = ('\b 'comm '\o eMetaPrettyPrint(M, AtS)) .
  eq eMetaPrettyPrint(M, (memo AtS))
    = ('\b 'memo '\o eMetaPrettyPrint(M, AtS)) .
  eq eMetaPrettyPrint(M, (idem AtS))
    = ('\b 'idem '\o eMetaPrettyPrint(M, AtS)) .
  eq eMetaPrettyPrint(M, (id(T) AtS))
    = ('\b 'id: '\o eMetaPrettyPrint(M, T) eMetaPrettyPrint(M, AtS)) .
  eq eMetaPrettyPrint(M, (right-id(T) AtS))
    = ('\b 'right 'id: '\o eMetaPrettyPrint(M, T) eMetaPrettyPrint(M, AtS)) .
  eq eMetaPrettyPrint(M, (left-id(T) AtS))
    = ('\b 'left 'id: '\o eMetaPrettyPrint(M, T) eMetaPrettyPrint(M, AtS)) .
  eq eMetaPrettyPrint(M, (poly(NL) AtS))
    = ('\b 'poly '`( '\o eMetaPrettyPrint(NL) '\b '`)
       '\o eMetaPrettyPrint(M, AtS)) .
  eq eMetaPrettyPrint(M, (strat(NL) AtS))
    = ('\b 'strat '`( '\o eMetaPrettyPrint(NL) '\b '`)
       '\o eMetaPrettyPrint(M, AtS)) .
  eq eMetaPrettyPrint(M, (memo AtS))
    = ('\b 'memo '\o eMetaPrettyPrint(M, AtS)) .
  eq eMetaPrettyPrint(M, (prec(I) AtS))
    = ('\b 'prec '\o eMetaPrettyPrint(I) eMetaPrettyPrint(M, AtS)) .
  eq eMetaPrettyPrint(M, (gather(QIL) AtS))
    = ('\b 'gather '\o '`( QIL '`) eMetaPrettyPrint(M, AtS)) .
  eq eMetaPrettyPrint(M, (format(QIL) AtS))
    = ('\b 'format '\o '`( QIL '`) eMetaPrettyPrint(M, AtS)) .
  eq eMetaPrettyPrint(M, (ctor AtS))
    = ('\b 'ctor '\o eMetaPrettyPrint(M, AtS)) .
  eq eMetaPrettyPrint(M, (frozen(NL) AtS))
    = ('\b 'frozen '`( '\o eMetaPrettyPrint(NL) '\b '`)
       '\o eMetaPrettyPrint(M, AtS)) .
  eq eMetaPrettyPrint(M, (iter AtS))
    = ('\b 'iter '\o eMetaPrettyPrint(M, AtS)) .
  eq eMetaPrettyPrint(M, (special(HkL) AtS))
    = ('\b 'special '`( '\o eMetaPrettyPrint(M, HkL) '\b '`)
       '\o eMetaPrettyPrint(M, AtS)) .
  eq eMetaPrettyPrint(M, (config AtS))
    = ('\b 'config '\o eMetaPrettyPrint(M, AtS)) .
  eq eMetaPrettyPrint(M, (object AtS))
    = ('\b 'object '\o eMetaPrettyPrint(M, AtS)) .
  eq eMetaPrettyPrint(M, (msg AtS))
    = ('\b 'msg '\o eMetaPrettyPrint(M, AtS)) .

  eq eMetaPrettyPrint(M, (label(QI) AtS))
    = ('\b 'label '\o QI '\b '\o eMetaPrettyPrint(M, AtS)) .
  eq eMetaPrettyPrint(M, (metadata(St) AtS))
    = ('\b 'metadata '\o qid("\"" + St + "\"") '\b
       '\o eMetaPrettyPrint(M, AtS)) .
  eq eMetaPrettyPrint(M, (nonexec AtS))
    = ('\b 'nonexec '\o eMetaPrettyPrint(M, AtS)) .
  eq eMetaPrettyPrint(M, (variant AtS))
    = ('\b 'variant '\o eMetaPrettyPrint(M, AtS)) .
  eq eMetaPrettyPrint(M, (owise AtS))
    = ('\b 'owise '\o eMetaPrettyPrint(M, AtS)) .
  eq eMetaPrettyPrint(M, (print(QIL) AtS))
    = ('\b 'print QIL '\o eMetaPrettyPrint(M, AtS)) .

  eq eMetaPrettyPrint(M, (none).AttrSet) = nil .

  ceq eMetaPrettyPrint(M, (Hk HkL))
    = (eMetaPrettyPrint(M, Hk) eMetaPrettyPrint(M, HkL))
    if HkL =/= nil .
  eq eMetaPrettyPrint(M, id-hook(QI, nil)) = ('\b 'id-hook '\o QI) .
  eq eMetaPrettyPrint(M, id-hook(QI, QIL))
    = ('\b 'id-hook '\o QI '\b '`( '\o QIL '\b '`) '\o )
    [owise] .
  eq eMetaPrettyPrint(M, op-hook(QI, QI', nil, QI''))
    = ('\b 'op-hook '\o QI '\b '`( '\o QI' ': '~> QI'' '\b '`) '\o) .
  eq eMetaPrettyPrint(M, op-hook(QI, QI', QIL, QI''))
    = ('\b 'op-hook '\o QI '\b '`( '\o QI' ': QIL '~> QI'' '\b '`) '\o)
    [owise] .
  eq eMetaPrettyPrint(M, term-hook(QI, T))
    = ('\b 'term-hook '\o QI '\b '`( '\o eMetaPrettyPrint(M, T) '\b '`) '\o) .

  eq eMetaPrettyPrint((I NL)) = (qid(string(I, 10)) eMetaPrettyPrint(NL)) .
  eq eMetaPrettyPrint((nil).NatList) = nil .

  eq eMetaPrettyPrint((class S | ADS .) CDS)
    = ((if ADS == none
        then ('\s '\s '\b 'class '\o eMetaPrettyPrint(S) '\b '. '\o '\n)
        else ('\s '\s '\b 'class '\o eMetaPrettyPrint(S) '\b '| '\o eMetaPrettyPrint(ADS) '\b '. '\o '\n)
        fi)
       eMetaPrettyPrint(CDS)) .
  eq eMetaPrettyPrint((none).ClassDeclSet) = nil .

  eq eMetaPrettyPrint((subclass S < S' .) SCDS)
    = ('\s '\s '\b 'subclass '\o eMetaPrettyPrint(S) '\b
           '< '\o eMetaPrettyPrint(S') '\b '. '\o '\n
       eMetaPrettyPrint(SCDS)) .
  eq eMetaPrettyPrint((none).SubclassDeclSet) = nil .

  eq eMetaPrettyPrint((msg F : TyL -> Ty .) MDS)
    = ('\s '\s '\b 'msg '\o F '\b ': '\o eMetaPrettyPrint(TyL) '\b '-> '\o eMetaPrettyPrint(Ty) '\b '. '\o '\n
       eMetaPrettyPrint(MDS)) .
  eq eMetaPrettyPrint((none).MsgDeclSet) = nil .

  eq eMetaPrettyPrint(((attr F : S), ADS))
    = (F '\b ': '\o eMetaPrettyPrint(S) '\b '`, '\o '\s eMetaPrettyPrint(ADS))
    [owise] .
  eq eMetaPrettyPrint((attr F : S)) = (F '\b ': '\o eMetaPrettyPrint(S)) .
  eq eMetaPrettyPrint((none).AttrDeclSet) = nil .

endfm

*******************************************************************************

***
*** 8.2.2 Meta Pretty Printing of Modules
***

*** In the following module, the \texttt{meta-pretty-print} function is
*** defined on sort \texttt{Module}.

fmod UNIT-META-PRETTY-PRINT is
  pr FM-UNIT .
  pr FM-RENAMING-EXPR-EVALUATION .
  pr DECL-META-PRETTY-PRINT .

  op eMetaPrettyPrint : Module Module -> QidList .

  op eMetaPrettyPrint : Module Module -> QidList .
  op eMetaPrettyPrint : Header -> QidList .
  op eMetaPrettyPrint : ParameterDeclList -> QidList .
  op eMetaPrettyPrint : ImportList -> QidList .

  var  M : Module .
  vars QI F F' L L' : Qid .
  var  QIL : QidList .
  var  ME : ModuleExpression .
  vars S S' : Sort .
  var  Ty : Type .
  var  TyL : TypeList .
  var  SS : SortSet .
  var  PD : ParameterDecl .
  var  PDL : ParameterDeclList .
  vars IL IL' : ImportList .
  var  SSDS : SubsortDeclSet .
  var  OPDS : OpDeclSet .
  var  MAS : MembAxSet .
  var  EqS : EquationSet .
  var  RlS : RuleSet .
  var  CDS : ClassDeclSet .
  var  SCDS : SubclassDeclSet .
  var  MDS : MsgDeclSet .
  var  U : Module .
  var  AtS : AttrSet .
  var  MN : ModuleName .
  var  StratDcls : StratDeclSet .
  var  StratDefs : StratDefSet .

  ceq eMetaPrettyPrint(ME)
    = if QI == '`) or QI == '`] or QI == '`}
      then QIL QI '\s
      else QIL QI
      fi
    if QIL QI := header2QidList(ME) .

  eq eMetaPrettyPrint(W:[Module], unitError(QIL)) = QIL .
  eq eMetaPrettyPrint(unitError(QIL), noModule) = QIL .
  eq eMetaPrettyPrint(noModule, noModule) = nil .
  eq eMetaPrettyPrint(M, mod ME is IL sorts SS . SSDS OPDS MAS EqS RlS endm)
    = ('\b
       'mod '\o eMetaPrettyPrint(ME) '\b 'is '\o '\n
          eMetaPrettyPrint(IL)
          (if SS == none
           then nil
           else ('\s '\s '\b 'sorts '\o eMetaPrettyPrint(SS) '\b '. '\o '\n)
           fi)
          eMetaPrettyPrint(SSDS)
          eMetaPrettyPrint(M, OPDS)
          eMetaPrettyPrint(M, MAS)
          eMetaPrettyPrint(M, EqS)
          eMetaPrettyPrint(M, RlS)
       '\b 'endm '\o '\n) .
  eq eMetaPrettyPrint(M, mod ME{PDL} is IL sorts SS . SSDS OPDS MAS EqS RlS endm)
    = ('\b
       'mod '\o eMetaPrettyPrint(ME) (if PDL == nil
                                      then nil
                                      else '`{ eMetaPrettyPrint(PDL) '`} '\s
                                      fi) '\b 'is '\o '\n
          eMetaPrettyPrint(IL)
          (if SS == none
           then nil
           else ('\s '\s '\b 'sorts '\o eMetaPrettyPrint(SS) '\b '. '\o '\n)
           fi)
          eMetaPrettyPrint(SSDS)
          eMetaPrettyPrint(M, OPDS)
          eMetaPrettyPrint(M, MAS)
          eMetaPrettyPrint(M, EqS)
          eMetaPrettyPrint(M, RlS)
       '\b 'endm '\o '\n) .
  eq eMetaPrettyPrint(M, th MN is IL sorts SS . SSDS OPDS MAS EqS RlS endth)
    = ('\b
       'th '\o eMetaPrettyPrint(MN) '\b 'is '\o '\n
          eMetaPrettyPrint(IL)
          (if SS == none
           then nil
           else ('\s '\s '\b 'sorts '\o eMetaPrettyPrint(SS) '\b '. '\o '\n)
           fi)
          eMetaPrettyPrint(SSDS)
          eMetaPrettyPrint(M, OPDS)
          eMetaPrettyPrint(M, MAS)
          eMetaPrettyPrint(M, EqS)
          eMetaPrettyPrint(M, RlS)
       '\b 'endth '\o '\n) .
  eq eMetaPrettyPrint(M, fmod ME is IL sorts SS . SSDS OPDS MAS EqS endfm)
    = ('\b
       'fmod '\o eMetaPrettyPrint(ME) '\b 'is '\o '\n
           eMetaPrettyPrint(IL)
           (if SS == none
            then nil
            else ('\s '\s '\b 'sorts '\o eMetaPrettyPrint(SS) '\b '. '\o '\n)
            fi)
           eMetaPrettyPrint(SSDS)
           eMetaPrettyPrint(M, OPDS)
           eMetaPrettyPrint(M, MAS)
           eMetaPrettyPrint(M, EqS)
       '\b 'endfm '\o '\n) .
  eq eMetaPrettyPrint(M, fmod ME{PDL} is IL sorts SS . SSDS OPDS MAS EqS endfm)
    = ('\b
       'fmod '\o eMetaPrettyPrint(ME) (if PDL == nil
                                       then nil
                                       else '`{ eMetaPrettyPrint(PDL) '`} '\s
                                       fi) '\b 'is '\o '\n
           eMetaPrettyPrint(IL)
           (if SS == none
            then nil
            else ('\s '\s '\b 'sorts '\o eMetaPrettyPrint(SS) '\b '. '\o '\n)
            fi)
           eMetaPrettyPrint(SSDS)
           eMetaPrettyPrint(M, OPDS)
           eMetaPrettyPrint(M, MAS)
           eMetaPrettyPrint(M, EqS)
       '\b 'endfm '\o '\n) .
  eq eMetaPrettyPrint(M, fth MN is IL sorts SS . SSDS OPDS MAS EqS endfth)
    = ('\b
       'fth '\o eMetaPrettyPrint(MN) '\b 'is '\o '\n
          eMetaPrettyPrint(IL)
          (if SS == none
           then nil
           else ('\s '\s '\b 'sorts '\o eMetaPrettyPrint(SS) '\b '. '\o '\n)
           fi)
          eMetaPrettyPrint(SSDS)
          eMetaPrettyPrint(M, OPDS)
          eMetaPrettyPrint(M, MAS)
          eMetaPrettyPrint(M, EqS)
       '\b 'endfth '\o '\n) .
  eq eMetaPrettyPrint(M,
       omod ME is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom)
    = ('\b
       'omod '\o eMetaPrettyPrint(ME) '\b 'is '\o '\n
          eMetaPrettyPrint(IL)
          (if SS == none
           then nil
           else ('\s '\s '\b 'sorts '\o eMetaPrettyPrint(SS) '\b '. '\o '\n )
           fi)
          eMetaPrettyPrint(SSDS) eMetaPrettyPrint(CDS)
          eMetaPrettyPrint(SCDS) eMetaPrettyPrint(M, OPDS)
          eMetaPrettyPrint(MDS) eMetaPrettyPrint(M, MAS)
          eMetaPrettyPrint(M, EqS) eMetaPrettyPrint(M, RlS)
       '\b 'endom '\o '\n) .
  eq eMetaPrettyPrint(M, omod ME{PDL} is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom)
    = ('\b
       'omod '\o eMetaPrettyPrint(ME) (if PDL == nil
                                       then nil
                                       else ('`{ eMetaPrettyPrint(PDL) '`} '\s)
                                       fi) '\b 'is '\o '\n
          eMetaPrettyPrint(IL)
          (if SS == none
           then nil
           else ('\s '\s '\b 'sorts '\o eMetaPrettyPrint(SS) '\b '. '\o '\n )
           fi)
          eMetaPrettyPrint(SSDS) eMetaPrettyPrint(CDS)
          eMetaPrettyPrint(SCDS) eMetaPrettyPrint(M, OPDS)
          eMetaPrettyPrint(MDS) eMetaPrettyPrint(M, MAS)
          eMetaPrettyPrint(M, EqS) eMetaPrettyPrint(M, RlS)
       '\b 'endom '\o '\n) .
  eq eMetaPrettyPrint(M, oth MN is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth)
    = ('\b
       'oth '\o eMetaPrettyPrint(MN) '\b 'is '\o '\n
          eMetaPrettyPrint(IL)
          (if SS == none
           then nil
           else ('\s '\s '\b 'sorts '\o eMetaPrettyPrint(SS) '\b '. '\o '\n )
           fi)
          eMetaPrettyPrint(SSDS) eMetaPrettyPrint(CDS)
          eMetaPrettyPrint(SCDS) eMetaPrettyPrint(M, OPDS)
          eMetaPrettyPrint(MDS) eMetaPrettyPrint(M, MAS)
          eMetaPrettyPrint(M, EqS) eMetaPrettyPrint(M, RlS) '\n '\b
       'endoth '\o '\n) .
  eq eMetaPrettyPrint(M, smod ME is IL sorts SS . SSDS OPDS MAS EqS RlS StratDcls StratDefs endsm)
    = ('\b
       'smod '\o eMetaPrettyPrint(ME) '\b 'is '\o '\n
          eMetaPrettyPrint(IL)
          (if SS == none
           then nil
           else ('\s '\s '\b 'sorts '\o eMetaPrettyPrint(SS) '\b '. '\o '\n)
           fi)
          eMetaPrettyPrint(SSDS)
          eMetaPrettyPrint(M, OPDS)
          eMetaPrettyPrint(M, MAS)
          eMetaPrettyPrint(M, EqS)
          eMetaPrettyPrint(M, RlS)
          eMetaPrettyPrint(M, StratDcls)
          eMetaPrettyPrint(M, StratDefs)
       '\b 'endsm '\o '\n) .
 eq eMetaPrettyPrint(M, smod ME{PDL} is IL sorts SS . SSDS OPDS MAS EqS RlS StratDcls StratDefs endsm)
   = ('\b
      'smod '\o eMetaPrettyPrint(ME) (if PDL == nil
                                     then nil
                                     else '`{ eMetaPrettyPrint(PDL) '`} '\s
                                     fi) '\b 'is '\o '\n
         eMetaPrettyPrint(IL)
         (if SS == none
          then nil
          else ('\s '\s '\b 'sorts '\o eMetaPrettyPrint(SS) '\b '. '\o '\n)
          fi)
         eMetaPrettyPrint(SSDS)
         eMetaPrettyPrint(M, OPDS)
         eMetaPrettyPrint(M, MAS)
         eMetaPrettyPrint(M, EqS)
         eMetaPrettyPrint(M, RlS)
         eMetaPrettyPrint(M, StratDcls)
         eMetaPrettyPrint(M, StratDefs)
      '\b 'endsm '\o '\n) .
 eq eMetaPrettyPrint(M, sth MN is IL sorts SS . SSDS OPDS MAS EqS RlS StratDcls StratDefs endsth)
   = ('\b
      'sth '\o eMetaPrettyPrint(MN) '\b 'is '\o '\n
         eMetaPrettyPrint(IL)
         (if SS == none
          then nil
          else ('\s '\s '\b 'sorts '\o eMetaPrettyPrint(SS) '\b '. '\o '\n)
          fi)
         eMetaPrettyPrint(SSDS)
         eMetaPrettyPrint(M, OPDS)
         eMetaPrettyPrint(M, MAS)
         eMetaPrettyPrint(M, EqS)
         eMetaPrettyPrint(M, RlS)
         eMetaPrettyPrint(M, StratDcls)
         eMetaPrettyPrint(M, StratDefs)
      '\b 'endsth '\o '\n) .

  eq eMetaPrettyPrint((including ME .) IL)
    = ('\s '\s '\b 'including '\o eMetaPrettyPrint(ME) '\b '. '\o '\n
       eMetaPrettyPrint(IL)) .
  eq eMetaPrettyPrint((extending ME .) IL)
    = ('\s '\s '\b 'extending '\o eMetaPrettyPrint(ME) '\b '. '\o '\n
       eMetaPrettyPrint(IL)) .
  eq eMetaPrettyPrint((protecting ME .) IL)
    = ('\s '\s '\b 'protecting '\o eMetaPrettyPrint(ME) '\b '. '\o '\n
       eMetaPrettyPrint(IL)) .
  eq eMetaPrettyPrint((protecting pd(QI :: ME) .) IL)
    = eMetaPrettyPrint(IL) .
  eq eMetaPrettyPrint((nil).ImportList) = nil .

  eq eMetaPrettyPrint((QI :: ME, PDL))
    = (QI '::  eMetaPrettyPrint(ME) '`, eMetaPrettyPrint(PDL))
    [owise] .
  eq eMetaPrettyPrint((QI :: ME)) = (QI '::  eMetaPrettyPrint(ME)) .
  eq eMetaPrettyPrint((nil).ParameterDeclList) = (nil).QidList .

  op eMetaPrettyPrint : ModuleExpression -> QidList .
  eq eMetaPrettyPrint(QI + ME:ModuleExpression)
    = QI '+ eMetaPrettyPrint(ME:ModuleExpression) .
  eq eMetaPrettyPrint(QI * (RnS:RenamingSet))
    = QI '* '\s '`( renamingSet2QidList(RnS:RenamingSet) '`) .
  eq eMetaPrettyPrint(pd(PD)) = eMetaPrettyPrint(PD) .

  op renamingSet2QidList : RenamingSet -> QidList .
  eq renamingSet2QidList(((op F to F' [AtS]), RS:RenamingSet))
    = if AtS == none
      then ('op F 'to F' '`, '\s renamingSet2QidList(RS:RenamingSet))
      else ('op F 'to F' '\s '`[ attrSet2QidList(AtS) '`] '`, '\s
            renamingSet2QidList(RS:RenamingSet))
      fi
    [owise] .
  eq renamingSet2QidList((op F to F' [AtS]))
    = if AtS == none
      then ('op F 'to F')
      else ('op F 'to F' '\s '`[ attrSet2QidList(AtS) '`])
      fi .
  eq renamingSet2QidList(((op F : TyL -> Ty to F' [AtS]), RS:RenamingSet))
    = if AtS == none
      then ('op F ': typeList2QidList(TyL) '-> Ty 'to F' '`,
            '\s renamingSet2QidList(RS:RenamingSet))
      else ('op F ': typeList2QidList(TyL) '-> Ty 'to F'
            '`[ attrSet2QidList(AtS) '`] '`,
            '\s renamingSet2QidList(RS:RenamingSet))
      fi
    [owise] .
  eq renamingSet2QidList((op F : TyL -> Ty to F' [AtS]))
    = if AtS == none
      then ('op F ': typeList2QidList(TyL) '-> Ty 'to F')
      else ('op F ': typeList2QidList(TyL) '-> Ty 'to F'
            '`[ attrSet2QidList(AtS) '`])
      fi .
  eq renamingSet2QidList(((sort S to S'), RS:RenamingSet))
    = ('sort S 'to S' '`, '\s
       renamingSet2QidList(RS:RenamingSet))
    [owise] .
  eq renamingSet2QidList((sort S to S')) = ('sort S 'to S') .

  eq renamingSet2QidList(((label L to L'), RS:RenamingSet))
    = ('label L 'to L' '`, '\s renamingSet2QidList(RS:RenamingSet))
    [owise] .
  eq renamingSet2QidList((label L to L')) = ('label L 'to L') .
endfm

*******************************************************************************

*** The function \texttt{meta-pretty-print} on units is defined recursively,
*** calling the \texttt{meta-pretty-print} functions for the different
*** declarations in the unit defined in module \texttt{DECL-META-PRETTY-PRINT}.

***
*** 8.2.3 Meta Pretty Printing of Maps and Views
***

*** We define in the following module the function \texttt{meta-pretty-print}
*** on maps.

fmod MAP-SET-META-PRETTY-PRINT is
  pr DECL-META-PRETTY-PRINT .
  pr FM-FMAP .
  pr FM-UNIT .

  op eMetaPrettyPrint : RenamingSet -> QidList .

  var  MAP : Renaming .
  var  MAPS : RenamingSet .
  vars QI QI' F F' L L' : Qid .
  var  AtS : AttrSet .
  vars S S' : Sort .
  var  Ty : Type .
  var  TyL : TypeList .

  eq eMetaPrettyPrint((MAP, MAPS))
    = (eMetaPrettyPrint(MAP) '`, '\s '\s eMetaPrettyPrint(MAPS))
    [owise] .
  eq eMetaPrettyPrint((none).RenamingSet) = nil .

  eq eMetaPrettyPrint(op F to F' [AtS])
    = if AtS == none
      then ('\b 'op '\o F '\b 'to '\o F')
      else ('\b 'op F '\b 'to '\o F' '\b
            '`[ '\o eMetaPrettyPrint(noModule, AtS) '\b '`] '\o)
           *** In a map there should not be attributes requiring a module
      fi .
  eq eMetaPrettyPrint(op F : TyL -> Ty to F' [AtS])
    = if AtS == none
      then ('\b 'op '\o F '\b ':
            '\o eMetaPrettyPrint(TyL) '\b '-> '\o eMetaPrettyPrint(Ty)
            '\b 'to '\o F')
      else ('\b 'op '\o F '\b ':
            '\o eMetaPrettyPrint(TyL) '\b '-> '\o eMetaPrettyPrint(Ty)
            '\b 'to '\o F'
            '\b '`[ '\o eMetaPrettyPrint(noModule, AtS) '\b '`] '\o)
           *** In a map there should not be attributes requiring a module
      fi .
  eq eMetaPrettyPrint(sort S to S')
    = ('\b 'sort '\o eMetaPrettyPrint(S) '\b 'to '\o eMetaPrettyPrint(S')) .
  eq eMetaPrettyPrint(label L to L') = ('\b 'label '\o L '\b 'to '\o L') .
  eq eMetaPrettyPrint(class S to S')
    = ('\b 'class '\o eMetaPrettyPrint(S) '\b 'to '\o eMetaPrettyPrint(S')) .
  eq eMetaPrettyPrint(attr QI . S to QI')
    = ('\b 'attr '\o eMetaPrettyPrint(S) '\b '. '\o QI '\b 'to '\o QI') .
  eq eMetaPrettyPrint(msg F to F') = ('\b 'msg '\o F '\b 'to '\o F') .
  eq eMetaPrettyPrint(msg F : TyL -> Ty to F')
    = ('\b 'msg '\o F '\b ':
       '\o eMetaPrettyPrint(TyL) '\b '-> '\o eMetaPrettyPrint(Ty)
       '\b 'to '\o F') .

endfm

*******************************************************************************

*** Finally, in the \texttt{VIEW-META-PRETTY-PRINT} module, the
*** \texttt{meta-pretty-print} function is defined on views.


fmod VIEW-META-PRETTY-PRINT is
  pr DATABASE .
  pr MAP-SET-META-PRETTY-PRINT .
  pr FM-RENAMING-SET-APPL-ON-UNIT .
  pr UNIT-META-PRETTY-PRINT .

  op eMetaPrettyPrint : Database View -> QidList .
  op eMetaPrettyPrint : ViewExpression -> QidList .
  op eMetaPrettyPrint : ModuleExpression ModuleExpression Database SortMappingSet
       SortMappingSet OpMappingSet -> QidList .
  op eMetaPrettyPrint : ModuleExpression ModuleExpression Database OpMappingSet
       SortMappingSet OpMappingSet -> QidList .
  op eMetaPrettyPrint : ModuleExpression ModuleExpression Database StratMappingSet
       SortMappingSet OpMappingSet -> QidList .
  op eMetaPrettyPrint1 : ModuleExpression ModuleExpression Database SortMapping
       SortMappingSet OpMappingSet -> QidList .
  op eMetaPrettyPrint1 : ModuleExpression ModuleExpression Database OpMapping
       SortMappingSet OpMappingSet -> QidList .
  op eMetaPrettyPrint1 : ModuleExpression ModuleExpression Database StratMapping
       SortMappingSet OpMappingSet -> QidList .

  vars QI QI' F F' : Qid .
  vars S S' : Sort .
  var  TyL : TypeList .
  var  Ty : Type .
  var  QIL : QidList .
  var  DB : Database .
  vars ME ME' : ModuleExpression .
  var  SM : SortMapping .
  var  OM : OpMapping .
  var  TM : StratMapping .
  vars SMS SMS' : SortMappingSet .
  vars OMS OMS' : OpMappingSet .
  vars TMS TMS' : StratMappingSet .
  vars T T' : Term .
  var  PDL : ParameterDeclList .
  vars VE VE' : ViewExpression .
  var  DT : Default{Term} .
  var  CS : CallStrategy .
  var  Strat : Strategy .

  ceq eMetaPrettyPrint(DB, view VE from ME to ME' is SMS OMS TMS endv)
    = ('\b 'view '\o
                 QIL QI
                 if QI == '`) then '\s else nil fi
              '\b 'from '\o eMetaPrettyPrint(ME)
              '\b 'to '\o eMetaPrettyPrint(ME') '\b 'is '\o '\n
       if SMS =/= none then '\s '\s eMetaPrettyPrint(ME, ME', DB, SMS, SMS, OMS) else nil fi
       if OMS =/= none then '\s '\s eMetaPrettyPrint(ME, ME', DB, OMS, SMS, OMS) else nil fi
       if TMS =/= none then '\s '\s eMetaPrettyPrint(ME, ME', DB, TMS, SMS, OMS) else nil fi
       '\b 'endv '\o '\n)
    if QIL QI := eMetaPrettyPrint(VE) .
  ceq eMetaPrettyPrint(DB, view VE{PDL} from ME to ME' is SMS OMS TMS endv)
    = ('\b 'view '\o
                 QIL QI
                 (if PDL == nil
                  then if QI == '`) then '\s else nil fi
                  else '`{ eMetaPrettyPrint(PDL) '`} '\s
                  fi)
              '\b 'from '\o eMetaPrettyPrint(ME)
              '\b 'to '\o eMetaPrettyPrint(ME') '\b 'is '\o '\n
       if OMS =/= none then eMetaPrettyPrint(ME, ME', DB, SMS, SMS, OMS) else nil fi
       if OMS =/= none then eMetaPrettyPrint(ME, ME', DB, OMS, SMS, OMS) else nil fi
       if TMS =/= none then eMetaPrettyPrint(ME, ME', DB, TMS, SMS, OMS) else nil fi
       '\b 'endv '\o '\n )
    if QIL QI := eMetaPrettyPrint(VE) .
  eq eMetaPrettyPrint(DB, viewError(QIL)) = QIL .

  ceq eMetaPrettyPrint(QI) = QI if not QI :: Type .
  ceq eMetaPrettyPrint(((VE, VE')))
    = eMetaPrettyPrint(VE) '`, '\s eMetaPrettyPrint(VE')
    if VE =/= nil /\ VE' =/= nil .
  eq eMetaPrettyPrint(QI{VE}) = QI '`{ eMetaPrettyPrint(VE) '`} '\s .

  eq eMetaPrettyPrint(ME, ME', DB, SM SMS, SMS', OMS')
    = ('\s '\s eMetaPrettyPrint1(ME, ME', DB, SM, SMS', OMS') '\n
       eMetaPrettyPrint(ME, ME', DB, SMS, SMS', OMS')) .
  eq eMetaPrettyPrint(ME, ME', DB, OM OMS, SMS', OMS')
    = ('\s '\s eMetaPrettyPrint1(ME, ME', DB, OM, SMS', OMS') '\n
       eMetaPrettyPrint(ME, ME', DB, OMS, SMS', OMS')) .
  eq eMetaPrettyPrint(ME, ME', DB, TM TMS, SMS', OMS')
    = ('\s '\s eMetaPrettyPrint1(ME, ME', DB, TM, SMS', OMS') '\n
       eMetaPrettyPrint(ME, ME', DB, TMS, SMS', OMS')) .
  eq eMetaPrettyPrint(ME, ME', DB, (none).SortMappingSet, SMS, OMS) = nil .
  eq eMetaPrettyPrint(ME, ME', DB, (none).OpMappingSet, SMS, OMS) = nil .
  eq eMetaPrettyPrint(ME, ME', DB, (none).StratMappingSet, SMS, OMS) = nil .

  eq eMetaPrettyPrint1(ME, ME', DB, op_to`term_.(T, T'), SMS, OMS)
    = ('\b 'op '\o eMetaPrettyPrint(getFlatModule(ME, DB), T) '\b 'to
               'term '\o eMetaPrettyPrint(getFlatModule(ME', DB), T') '\b '. '\o) .
----  eq eMetaPrettyPrint1(ME, ME', DB, op_to`term_.(T, T'), SMS, OMS)
----    = ('op eMetaPrettyPrint(T) '\b 'to 'term '\o eMetaPrettyPrint(T') '. '\n) .
  eq eMetaPrettyPrint1(ME, ME', DB, op F to F' ., SMS, OMS)
    = ('\b 'op '\o F '\b 'to '\o F' '\b '. '\o) .
  eq eMetaPrettyPrint1(ME, ME', DB, op F : TyL -> Ty to F' ., SMS, OMS)
    = ('\b 'op '\o F '\b ':
       '\o eMetaPrettyPrint(TyL) '\b '-> '\o eMetaPrettyPrint(Ty)
       '\b 'to '\o F' 'b '. '\o) .
  eq eMetaPrettyPrint1(ME, ME', DB, sort S to S' ., SMS, OMS)
    = ('\b 'sort '\o eMetaPrettyPrint(S) '\b 'to '\o eMetaPrettyPrint(S') 'b '. '\o) .
  eq eMetaPrettyPrint1(ME, ME', DB, class S to S' ., SMS, OMS)
    = ('\b 'class '\o eMetaPrettyPrint(S) '\b 'to '\o eMetaPrettyPrint(S') 'b '. '\o) .
  eq eMetaPrettyPrint1(ME, ME', DB, attr QI . S to QI' ., SMS, OMS)
    = ('\b 'attr '\o eMetaPrettyPrint(S) '\b '. '\o QI '\b 'to '\o QI' 'b '. '\o) .
  eq eMetaPrettyPrint1(ME, ME', DB, msg F to F' ., SMS, OMS)
    = ('\b 'msg '\o F '\b 'to '\o F' 'b '. '\o) .
  eq eMetaPrettyPrint1(ME, ME', DB, msg F : TyL -> Ty to F' ., SMS, OMS)
    = ('\b 'msg '\o F '\b ':
       '\o eMetaPrettyPrint(TyL) '\b '-> '\o eMetaPrettyPrint(Ty)
       '\b 'to '\o F' 'b '. '\o) .

  eq eMetaPrettyPrint1(ME, ME', DB, strat_to`expr_.(CS, Strat), SMS, OMS)
    = ('\b 'strat '\o metaPrettyPrintStrategy(getFlatModule(ME, DB), CS) '\b 'to
               'expr '\o metaPrettyPrintStrategy(getFlatModule(ME', DB), Strat) '\b '. '\o) .
  eq eMetaPrettyPrint1(ME, ME', DB, strat F to F' ., SMS, OMS)
    = ('\b 'strat '\o F '\b 'to '\o F' 'b '. '\o) .
  eq eMetaPrettyPrint1(ME, ME', DB, strat F : TyL @ Ty to F' ., SMS, OMS)
    = ('\b 'strat '\o F
       if TyL == nil then nil else '\b ': '\o eMetaPrettyPrint(TyL) fi
       '\b '@ '\o eMetaPrettyPrint(Ty)
       '\b 'to '\o F' 'b '. '\o) .
endfm

*******************************************************************************

***
*** 8.3 Input Processing
***

*** The processing functions presented in the following modules are in charge
*** of taking each term generated by the \texttt{metaParse} function and,
*** after transforming it into an element of the data types \texttt{Module} or
*** \texttt{View}, or generating some output, returning the database resulting
*** from introducing in it such a term. We shall see in
*** Section~\ref{database-handling} how the appropriate function is called
*** after having performed a first analysis of the term, in which it is
*** detected whether the input corresponds to a unit, view, or command. In the
*** cases of units and views the processing is quite similar. After a
*** preprocessing of the term, the function \texttt{parseDecl} is called with
*** each of the subterms representing declarations, resulting in units or
*** views with the parsed declarations in it.

***
*** 8.3.1 Module Processing
***

*** The processing of a term resulting from the parsing of some input
*** corresponding to a unit is accomplished by the \texttt{procModule} function.
*** This function takes as arguments a term of sort \texttt{Term}, which
*** represents some preunit, and a database. The function then enters into the
*** given database the unit obtained from the transformation of such term
*** into a term of sort \texttt{Module}.

mod UNIT-PROCESSING is
  ----MI pr DATABASE .
  pr UNIT-DECL-PARSING .
  pr FM-EVALUATION .
  pr FM-RENAMING-SET-APPL-ON-UNIT .
  pr META-FULL-MAUDE-SIGN .
  pr FM-MOD-EXP-PARSING .

  vars QI F X : Qid .
  var  M : Module .
  vars PU PU' U U' : Module .
  vars DB DB' : Database .
  vars T T' T'' T3 : Term .
  var  TL : TermList .
  vars PL PL' PL'' : ParameterList .
  var  PDL : ParameterDeclList .
  var  IL IL' : ImportList .
  var  ME : ModuleExpression .
  var  S : Sort .
  var  SS : SortSet .
  var  ME' : ModuleExpression .
  var  VMAPS : RenamingSet .
  var  B : Bool .
  var  VDS : VariableSet .
  var  QIL : QidList .
  var  PDR : ParseDeclResult .
  var  DT : Default{Term} .

*** The \texttt{parseParList} takes a term representing a list of parameters
*** and returns the corresponding list.

  op parseParList : Term -> ParameterDeclList .
  eq parseParList('_::_['token[T], T']) = downQid(T) :: parseModExp(T') .
  eq parseParList('_`,_[T, T']) = (parseParList(T), parseParList(T')) .

*** All the operators declared as constructors of sort \texttt{PreModule} in
*** the signature of Full Maude, given in Appendix~\ref{signature-full-maude},
*** are declared with two arguments, namely, the name, or name and interface,
*** of the unit, and the list of declarations of such units. The function
*** \texttt{procModule3} is called with the term corresponding to the name, or
*** name and interface, of the module as first argument, the term corresponding
*** to the set of declarations as second argument, and an empty module of the
*** appropriate type, in which the different declarations will be accumulated,
*** as third argument.

*** The task of the function \texttt{procModule4} is then to make a second
*** level parsing of the input, building up, simultaneously, the preunit
*** represented in the term passed as argument, and the unit resulting from the
*** declarations without bubbles. This unit without bubbles will be used by the
*** \texttt{evalPreModule} function to build the signature with which to
*** analyze the bubbles in the preunit (see Section~\ref{evaluation}).

*** The case of parameterized modules requires a special treatment of the
*** parameters. These parameters are evaluated and are added as submodules in
*** the appropriate way.

*** When the last declaration is parsed, the function \texttt{evalPreModule} is
*** called with the preunit (the top module with bubbles) as first argument,
*** the empty copy of it as second argument, the top module without bubbles as
*** third argument, and the database.

*** Note that the \texttt{procModule} function adds a declaration importing the
*** module \texttt{CONFIGURATION+}, presented in
*** Section~\ref{non-built-in-predefined}, to the object-oriented modules, and
*** that \texttt{procModule4} adds a declaration importing the built-in module
*** \texttt{BOOL} to all modules.

  op procModule : Term Database -> Database .
  ***  moved to MOD-EXPR-EVAL to solve dependency
  ***  op procModule : Qid Database -> Database .
  op procModule2 : Term Term Database -> Database .
  op procModule2 : Term Database -> Database .
  op procModule3 : Term Term Term Module Database -> Database .
  op procModule3 : Term Term Module Database -> Database .
  op procModule4 : Term Term Module Module VariableSet Database -> Database .
  op procModule4 : Term Module Module VariableSet Database -> Database .

  op procModule : Oid Term -> Msg .
  op procModule : Oid Term Term -> Msg .

  rl < O : FullMaude | mi: MI, mn: QI?, st: 6, Atts >
     procModule(O, F[T, T'])
  => < O : FullMaude | mi: MI, mn: QI?, st: 6, Atts >
     procModule(O, F[T, T'], F[T, T']) .

  rl < O : FullMaude | mi: MI, mn: QI?, st: 6, Atts >
     procModule(O, T, 'fmod_is_endfm[T', T''])
  => < O : FullMaude | mi: MI, mn: QI?, st: 6, Atts >
     procModule(O, T, T', T'', emptyFModule) .
  rl < O : FullMaude | mi: MI, mn: QI?, st: 6, Atts >
     procModule(O, T, 'obj_is_endo[T', T''])
  => < O : FullMaude | mi: MI, mn: QI?, st: 6, Atts >
     procModule(O, T, T', T'', emptyFModule) .
  rl < O : FullMaude | mi: MI, mn: QI?, st: 6, Atts >
     procModule(O, T, 'obj_is_jbo[T', T''])
  => < O : FullMaude | mi: MI, mn: QI?, st: 6, Atts >
     procModule(O, T, T', T'', emptyFModule) .
  rl < O : FullMaude | mi: MI, mn: QI?, st: 6, Atts >
     procModule(O, T, 'mod_is_endm[T', T''])
  => < O : FullMaude | mi: MI, mn: QI?, st: 6, Atts >
     procModule(O, T, T', T'', emptySModule) .
  rl < O : FullMaude | mi: MI, mn: QI?, st: 6, Atts >
     procModule(O, T, 'omod_is_endom[T', T''])
  => < O : FullMaude | mi: MI, mn: QI?, st: 6, Atts >
     procModule(O, T, T', T'', addImports((including 'CONFIGURATION+ .), emptyOModule)) .
  rl < O : FullMaude | mi: MI, mn: QI?, st: 6, Atts >
     procModule(O, T, 'smod_is_endsm[T', T''])
  => < O : FullMaude | mi: MI, mn: QI?, st: 6, Atts >
     procModule(O, T, T', T'', emptyStratModule) .
  rl < O : FullMaude | mi: MI, mn: QI?, st: 6, Atts >
     procModule(O, T, 'fth_is_endfth[T', T''])
  => < O : FullMaude | mi: MI, mn: QI?, st: 6, Atts >
     procModule(O, T, T', T'', emptyFTheory) .
  rl < O : FullMaude | mi: MI, mn: QI?, st: 6, Atts >
     procModule(O, T, 'th_is_endth[T', T''])
  => < O : FullMaude | mi: MI, mn: QI?, st: 6, Atts >
     procModule(O, T, T', T'', emptySTheory) .
  rl < O : FullMaude | mi: MI, mn: QI?, st: 6, Atts >
     procModule(O, T, 'oth_is_endoth[T', T''])
  => < O : FullMaude | mi: MI, mn: QI?, st: 6, Atts >
     procModule(O, T, T', T'', addImports((including 'CONFIGURATION+ .), emptyOTheory)) .
  rl < O : FullMaude | mi: MI, mn: QI?, st: 6, Atts >
     procModule(O, T, 'sth_is_endsth[T', T''])
  => < O : FullMaude | mi: MI, mn: QI?, st: 6, Atts >
     procModule(O, T, T', T'', emptyStratTheory) .



endm

eof

---- load santiago.maude

fmod 2TUPLE{X :: TRIV, Y :: TRIV} is
  sorts Tuple{X, Y} .
  op ((_,_)) : X$Elt Y$Elt -> Tuple{X, Y} .
  op p1_ : Tuple{X, Y} -> X$Elt .
  op p2_ : Tuple{X, Y} -> Y$Elt .
  eq p1(V1:[X$Elt],V2:[Y$Elt]) = V1:[X$Elt] .
  eq p2(V1:[X$Elt],V2:[Y$Elt]) = V2:[Y$Elt] .
endfm

fmod 3TUPLE{X :: TRIV, Y :: TRIV, Z :: TRIV} is
  sort Tuple{X, Y, Z} .
  op ((_,_,_)) : X$Elt Y$Elt Z$Elt -> Tuple{X, Y, Z} .
  op p1_ : Tuple{X, Y, Z} -> X$Elt .
  op p2_ : Tuple{X, Y, Z} -> Y$Elt .
  op p3_ : Tuple{X, Y, Z} -> Z$Elt .
  eq p1((A:[X$Elt], B:[Y$Elt], C:[Z$Elt])) = A:[X$Elt] .
  eq p2((A:[X$Elt], B:[Y$Elt], C:[Z$Elt])) = B:[Y$Elt] .
  eq p3((A:[X$Elt], B:[Y$Elt], C:[Z$Elt])) = C:[Z$Elt] .
endfm

fmod 4TUPLE{W :: TRIV, X :: TRIV, Y :: TRIV, Z :: TRIV} is
  sort Tuple{W, X, Y, Z} .
  op ((_,_,_,_)) : W$Elt X$Elt Y$Elt Z$Elt -> Tuple{W, X, Y, Z} .
  op p1_ : Tuple{W, X, Y, Z} -> W$Elt .
  op p2_ : Tuple{W, X, Y, Z} -> X$Elt .
  op p3_ : Tuple{W, X, Y, Z} -> Y$Elt .
  op p4_ : Tuple{W, X, Y, Z} -> Z$Elt .
  eq p1((A:[W$Elt], B:[X$Elt], C:[Y$Elt], D:[Z$Elt])) = A:[W$Elt] .
  eq p2((A:[W$Elt], B:[X$Elt], C:[Y$Elt], D:[Z$Elt])) = B:[X$Elt] .
  eq p3((A:[W$Elt], B:[X$Elt], C:[Y$Elt], D:[Z$Elt])) = C:[Y$Elt] .
  eq p4((A:[W$Elt], B:[X$Elt], C:[Y$Elt], D:[Z$Elt])) = D:[Z$Elt] .
endfm

fmod 5TUPLE{V :: TRIV, W :: TRIV, X :: TRIV, Y :: TRIV, Z :: TRIV} is
  sort Tuple{V, W, X, Y, Z} .
  op ((_,_,_,_,_)) : V$Elt W$Elt X$Elt Y$Elt Z$Elt -> Tuple{V, W, X, Y, Z} .
  op p1_ : Tuple{V, W, X, Y, Z} -> V$Elt .
  op p2_ : Tuple{V, W, X, Y, Z} -> W$Elt .
  op p3_ : Tuple{V, W, X, Y, Z} -> X$Elt .
  op p4_ : Tuple{V, W, X, Y, Z} -> Y$Elt .
  op p5_ : Tuple{V, W, X, Y, Z} -> Z$Elt .
  eq p1((A:[V$Elt], B:[W$Elt], C:[X$Elt], D:[Y$Elt], E:[Z$Elt])) = A:[V$Elt] .
  eq p2((A:[V$Elt], B:[W$Elt], C:[X$Elt], D:[Y$Elt], E:[Z$Elt])) = B:[W$Elt] .
  eq p3((A:[V$Elt], B:[W$Elt], C:[X$Elt], D:[Y$Elt], E:[Z$Elt])) = C:[X$Elt] .
  eq p4((A:[V$Elt], B:[W$Elt], C:[X$Elt], D:[Y$Elt], E:[Z$Elt])) = D:[Y$Elt] .
  eq p5((A:[V$Elt], B:[W$Elt], C:[X$Elt], D:[Y$Elt], E:[Z$Elt])) = E:[Z$Elt] .
endfm

fmod 6TUPLE{X1 :: TRIV, X2 :: TRIV, X3 :: TRIV, X4 :: TRIV, X5 :: TRIV, X6 :: TRIV} is
  sort Tuple{X1, X2, X3, X4, X5, X6} .
  op ((_,_,_,_,_,_)) : X1$Elt X2$Elt X3$Elt X4$Elt X5$Elt X6$Elt
       -> Tuple{X1, X2, X3, X4, X5, X6} .
  op p1_ : Tuple{X1, X2, X3, X4, X5, X6} -> X1$Elt .
  op p2_ : Tuple{X1, X2, X3, X4, X5, X6} -> X2$Elt .
  op p3_ : Tuple{X1, X2, X3, X4, X5, X6} -> X3$Elt .
  op p4_ : Tuple{X1, X2, X3, X4, X5, X6} -> X4$Elt .
  op p5_ : Tuple{X1, X2, X3, X4, X5, X6} -> X5$Elt .
  op p6_ : Tuple{X1, X2, X3, X4, X5, X6} -> X6$Elt .
  eq p1((V1:[X1$Elt],V2:[X2$Elt],V3:[X3$Elt],V4:[X4$Elt],V5:[X5$Elt],V6:[X6$Elt]))
    = V1:[X1$Elt] .
  eq p2((V1:[X1$Elt],V2:[X2$Elt],V3:[X3$Elt],V4:[X4$Elt],V5:[X5$Elt],V6:[X6$Elt]))
    = V2:[X2$Elt] .
  eq p3((V1:[X1$Elt],V2:[X2$Elt],V3:[X3$Elt],V4:[X4$Elt],V5:[X5$Elt],V6:[X6$Elt]))
    = V3:[X3$Elt] .
  eq p4((V1:[X1$Elt],V2:[X2$Elt],V3:[X3$Elt],V4:[X4$Elt],V5:[X5$Elt],V6:[X6$Elt]))
    = V4:[X4$Elt] .
  eq p5((V1:[X1$Elt],V2:[X2$Elt],V3:[X3$Elt],V4:[X4$Elt],V5:[X5$Elt],V6:[X6$Elt]))
    = V5:[X5$Elt] .
  eq p6((V1:[X1$Elt],V2:[X2$Elt],V3:[X3$Elt],V4:[X4$Elt],V5:[X5$Elt],V6:[X6$Elt]))
    = V6:[X6$Elt] .
endfm

fmod 7TUPLE{X1 :: TRIV, X2 :: TRIV, X3 :: TRIV,
            X4 :: TRIV, X5 :: TRIV, X6 :: TRIV, X7 :: TRIV} is
  ---- define it using 6TUPLE{}
  sort Tuple{X1, X2, X3, X4, X5, X6, X7} .
  op ((_,_,_,_,_,_,_)) : X1$Elt X2$Elt X3$Elt X4$Elt X5$Elt X6$Elt X7$Elt
       -> Tuple{X1, X2, X3, X4, X5, X6, X7} .
  op p1_ : Tuple{X1, X2, X3, X4, X5, X6, X7} -> X1$Elt .
  op p2_ : Tuple{X1, X2, X3, X4, X5, X6, X7} -> X2$Elt .
  op p3_ : Tuple{X1, X2, X3, X4, X5, X6, X7} -> X3$Elt .
  op p4_ : Tuple{X1, X2, X3, X4, X5, X6, X7} -> X4$Elt .
  op p5_ : Tuple{X1, X2, X3, X4, X5, X6, X7} -> X5$Elt .
  op p6_ : Tuple{X1, X2, X3, X4, X5, X6, X7} -> X6$Elt .
  op p7_ : Tuple{X1, X2, X3, X4, X5, X6, X7} -> X7$Elt .
  eq p1((V1:[X1$Elt], V2:[X2$Elt], V3:[X3$Elt], V4:[X4$Elt], V5:[X5$Elt],
         V6:[X6$Elt], V7:[X7$Elt]))
    = V1:[X1$Elt] .
  eq p2((V1:[X1$Elt], V2:[X2$Elt], V3:[X3$Elt], V4:[X4$Elt], V5:[X5$Elt],
        V6:[X6$Elt], V7:[X7$Elt]))
    = V2:[X2$Elt] .
  eq p3((V1:[X1$Elt], V2:[X2$Elt], V3:[X3$Elt], V4:[X4$Elt], V5:[X5$Elt],
         V6:[X6$Elt], V7:[X7$Elt]))
    = V3:[X3$Elt] .
  eq p4((V1:[X1$Elt], V2:[X2$Elt], V3:[X3$Elt], V4:[X4$Elt], V5:[X5$Elt],
         V6:[X6$Elt], V7:[X7$Elt]))
    = V4:[X4$Elt] .
  eq p5((V1:[X1$Elt], V2:[X2$Elt], V3:[X3$Elt], V4:[X4$Elt], V5:[X5$Elt],
         V6:[X6$Elt], V7:[X7$Elt]))
    = V5:[X5$Elt] .
  eq p6((V1:[X1$Elt], V2:[X2$Elt], V3:[X3$Elt], V4:[X4$Elt], V5:[X5$Elt],
         V6:[X6$Elt], V7:[X7$Elt]))
    = V6:[X6$Elt] .
  eq p7((V1:[X1$Elt], V2:[X2$Elt], V3:[X3$Elt], V4:[X4$Elt], V5:[X5$Elt],
         V6:[X6$Elt], V7:[X7$Elt]))
    = V7:[X7$Elt] .
endfm

fmod 8TUPLE{X1 :: TRIV, X2 :: TRIV, X3 :: TRIV, X4 :: TRIV,
            X5 :: TRIV, X6 :: TRIV, X7 :: TRIV, X8 :: TRIV} is
  sort Tuple{X1, X2, X3, X4, X5, X6, X7, X8} .
  op ((_,_,_,_,_,_,_,_)) : X1$Elt X2$Elt X3$Elt X4$Elt X5$Elt X6$Elt X7$Elt X8$Elt
       -> Tuple{X1, X2, X3, X4, X5, X6, X7, X8} .
  op p1_ : Tuple{X1, X2, X3, X4, X5, X6, X7, X8} -> X1$Elt .
  op p2_ : Tuple{X1, X2, X3, X4, X5, X6, X7, X8} -> X2$Elt .
  op p3_ : Tuple{X1, X2, X3, X4, X5, X6, X7, X8} -> X3$Elt .
  op p4_ : Tuple{X1, X2, X3, X4, X5, X6, X7, X8} -> X4$Elt .
  op p5_ : Tuple{X1, X2, X3, X4, X5, X6, X7, X8} -> X5$Elt .
  op p6_ : Tuple{X1, X2, X3, X4, X5, X6, X7, X8} -> X6$Elt .
  op p7_ : Tuple{X1, X2, X3, X4, X5, X6, X7, X8} -> X7$Elt .
  op p8_ : Tuple{X1, X2, X3, X4, X5, X6, X7, X8} -> X8$Elt .
  var V1 : [X1$Elt] . var V2 : [X2$Elt] . var V3 : [X3$Elt] . var V4 : [X4$Elt] .
  var V5 : [X5$Elt] . var V6 : [X6$Elt] . var V7 : [X7$Elt] . var V8 : [X8$Elt] .
  eq p1((V1, V2, V3, V4, V5, V6, V7, V8)) = V1 .
  eq p2((V1, V2, V3, V4, V5, V6, V7, V8)) = V2 .
  eq p3((V1, V2, V3, V4, V5, V6, V7, V8)) = V3 .
  eq p4((V1, V2, V3, V4, V5, V6, V7, V8)) = V4 .
  eq p5((V1, V2, V3, V4, V5, V6, V7, V8)) = V5 .
  eq p6((V1, V2, V3, V4, V5, V6, V7, V8)) = V6 .
  eq p7((V1, V2, V3, V4, V5, V6, V7, V8)) = V7 .
  eq p8((V1, V2, V3, V4, V5, V6, V7, V8)) = V8 .
endfm

fmod 9TUPLE{X1 :: TRIV, X2 :: TRIV, X3 :: TRIV, X4 :: TRIV,
            X5 :: TRIV, X6 :: TRIV, X7 :: TRIV, X8 :: TRIV, X9 :: TRIV} is
  sort Tuple{X1, X2, X3, X4, X5, X6, X7, X8, X9} .
  op ((_,_,_,_,_,_,_,_,_)) : X1$Elt X2$Elt X3$Elt X4$Elt X5$Elt X6$Elt X7$Elt
       X8$Elt X9$Elt -> Tuple{X1, X2, X3, X4, X5, X6, X7, X8, X9} .
  op p1_ : Tuple{X1, X2, X3, X4, X5, X6, X7, X8, X9} -> X1$Elt .
  op p2_ : Tuple{X1, X2, X3, X4, X5, X6, X7, X8, X9} -> X2$Elt .
  op p3_ : Tuple{X1, X2, X3, X4, X5, X6, X7, X8, X9} -> X3$Elt .
  op p4_ : Tuple{X1, X2, X3, X4, X5, X6, X7, X8, X9} -> X4$Elt .
  op p5_ : Tuple{X1, X2, X3, X4, X5, X6, X7, X8, X9} -> X5$Elt .
  op p6_ : Tuple{X1, X2, X3, X4, X5, X6, X7, X8, X9} -> X6$Elt .
  op p7_ : Tuple{X1, X2, X3, X4, X5, X6, X7, X8, X9} -> X7$Elt .
  op p8_ : Tuple{X1, X2, X3, X4, X5, X6, X7, X8, X9} -> X8$Elt .
  op p9_ : Tuple{X1, X2, X3, X4, X5, X6, X7, X8, X9} -> X9$Elt .
  var V1 : [X1$Elt] . var V2 : [X2$Elt] . var V3 : [X3$Elt] . var V4 : [X4$Elt] .
  var V5 : [X5$Elt] . var V6 : [X6$Elt] . var V7 : [X7$Elt] . var V8 : [X8$Elt] .
  var V9 : [X9$Elt] .
  eq p1((V1, V2, V3, V4, V5, V6, V7, V8, V9)) = V1 .
  eq p2((V1, V2, V3, V4, V5, V6, V7, V8, V9)) = V2 .
  eq p3((V1, V2, V3, V4, V5, V6, V7, V8, V9)) = V3 .
  eq p4((V1, V2, V3, V4, V5, V6, V7, V8, V9)) = V4 .
  eq p5((V1, V2, V3, V4, V5, V6, V7, V8, V9)) = V5 .
  eq p6((V1, V2, V3, V4, V5, V6, V7, V8, V9)) = V6 .
  eq p7((V1, V2, V3, V4, V5, V6, V7, V8, V9)) = V7 .
  eq p8((V1, V2, V3, V4, V5, V6, V7, V8, V9)) = V8 .
  eq p9((V1, V2, V3, V4, V5, V6, V7, V8, V9)) = V9 .
endfm

view QidList from TRIV to QID-LIST is
  sort Elt to QidList .
endv

view TermList from TRIV to META-MODULE is
  sort Elt to TermList .
endv

view RuleSet from TRIV to META-MODULE is
  sort Elt to RuleSet .
endv

view EquationSet from TRIV to META-MODULE is
  sort Elt to EquationSet .
endv

view VariableSet from TRIV to META-LEVEL is
  sort Elt to VariableSet .
endv

view ImportList from TRIV to META-MODULE is
  sort Elt to ImportList .
endv

view Condition from TRIV to META-MODULE is
  sort Elt to Condition .
endv

view QidSet from TRIV to META-MODULE is
  sort Elt to QidSet .
endv

view ParameterDeclList from TRIV to META-MODULE is
  sort Elt to ParameterDeclList .
endv

view Bound from TRIV to META-LEVEL is
  sort Elt to Bound .
endv

view Sort from TRIV to META-LEVEL is
  sort Elt to Sort .
endv

view SortMappingSet from TRIV to META-LEVEL is
  sort Elt to SortMappingSet .
endv

view OpMappingSet from TRIV to META-LEVEL is
  sort Elt to OpMappingSet .
endv

view StratMappingSet from TRIV to META-LEVEL is
  sort Elt to StratMappingSet .
endv

view Tuple{X1 :: TRIV, X2 :: TRIV} from TRIV to 2TUPLE{X1, X2} is
  sort Elt to Tuple{X1, X2} .
endv

view ViewExpression from TRIV to META-LEVEL is
  sort Elt to ViewExpression .
endv

---- view Set{X :: TRIV} from TRIV to SET{X} is
----   sort Elt to Set{X} .
---- endv

-------------------------------------------------------------------------------
*******************************************************************************
***
*** 2 The Signature of Full Maude
***
*******************************************************************************
-------------------------------------------------------------------------------

fmod BUBBLES is
  sorts @Token@ @ViewToken@ @SortToken@ @NeTokenList@ @Bubble@ @UBubble@ @StBubble@
        @EqLBubble@ @RlLBubble@ @SdLBubble@ @RCBubble@ @RBubble@ .
  including QID-LIST .
  op token : Qid -> @Token@ [special (id-hook Bubble (1 1)
                                      op-hook qidSymbol (<Qids> : ~> Qid))] .
  op viewToken : Qid -> @ViewToken@ [special (id-hook Bubble    (1 1)
                                              op-hook qidSymbol (<Qids> : ~> Qid))] .
  op sortToken : Qid -> @SortToken@ [special (id-hook Bubble    (1 1)
                                              op-hook qidSymbol (<Qids> : ~> Qid)
                                              id-hook Exclude   ([ ] < to , . ( ) { } : |
                                                                 ditto precedence prec gather
                                                                 assoc associative comm commutative
                                                                 ctor constructor id: strat strategy
                                                                 poly memo memoization iter frozen
                                                                 config object msg metadata nonexec variant))] .
  op neTokenList : QidList -> @NeTokenList@ [special (id-hook Bubble (1 -1)
                                                      op-hook qidListSymbol (__ : QidList QidList ~> QidList)
                                                      op-hook qidSymbol (<Qids> : ~> Qid)
                                                      id-hook Exclude (. :))] .
  op bubble : QidList -> @Bubble@ [special (id-hook Bubble (1 -1)
                                            op-hook qidListSymbol (__ : QidList QidList ~> QidList)
                                            op-hook qidSymbol (<Qids> : ~> Qid)
                                            id-hook Exclude  (eq ceq rl crl mb cmb sd csd
                                                              var vars strat endm
                                                              endfm endsm sorts subsort subsorts
                                                              subclass subclasses op ops
                                                              protecting pr including inc extending
                                                              ctor assoc comm ==))] .
  op ububble : QidList -> @UBubble@ [special (id-hook Bubble (1 -1)
                                              op-hook qidListSymbol (__ : QidList QidList ~> QidList)
                                              op-hook qidSymbol (<Qids> : ~> Qid))] .
  op stbubble : QidList -> @StBubble@ [special (id-hook Bubble (1 -1)
                                                op-hook qidListSymbol (__ : QidList QidList ~> QidList)
                                                op-hook qidSymbol (<Qids> : ~> Qid)
                                                id-hook Exclude (using))] .
  op eqlbubble : QidList -> @EqLBubble@ [special (id-hook Bubble (1 -1)
                                                  op-hook qidListSymbol (__ : QidList QidList ~> QidList)
                                                  op-hook qidSymbol (<Qids> : ~> Qid)
                                                  id-hook Exclude (=))] .
  op rllbubble : QidList -> @RlLBubble@ [special (id-hook Bubble (1 -1)
                                                  op-hook qidListSymbol (__ : QidList QidList ~> QidList)
                                                  op-hook qidSymbol (<Qids> : ~> Qid)
                                                  id-hook Exclude (=>))] .
  op sdlbubble : QidList -> @SdLBubble@ [special (id-hook Bubble (1 -1)
                                                  op-hook qidListSymbol (__ : QidList Qid List ~> QidList)
                                                  op-hook qidSymbol (<Qids> : ~> Qid)
                                                  id-hook Exclude (:=))] . 
  op rcbubble : QidList -> @RCBubble@ [special (id-hook Bubble (1 -1)
                                                op-hook qidListSymbol (__ : QidList QidList ~> QidList)
                                                op-hook qidSymbol (<Qids> : ~> Qid)
                                                id-hook Exclude (if))] .
  op rbubble : QidList -> @RBubble@ [special (id-hook Bubble (1 -1)
                                              op-hook qidListSymbol (__ : QidList QidList ~> QidList)
                                              op-hook qidSymbol (<Qids> : ~> Qid)
                                              id-hook Exclude (.))] .
endfm

fmod FM-EXTENDED-SORTS is
  including BUBBLES .
  ---- Any modification in this module must be reflected in the metamodule
  ---- used in eq addInfoConds in module UNIT-BUBBLE-PARSING
  sorts ---- @SortToken@ @ViewToken@ 
        @Sort@ @Kind@ @Type@ @SortList@
        @TypeList@ @ViewExpression@ @ModExp@ .

  subsorts @SortToken@ < @Sort@ < @SortList@ < @TypeList@ .
  subsorts @Sort@ @Kind@ < @Type@ < @TypeList@ .
  subsort @ViewToken@ < @ViewExpression@ .

  op _`{_`} : @Sort@ @ViewExpression@ -> @Sort@ [prec 40] .
  op __ : @SortList@ @SortList@ -> @SortList@ [assoc] .
  op __ : @TypeList@ @TypeList@ -> @TypeList@ [assoc] .
  op `[_`] : @Sort@ -> @Kind@ .

  op _`,_ : @ViewExpression@ @ViewExpression@ -> @ViewExpression@ [assoc] .
  op _`{_`} : @ViewExpression@ @ViewExpression@ -> @ViewExpression@ [prec 40] .
endfm

-------------------------------------------------------------------------------
******************************************************************************
-------------------------------------------------------------------------------

fmod FM-OPERATOR-ATTRIBUTES is
  including BUBBLES .
  sorts @Attr@ @AttrList@ @Hook@ @HookList@ 
         ---- @Bubble@ @UBubble@ @StBubble@
         ---- @EqLBubble@ @RlLBubble@ @SdLBubble@ @RCBubble@ @RBubble@ @Token@ @NeTokenList@ 
         .
  subsort @Attr@ < @AttrList@ .
  subsort @Hook@ < @HookList@ .

  op __ : @AttrList@ @AttrList@ -> @AttrList@ [assoc] .
  ops assoc associative : -> @Attr@ .
  ops comm commutative : -> @Attr@ .
  ops idem idempotent : -> @Attr@ .
  ops id:_ identity:_ : @Bubble@ -> @Attr@ .
  ops left`id:_ left`identity:_ : @Bubble@ -> @Attr@ .
  ops right`id:_ right`identity:_ : @Bubble@ -> @Attr@ .
  ops frozen`(_`) poly`(_`) strat`(_`) strategy`(_`) :
        @NeTokenList@ -> @AttrList@ .
  ops memo memoization : -> @Attr@ .
  ops prec_ precedence_ : @Token@ -> @Attr@ .
  ops gather`(_`) gathering`(_`) : @NeTokenList@ -> @Attr@ .
  ops format`(_`) : @NeTokenList@ -> @Attr@ .
  ops ctor constructor : -> @Attr@ .
  ops frozen ditto iter : -> @Attr@ .
  ops object msg message config : -> @Attr@ .
  op metadata_ : @Token@ -> @Attr@ .

  op special`(_`) : @HookList@ -> @Attr@ .
  op __ : @HookList@ @HookList@ -> @HookList@ [assoc] .
  op id-hook_ : @Token@ -> @Hook@ .
  op id-hook_`(_`) : @Token@ @NeTokenList@ -> @Hook@ .
  op op-hook_`(_:_->_`) : @Token@ @Token@ @NeTokenList@ @Token@ -> @Hook@ .
  op op-hook_`(_:`->_`) : @Token@ @Token@ @Token@ -> @Hook@ .
  op op-hook_`(_:_~>_`) : @Token@ @Token@ @NeTokenList@ @Token@ -> @Hook@ .
  op op-hook_`(_:`~>_`) : @Token@ @Token@ @Token@ -> @Hook@ .
  op term-hook_`(_`) : @Token@ @Bubble@ -> @Hook@ .
endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod FM-MOD-EXPR is
  including FM-OPERATOR-ATTRIBUTES .
  including FM-EXTENDED-SORTS .

  sorts @Map@ @MapList@ .
  subsort @Map@ < @MapList@ .
  subsorts @Token@ < @ModExp@ .

  *** module expression
  op _*`(_`) : @ModExp@ @MapList@ -> @ModExp@ .
  op _`{_`} : @ModExp@ @ViewExpression@ -> @ModExp@ .
  op TUPLE`[_`] : @Token@ -> @ModExp@ .
  op POWER`[_`] : @Token@ -> @ModExp@ .
  op _+_ : @ModExp@ @ModExp@ -> @ModExp@ [assoc prec 42] .

  *** renaming maps
  op op_to_ : @Token@ @Token@ -> @Map@ .
  op op_:_->_to_ : @Token@ @TypeList@ @Type@ @Token@ -> @Map@ .
  op op_: ->_to_ : @Token@ @Type@ @Token@ -> @Map@ .
  op op_:_~>_to_ : @Token@ @TypeList@ @Type@ @Token@ -> @Map@ .
  op op_: ~>_to_ : @Token@ @Type@ @Token@ -> @Map@ .
  op op_to_`[_`] : @Token@ @Token@ @AttrList@ -> @Map@ .
  op op_:_->_to_`[_`] : @Token@ @TypeList@ @Type@ @Token@ @AttrList@ -> @Map@ .
  op op_:`->_to_`[_`] : @Token@ @Type@ @Token@ @AttrList@ -> @Map@ .
  op op_:_~>_to_`[_`] : @Token@ @TypeList@ @Type@ @Token@ @AttrList@ -> @Map@ .
  op op_:`~>_to_`[_`] : @Token@ @Type@ @Token@ @AttrList@ -> @Map@ .
  op sort_to_ : @Sort@ @Sort@ -> @Map@ .
  op label_to_ : @Token@ @Token@ -> @Map@ .
  op class_to_ : @Sort@ @Sort@ -> @Map@ .
  op attr_._to_ : @Sort@ @Token@ @Token@ -> @Map@ .
  op msg_to_ : @Token@ @Token@ -> @Map@ .
  op msg_:_->_to_ : @Token@ @TypeList@ @Type@ @Token@ -> @Map@ .
  op msg_:`->_to_ : @Token@ @Type@ @Token@ -> @Map@ .
  op strat_to_ : @Token@ @Token@ -> @Map@ .
  op strat_@_to_ : @Token@ @Type@ @Token@ -> @Map@ .
  op strat_:_@_to_ : @Token@ @TypeList@ @Type@ @Token@ -> @Map@ .

  op _`,_ : @MapList@ @MapList@ -> @MapList@ [assoc prec 42] .
endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod FM-SIGNATURE is
  inc FM-MOD-EXPR .

  sorts @SortDecl@ @SubsortRel@ @SubsortDecl@ @OpDecl@ .
  sorts @ClassDecl@ @AttrDecl@ @AttrDeclList@ @SubclassDecl@ @MsgDecl@
        @ODeclList@ .
  subsort @AttrDecl@ < @AttrDeclList@ .

  op `(_`) : @Token@ -> @Token@ .

  *** sort declaration
  op sorts_. : @SortList@ -> @SortDecl@ .
  op sort_. : @SortList@ -> @SortDecl@ .

  *** subsort declaration
  op subsort_. : @SubsortRel@ -> @SubsortDecl@ .
  op subsorts_. : @SubsortRel@ -> @SubsortDecl@ .
  op _<_ : @SortList@ @SortList@ -> @SubsortRel@ .
  op _<_ : @SortList@ @SubsortRel@ -> @SubsortRel@ .

  *** operator declaration
  op op_:`->_. : @Token@ @Type@ -> @OpDecl@ .
  op op_:`->_`[_`]. : @Token@ @Type@ @AttrList@ -> @OpDecl@ .
  op op_:_->_. : @Token@ @TypeList@ @Type@ -> @OpDecl@ .
  op op_:_->_`[_`]. : @Token@ @TypeList@ @Type@ @AttrList@ -> @OpDecl@ .
  op ops_:`->_. : @NeTokenList@ @Type@ -> @OpDecl@ .
  op ops_:`->_`[_`]. : @NeTokenList@ @Type@ @AttrList@ -> @OpDecl@ .
  op ops_:_->_. : @NeTokenList@ @TypeList@ @Type@ -> @OpDecl@ .
  op ops_:_->_`[_`]. : @NeTokenList@ @TypeList@ @Type@ @AttrList@ -> @OpDecl@ .

  op op_:`~>_. : @Token@ @Sort@ -> @OpDecl@ .
  op op_:`~>_`[_`]. : @Token@ @Sort@ @AttrList@ -> @OpDecl@ .
  op op_:_~>_. : @Token@ @TypeList@ @Sort@ -> @OpDecl@ .
  op op_:_~>_`[_`]. : @Token@ @TypeList@ @Sort@ @AttrList@ -> @OpDecl@ .
  op ops_:`~>_. : @NeTokenList@ @Sort@ -> @OpDecl@ .
  op ops_:`~>_`[_`]. : @NeTokenList@ @Sort@ @AttrList@ -> @OpDecl@ .
  op ops_:_~>_. : @NeTokenList@ @TypeList@ @Sort@ -> @OpDecl@ .
  op ops_:_~>_`[_`]. : @NeTokenList@ @TypeList@ @Sort@ @AttrList@ -> @OpDecl@ .

  *** class declaration
  op class_|_. : @Sort@ @AttrDeclList@ -> @ClassDecl@ .
  op class_|`. : @Sort@ -> @ClassDecl@ .
  op class_. : @Sort@ -> @ClassDecl@ .
  op _`,_ : @AttrDeclList@ @AttrDeclList@ -> @AttrDeclList@ [assoc] .
  op _:_ : @Token@ @Sort@ -> @AttrDecl@ [prec 40] .

  *** subclass declaration
  op subclass_. : @SubsortRel@ -> @SubclassDecl@ .
  op subclasses_. : @SubsortRel@ -> @SubclassDecl@ .

  *** message declaration
  op msg_:_->_. : @Token@ @SortList@ @Sort@ -> @MsgDecl@ .
  op msgs_:_->_. : @NeTokenList@ @SortList@ @Sort@ -> @MsgDecl@ .
  op msg_:`->_. : @Token@ @Sort@ -> @MsgDecl@ .
  op msgs_:`->_. : @NeTokenList@ @Sort@ -> @MsgDecl@ .

  *** strategy declarations
  op strat_@_. : @Token@ @Type@ -> @OpDecl@ .
  op strats_@_. : @NeTokenList@ @Type@ -> @OpDecl@ .
  op strat_@_`[_`]. : @Token@ @Type@ @AttrList@ -> @OpDecl@ .
  op strats_@_`[_`]. : @NeTokenList@ @Type@ @AttrList@ -> @OpDecl@ .
  op strat_:_@_. : @Token@ @TypeList@ @Type@ -> @OpDecl@ .
  op strats_:_@_. : @NeTokenList@ @TypeList@ @Type@ -> @OpDecl@ .
  op strat_:_@_`[_`]. : @Token@ @TypeList@ @Type@ @AttrList@ -> @OpDecl@ .
  op strats_:_@_`[_`]. : @NeTokenList@ @TypeList@ @Type@ @AttrList@ -> @OpDecl@ .

endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod FM-STATEMENTS is
  including FM-SIGNATURE .
  including QID-LIST .

  sorts @ImportDecl@ @EqDecl@ @RlDecl@ @StDecl@ @MbDecl@ @VarDecl@ .

  *** variable declaration
  op vars_:_. : @NeTokenList@ @Type@ -> @VarDecl@ .
  op var_:_. : @NeTokenList@ @Type@ -> @VarDecl@ .

  *** membership axiom declaration
  op mb_:_. : @RBubble@ @RBubble@ -> @MbDecl@ .
  op cmb_:_if_. : @RBubble@ @Sort@ @RBubble@ -> @MbDecl@ .

  *** equation declaration
  op eq_=_. : @EqLBubble@ @RBubble@ -> @EqDecl@ .
  op ceq_=_if_. : @EqLBubble@ @RCBubble@ @RBubble@ -> @EqDecl@ .
  op cq_=_if_. : @EqLBubble@ @RCBubble@ @RBubble@ -> @EqDecl@ .

  *** rule declaration
  op rl_=>_. : @RlLBubble@ @RBubble@ -> @RlDecl@ .
  op crl_=>_if_. : @RlLBubble@ @RCBubble@ @RBubble@ -> @RlDecl@ .

  *** importation declaration
  ops including_. inc_. : @ModExp@ -> @ImportDecl@ .
  ops extending_. ex_. : @ModExp@ -> @ImportDecl@ .
  ops protecting_. pr_. : @ModExp@ -> @ImportDecl@ .

  *** strat statement
  op sd_:=_. : @SdLBubble@ @RBubble@ -> @StDecl@ .
  op csd_:=_if_. : @SdLBubble@ @RCBubble@ @RBubble@ -> @StDecl@ .
endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod FM-MODULES is
  including FM-STATEMENTS .

  sorts @DeclList@ @Module@ @Parameter@ @List<Parameter>@ .
  sorts @Interface@ .
  subsorts @VarDecl@ @ImportDecl@ @SortDecl@ @SubsortDecl@ @OpDecl@ @MbDecl@
           @EqDecl@
           @RlDecl@
           @StDecl@
           @MsgDecl@ @SubclassDecl@ @ClassDecl@ < @DeclList@ .
  subsort @Parameter@ < @List<Parameter>@ .
  subsorts @Token@ < @Interface@ .

  *** declaration list
  op __ : @DeclList@ @DeclList@ -> @DeclList@ [assoc] .
  op __ : @VarDecl@ @VarDecl@ -> @VarDecl@ [assoc] .

  *** parameterized module interface
  op _::_ : @Token@ @ModExp@ -> @Parameter@ [prec 40 gather (e &)] .
  op _::_ : @Token@ @Interface@ -> @Parameter@ [prec 40 gather (e &)] .

  op _`,_ : @List<Parameter>@ @List<Parameter>@ -> @List<Parameter>@ [assoc] .

  op _`{_`} : @ModExp@ @List<Parameter>@ -> @Interface@ .

  *** modules and theories
  op fmod_is_endfm : @Interface@ @DeclList@ -> @Module@ .
  op obj_is_jbo : @Interface@ @DeclList@ -> @Module@ .
  op obj_is_endo : @Interface@ @DeclList@ -> @Module@ .
  op mod_is_endm : @Interface@ @DeclList@ -> @Module@ .
  op omod_is_endom : @Interface@ @DeclList@ -> @Module@ .
  op smod_is_endsm : @Interface@ @DeclList@ -> @Module@ .
  op fth_is_endfth : @Interface@ @DeclList@ -> @Module@ .
  op th_is_endth : @Interface@ @DeclList@ -> @Module@ .
  op oth_is_endoth : @Interface@ @DeclList@ -> @Module@ .
  op sth_is_endsth : @Interface@ @DeclList@ -> @Module@ .
endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod FM-VIEWS is
  including FM-MODULES .

  sorts @ViewDecl@ @ViewDeclList@ @View@ .
  subsorts @VarDecl@ < @ViewDecl@ < @ViewDeclList@ .

  *** view maps
  op op_to`term_. : @Bubble@ @Bubble@ -> @ViewDecl@ .
  op op_to_. : @Token@ @Token@ -> @ViewDecl@ .
  op op_:_->_to_. : @Token@ @TypeList@ @Type@ @Token@ -> @ViewDecl@ .
  op op_:`->_to_. : @Token@ @Type@ @Token@ -> @ViewDecl@ .
  op op_:_~>_to_. : @Token@ @TypeList@ @Type@ @Token@ -> @ViewDecl@ .
  op op_:`~>_to_. : @Token@ @Type@ @Token@ -> @ViewDecl@ .
  op sort_to_. : @Sort@ @Sort@ -> @ViewDecl@ .
  op class_to_. : @Sort@ @Sort@ -> @ViewDecl@ .
  op attr_._to_. : @Sort@ @Token@ @Token@ -> @ViewDecl@ .
  op msg_to_. : @Token@ @Token@ -> @ViewDecl@ .
  op msg_:_->_to_. : @Token@ @TypeList@ @Type@ @Token@ -> @ViewDecl@ .
  op msg_:`->_to_. : @Token@ @Type@ @Token@ -> @ViewDecl@ .
  op strat_to_. : @Token@ @Token@ -> @ViewDecl@ .
  op strat_@_to_. : @Token@ @Type@ @Token@ -> @ViewDecl@ .
  op strat_:_@_to_. : @Token@ @TypeList@ @Type@ @Token@ -> @ViewDecl@ .
  op strat_to expr_. : @Bubble@ @Bubble@ -> @ViewDecl@ .

  *** view
  op view_from_to_is_endv : @Interface@ @ModExp@ @ModExp@ @ViewDeclList@ -> @View@ .
  op view_from_to_is endv : @Interface@ @ModExp@ @ModExp@ -> @View@ .
  op __ : @ViewDeclList@ @ViewDeclList@ -> @ViewDeclList@ [assoc] .
endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod FM-COMMANDS is
  including FM-MOD-EXPR .

  sorts @Command@ .

  *** down function
  op down_:_ : @ModExp@ @Command@ -> @Command@ .

  *** parse commands
  op parse_. : @Bubble@ -> @Command@ .

  *** reduce commands
  op red_. : @UBubble@ -> @Command@ .
  op reduce_. : @UBubble@ -> @Command@ .

  *** rewrite commands
  op rew_. : @UBubble@ -> @Command@ .
  op rewrite_. : @UBubble@ -> @Command@ .

  *** frewrite commands
  op frew_. : @UBubble@ -> @Command@ .
  op frewrite_. : @UBubble@ -> @Command@ .

  *** srewrite commands
  op srew_. : @UBubble@ -> @Command@ .
  op dsrew_. : @UBubble@ -> @Command@ .
  op srewrite_. : @UBubble@ -> @Command@ .
  op dsrewrite_. : @UBubble@ -> @Command@ .

  *** search commands
  op search_=>1_. : @UBubble@ @UBubble@ -> @Command@ .
  op search_=>*_. : @UBubble@ @UBubble@ -> @Command@ .
  op search_=>+_. : @UBubble@ @UBubble@ -> @Command@ .
  op search_=>!_. : @UBubble@ @UBubble@ -> @Command@ .

  *** narrowing search commands
  op vu-narrow_=>1_. : @UBubble@ @UBubble@ -> @Command@ .
  op vu-narrow_=>*_. : @UBubble@ @UBubble@ -> @Command@ .
  op vu-narrow_=>+_. : @UBubble@ @UBubble@ -> @Command@ .
  op vu-narrow_=>!_. : @UBubble@ @UBubble@ -> @Command@ .

  op fvu-narrow_=>1_. : @UBubble@ @UBubble@ -> @Command@ .
  op fvu-narrow_=>*_. : @UBubble@ @UBubble@ -> @Command@ .
  op fvu-narrow_=>+_. : @UBubble@ @UBubble@ -> @Command@ .
  op fvu-narrow_=>!_. : @UBubble@ @UBubble@ -> @Command@ .

  op search_~>1_. : @UBubble@ @UBubble@ -> @Command@ .
  op search_~>*_. : @UBubble@ @UBubble@ -> @Command@ .
  op search_~>+_. : @UBubble@ @UBubble@ -> @Command@ .
  op search_~>!_. : @UBubble@ @UBubble@ -> @Command@ .

  *** matching commands
  op match_<=?_. : @UBubble@ @UBubble@ -> @Command@ .
  op xmatch_<=?_. : @UBubble@ @UBubble@ -> @Command@ .

  *** unifying command
  op unify_. : @UBubble@ -> @Command@ .

  *** unifying command
  op id-unify_. : @UBubble@ -> @Command@ .

  *** unifying command
  op variant`unify_. : @UBubble@ -> @Command@ .

  *** unifying command
  op asymmetric`variant`unify_. : @UBubble@ -> @Command@ .

  *** unifying command
  op get`variants_. : @UBubble@ -> @Command@ .

  *** select command
  op select_. : @ModExp@ -> @Command@ .

  *** show commands
  op show`module`. : -> @Command@ .
  op show`module_. : @ModExp@ -> @Command@ .
  op show`all`. : -> @Command@ .
  op show`all_. : @ModExp@ -> @Command@ .
  op show`vars`. : -> @Command@ .
  op show`vars_. : @ModExp@ -> @Command@ .
  op show`sorts`. : -> @Command@ .
  op show`sorts_. : @ModExp@ -> @Command@ .
  op show`ops`. : -> @Command@ .
  op show`ops_. : @ModExp@ -> @Command@ .
  op show`mbs`. : -> @Command@ .
  op show`mbs_. : @ModExp@ -> @Command@ .
  op show`eqs`. : -> @Command@ .
  op show`eqs_. : @ModExp@ -> @Command@ .
  op show`rls`. : -> @Command@ .
  op show`rls_. : @ModExp@ -> @Command@ .
  op show`view_. : @ViewExpression@ -> @Command@ .
  op show`modules`. : -> @Command@ .
  op show`views`. : -> @Command@ .

  *** set commands
  op set`protect_on`. : @ModExp@ -> @Command@ .
  op set`protect_off`. : @ModExp@ -> @Command@ .
  op set`include_on`. : @ModExp@ -> @Command@ .
  op set`include_off`. : @ModExp@ -> @Command@ .
  op set`extend_on`. : @ModExp@ -> @Command@ .
  op set`extend_off`. : @ModExp@ -> @Command@ .

  *** miscellaneous
  op load_. : @UBubble@ -> @Command@ .
  ops remove`identity`attributes`. rm`ids`. : -> @Command@ .
  ops remove`identity`attributes_. rm`ids_. : @ModExp@ -> @Command@ .
  op remove`assoc`attributes`. : -> @Command@ .
  op remove`assoc`attributes_. : @ModExp@ -> @Command@ .
  op ax`coherence`completion`. : -> @Command@ .
  op ax`coherence`completion_. : @ModExp@ -> @Command@ .
  op help`. : -> @Command@ .
endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod FULL-MAUDE-SIGN is
  including FM-VIEWS .
  including FM-COMMANDS .
  including BUBBLES .

  sort @Input@ .
  subsorts @Command@ @Module@ @View@ < @Input@ .
endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod FM-STRATEGY-GRAMMAR is
  *** strategies
    sorts @Strategy@ @UsingPair@ @UsingPairSet@ @StBubble@ @StCondBubble@
          @Token@ @TermList@ @CallStrategy@ .
    subsort @UsingPair@ < @UsingPairSet@ .
----    sorts RuleApplication CallStrategy @Strategy@ StrategyList .
----    subsort RuleApplication CallStrategy < Strategy < StrategyList .

  *** basic operators
    ops fail idle all : -> @Strategy@ .
----    op _[_]{_} : Qid Substitution StrategyList -> RuleApplication [ctor prec 21] .
----    op top : RuleApplication -> Strategy [ctor] .
    op match_s.t._ : @StBubble@ @StCondBubble@ -> @Strategy@ [prec 21] .
    op xmatch_s.t._ : @StBubble@ @StCondBubble@ -> @Strategy@ [prec 21] .
    op amatch_s.t._ : @StBubble@ @StCondBubble@ -> @Strategy@ [prec 21] .
----    op _|_ : Strategy Strategy -> Strategy [ctor assoc comm id: fail prec 41 gather (e E)] .
----    op _;_ : Strategy Strategy -> Strategy [ctor assoc id: idle prec 39 gather (e E)] .
----    op _or-else_ : Strategy Strategy -> Strategy [ctor assoc prec 43 gather (e E)] .
----    op _+ : Strategy -> Strategy [ctor] .
----    op _?_:_ : Strategy Strategy Strategy -> Strategy [ctor prec 55] .
----    op matchrew_s.t._by_ : @StBubble@ EqCondition UsingPairSet -> Strategy [ctor] .
----    op xmatchrew_s.t._by_ : @StBubble@ EqCondition UsingPairSet -> Strategy [ctor] .
----    op amatchrew_s.t._by_ : @StBubble@ EqCondition UsingPairSet -> Strategy [ctor] .
    op _[[_]] : @Token@ @TermList@ -> @CallStrategy@ [ctor prec 21] .
----    op one : Strategy -> Strategy [ctor] .

  *** derived operators (defined as constructors)
----    op _* : Strategy -> Strategy [ctor] .
----    op _! : Strategy -> Strategy [ctor] .
----    op not : Strategy -> Strategy [ctor] .
----    op test : Strategy -> Strategy [ctor] .
----    op try : Strategy -> Strategy [ctor] .

  *** lists
----    op empty : -> StrategyList [ctor] .
----    op _,_ : StrategyList StrategyList -> StrategyList [ctor assoc id: empty] .
    op _using_ : @Token@ @Strategy@ -> @UsingPair@ [ctor prec 21] .
    op _,_ : @UsingPair@ @UsingPairSet@ -> @UsingPairSet@ [ctor assoc comm prec 61] .
----    eq U:UsingPair, U:UsingPair = U:UsingPair .
endfm


*******
******* ERROR HANDLING, by Peter Olveczky
*******

*** The following module defines a function which prints up to n characters
*** of a bubble, followed by the usual arrow <---*HERE* which points to the
*** erroneous token:

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod FM-PRINT-SYNTAX-ERROR is
---  protecting META-LEVEL + PRE-VARIANT .
  protecting META-LEVEL .
  protecting INT .

  var  QIL : QidList .
  var  Q : Qid .
  var  N : Nat .
  vars RP RP' : ResultPair .
  var  RP? : [ResultPair?] .
  vars Strat Strat' : Strategy .
  var  Strat? : [Strategy?] .

  op printN : Nat QidList -> QidList .  *** first N qid's in a qidList
  eq printN(N, nil) = nil .
  eq printN(0, QIL) = nil .
  eq printN(s N, Q QIL) = Q printN(N, QIL) .

  op removeFront : Nat QidList -> QidList .  *** removes first N qid's
  eq removeFront(N, nil) = nil .
  eq removeFront(0, QIL) = QIL .
  eq removeFront(s N, Q QIL) = removeFront(N, QIL) .

  op printSyntaxError : [ResultPair?] QidList -> QidList .
  eq printSyntaxError(noParse(N), QIL)
    = '\r 'Parse 'error 'in '\o '\s printN(N + 1, QIL) '\r '<---*HERE* '\o .
  eq printSyntaxError(ambiguity(RP, RP'), QIL)
    = '\r 'Ambiguous 'parsing 'for '\o '\s QIL '\o .
  eq printSyntaxError(RP?, QIL) = QIL [owise] .

  op printSyntaxError : [Strategy?] QidList -> QidList .
  eq printSyntaxError(noStratParse(N), QIL)
    = '\r 'Parse 'error 'in '\o '\s printN(N + 1, QIL) '\r '<---*HERE* '\o .
  eq printSyntaxError(ambiguity(Strat, Strat'), QIL)
    = '\r 'Ambiguous 'parsing 'for '\o '\s QIL '\o .
  eq printSyntaxError(Strat?, QIL) = QIL [owise] .
endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------
***
*** The Abstract Data Type \texttt{Module}
***
-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

*** In this section we present the abstract data type \texttt{Module}, which
*** can be seen as an extension of the predefined sort \texttt{Module} in
*** several ways. There are constructors for functional, system, and object-
*** oriented modules and theories, which can be parameterized and can import
*** module expressions. There can also be parameterized sorts in Full Maude
*** modules, and therefore, the constructors for the different declarations
*** that can appear in a module have to be appropriately extended.

*** The section is structured as follows. After introducing some modules
*** defining some functions on the predefined sorts \texttt{Bool} and
*** \texttt{QidList} in Section~\ref{BOOL-QID-LIST}, we present in
*** Sections~\ref{EXT-SORT} and~\ref{EXT-DECL} the data types for extended
*** sorts and extended declarations. In Section~\ref{mod-exp-mod-id} we
*** introduce module expressions and module names, and in
*** Section~\ref{unitADT} the abstract data type \texttt{Module} itself.


fmod FM-HELP is
  pr FM-EXT-QID-LIST .
  op fm-help : -> QidList .
  eq fm-help
    = string2qidList("Additional commands available:") '\n
      '\t string2qidList("(load <meta-module> .)") '\n
      '\t '\t string2qidList("Takes as argument a term of sort Module,") '\s string2qidList("i.e.,") '\s string2qidList("a metaterm.") '\n
      '\t '`( 'remove 'identity 'attributes '\s '`[ '<module-expr.> '`] '\s  '. '`) '\s  '| '\s '`( 'rm 'ids '\s '`[ '<module-expr.> '`] '\s  '. '`) '\n
      '\t '\t string2qidList("Shows the module with the id attributes removed using a variant-based transformation.") '\n
      '\t string2qidList("(remove assoc attributes") '\s string2qidList("[<module-expr.>]") '\s string2qidList(".)") '\n
      '\t '\t string2qidList("Shows the module with the assoc (if not with comm) attributes removed using a variant-based transformation.") '\n
      '\t string2qidList("(ax coherence completion") '\s string2qidList("[<module-expr.>]") '\s string2qidList(".)") '\n
      '\t '\t string2qidList("Shows the module resulting from completing for coherence for the different combinations of axioms.") '\n .
endfm


-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod DEFAULT-VALUE{X :: TRIV} is
  sort Default{X} .
  subsort X$Elt < Default{X} .
  op null : -> Default{X} .
endfm

view Term from TRIV to META-TERM is
  sort Elt to Term .
endv

**** The module FM-EXT-TERM extends META-LEVEL with definitions of several
**** operations that manipulate terms: definitions for positions and operations
**** to get the subterm of a given term at a given position, to replace the
**** subterm of a term at a given position by another term, to get all the
**** nonvariable positions in a term, to apply a substitution to a term, and to
**** get a copy of a term in which all the variables in it have been renamed.

fmod FM-EXT-TERM is
---  pr META-LEVEL + PRE-VARIANT .
  pr META-LEVEL .
  pr EXT-BOOL .
  pr FM-EXT-DECL .

  vars T T' : Term .
  vars F X : Qid .
  var  TL : TermList .
  var  N : Nat .
  vars NL NL' : NatList .
  vars V V' W : Variable .
  var  Subst : Substitution .
  vars C Ct : Constant .
  var  NTL : NeTermList .
  var  M : Module .
  var  Tp : Type .
  vars TpL TpL' : TypeList .
  vars AtS AtS' : AttrSet .
  var  ODS : OpDeclSet .
  var  Cd : Condition .
  var  S : Sort .

  **** vars returns the set of variables in a term
  op vars : Term -> QidSet .
  op vars : TermList -> QidSet .

  eq vars(V) = V .
  eq vars(C) = none .
  eq vars(F[TL]) = vars(TL) .
  eq vars(empty) = none .
  eq vars((T, TL)) = (vars(T) ; vars(TL)) .

  **** varlist returns the list of variables in a term
  op varlist : Term -> QidList .
  op varlist : TermList -> QidList .

  eq varlist(V) = V .
  eq varlist(C) = nil .
  eq varlist(F[TL]) = varlist(TL) .
  eq varlist(empty) = nil .
  eq varlist((T, TL)) = varlist(T) varlist(TL) .

  **** occurs? checks whether a variable name occurs in a term or not.
  op occurs? : Variable Term -> Bool .
  op occurs? : Variable TermList -> Bool .
  eq occurs?(V, V') = V == V' .
  eq occurs?(V, C) = false .
  eq occurs?(V, F[TL]) = occurs?(V, TL) .
  eq occurs?(V, (T, TL)) = occurs?(V, T) or-else  occurs?(V, TL) .

  **** occurrences checks whether a variable name occurs in a term or not.
  op occurrences : Variable Term -> Nat .
  op occurrences : Variable TermList -> Nat .
  eq occurrences(V, V') = if V == V' then 1 else 0 fi .
  eq occurrences(V, C) = 0 .
  eq occurrences(V, F[TL]) = occurrences(V, TL) .
  eq occurrences(V, (T, TL)) = occurrences(V, T) + occurrences(V, TL) .

  op frozen : Module Term Nat -> Bool .
  op frozen : Module OpDeclSet Qid TypeList Nat -> Bool .
  eq frozen(M, F[TL], N)
    = frozen(M, getOps(M), F, eLeastSort(M, TL), N) .

  ceq frozen(M, op F : TpL -> Tp [AtS] . ODS, F, TpL', N)
    = true
    if sameKind(M, TpL, TpL')
       /\ not ctor(M, op F : TpL -> Tp [AtS] . ODS, F, TpL') .
  ceq frozen(M, op F : TpL -> Tp [AtS] . ODS, F, TpL', N)
    = true
    if sameKind(M, TpL, TpL')
       /\ ctor(M, op F : TpL -> Tp [AtS] . ODS, F, TpL')
       /\ frozen(NL N NL') AtS' := AtS .
  eq frozen(M, ODS, F, TpL, N) = false [owise] .

  ---- ctor check whether the operator at the top is a constructor
  ---- in any of its overloadings
  op ctor : Module OpDeclSet Term -> Bool .
  op ctor : Module OpDeclSet Qid TypeList -> Bool .

  eq ctor(M, ODS, Ct) = ctor(M, ODS, Ct, nil) .
  eq ctor(M, ODS, F[TL]) = ctor(M, ODS, F, eLeastSort(M, TL)) .
  eq ctor(M, ODS, T) = false [owise] .

  ceq ctor(M, op F : TpL -> Tp [AtS] . ODS, F, TpL')
    = ctor in AtS or-else ctor(M, ODS, F, TpL')
    if sameKind(M, TpL, TpL') .
  eq ctor(M, ODS, F, TpL) = false [owise] .

**** The function \texttt{substitute} takes a term $t$ and a substitution
**** $\sigma$ and returns the term $t\sigma$.

  op substitute : Module Term Substitution -> Term .
  op substitute : Module TermList Substitution -> TermList .

  eq substitute(M, T, none) = T .
  eq substitute(M, V, ((W <- T) ; Subst))
    = if getName(V) == getName(W) and-then sameKind(M, getType(V), getType(W))
      then T
      else substitute(M, V, Subst)
      fi .
  eq substitute(M, C, ((W <- T); Subst)) = C .
  eq substitute(M, F[TL], Subst) = F[substitute(M, TL, Subst)] .
  eq substitute(M, (T, TL), Subst)
    = (substitute(M, T, Subst), substitute(M, TL, Subst)) .

  op substitute : Module EqCondition Substitution -> EqCondition .
  eq substitute(M, T = T' /\ Cd, Subst)
    = substitute(M, T, Subst) = substitute(M, T', Subst) /\ substitute(M, Cd, Subst) .
  eq substitute(M, T := T' /\ Cd, Subst)
    = substitute(M, T, Subst) := substitute(M, T', Subst) /\ substitute(M, Cd, Subst) .
  eq substitute(M, T : S /\ Cd, Subst)
    = substitute(M, T, Subst) : S /\ substitute(M, Cd, Subst) .
  eq substitute(M, (nil).EqCondition, Subst) = nil .
endfm

***(
red substitute('f['X:Foo, 'g['Y:Foo, 'Z:Foo]], ('Y:Foo <- 'h['W:Foo])) .
red rename('f['X:Foo, 'g['Y:Foo, 'Z:Foo]]) .
red allNonVarPos(
      substitute('f['X:Foo, 'g['Y:Foo, 'Z:Foo]], ('Y:Foo <- 'h['W:Foo]))) .
)

fmod FM-PARSE-STRATEGY is
---  including META-LEVEL + PRE-VARIANT .
  including META-LEVEL .
  including FM-UNIT .

  op STRAT-BUBBLES : -> FModule .
  op STRAT-GRAMMAR : -> FModule [memo] .

  eq STRAT-BUBBLES
    = (fmod 'GRAMMAR is
        including 'QID-LIST .
        sorts none .
        none
        op 'token : 'Qid -> '@Token@
             [special(
               (id-hook('Bubble, '1 '1)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)))] .
        op 'stbubble : 'QidList -> '@StBubble@
             [special(
               (id-hook('Bubble, '1 '-1 '`( '`))
                op-hook('qidListSymbol, '__, 'QidList 'QidList, 'QidList)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)
                id-hook('Exclude, 's.t.)))] .
        none
        none
     endfm) .

  eq STRAT-GRAMMAR = addImports((including 'FULL-MAUDE-SIGN .), STRAT-BUBBLES) .

----  op metaParseStrategy : Module QidSet QidList ~> Strategy? .
----  op metaPrettyPrintStrategy : Module Strategy PrintOptionSet ~> QidList .

endfm

-------------------------------------------------------------------------------

fmod AX-COHERENCE-COMPLETION is
  inc FM-UNIT .
----  inc FM-MODULE-HANDLING * (op addOps to addOpsSE, op addEqs to addEqsSE, op addSorts to addSortsSE) .

  vars V W : Variable .
  var  C : Constant .
  var  FM : FModule .
  var  SM : SModule .
  var  M : Module .
  var  N : Nat .
  vars T T' T'' LHS RHS : Term .
  vars Subst Subst' : Substitution .
  var  F : Qid .
  var  TL : TermList .
  vars AtS AtS' : AttrSet .
----  var  VFS : VariantFourSet .
  vars Tp Tp' Tp'' : Type .
  var  TpL : TypeList .
  var  Rl : Rule .
  var  RlS : RuleSet .
  var  Eq : Equation .
  var  EqS : EquationSet .
  var  ODS : OpDeclSet .
  var  Cond : Condition .
  var  QIL : QidList .

  ------------------------------------------------------------------------------
  ---- coherence completion
  ------------------------------------------------------------------------------

  op axCohComplete : SModule -> SModule .
  op axCohComplete : SModule OpDeclSet RuleSet -> RuleSet .
  op axCohCompleteAux : SModule OpDeclSet RuleSet -> RuleSet .
  op axCohComplete : SModule Type AttrSet Rule -> RuleSet .
  op axCohComplete : SModule OpDeclSet EquationSet -> EquationSet .
  op axCohCompleteAux : SModule OpDeclSet EquationSet -> EquationSet .
  op axCohComplete : SModule Type AttrSet Equation -> EquationSet .

  eq axCohComplete(FM)
    = moreGeneralEqs(setEqs(FM, axCohComplete(FM, getOps(FM), getEqs(FM)))) .
  eq axCohComplete(SM)
    = moreGeneralEqs(
        moreGeneralRls(
          setRls(
            setEqs(SM,
              axCohComplete(SM, getOps(SM), getEqs(SM))),
            axCohComplete(SM, getOps(SM), getRls(SM)))))
    [owise] .
  eq axCohComplete(unitError(QIL)) = unitError(QIL) .

  ceq axCohComplete(M, op F : Tp Tp' -> Tp'' [assoc AtS] . ODS, rl F[TL] => RHS [AtS'] . RlS)
    = axCohComplete(M, Tp, assoc AtS, rl F[TL] => RHS [AtS'] .)
      axCohComplete(M, op F : Tp Tp' -> Tp'' [assoc AtS] . ODS, RlS)
    if sameKindAll(M, Tp, eLeastSort(M, TL)) .
  ceq axCohComplete(M, op F : Tp Tp' -> Tp'' [assoc AtS] . ODS, crl F[TL] => RHS if Cond [AtS'] . RlS)
    = axCohComplete(M, Tp, assoc AtS, crl F[TL] => RHS if Cond [AtS'] .)
      axCohComplete(M, op F : Tp Tp' -> Tp'' [assoc AtS] . ODS, RlS)
    if sameKindAll(M, Tp, eLeastSort(M, TL)) .
  eq axCohComplete(M, ODS, RlS) = axCohCompleteAux(M, ODS, RlS) [owise] .

  ceq axCohCompleteAux(M, op F : Tp Tp' -> Tp'' [assoc id(T) AtS] . ODS, rl LHS => RHS [AtS'] . RlS)
    = axCohComplete(M, Tp, assoc id(T) AtS, rl F[LHS] => RHS [AtS'] .)
      axCohCompleteAux(M, op F : Tp Tp' -> Tp'' [assoc id(T) AtS] . ODS, RlS)
    if sameKindAll(M, Tp, leastSort(M, LHS)) .
  ceq axCohCompleteAux(M, op F : Tp Tp' -> Tp'' [assoc id(T) AtS] . ODS, crl LHS => RHS if Cond [AtS'] . RlS)
    = axCohComplete(M, Tp, assoc id(T) AtS, crl F[LHS] => RHS if Cond [AtS'] .)
      axCohCompleteAux(M, op F : Tp Tp' -> Tp'' [assoc id(T) AtS] . ODS, RlS)
    if sameKindAll(M, Tp, leastSort(M, LHS)) .
  ceq axCohCompleteAux(M, op F : Tp Tp' -> Tp'' [assoc left-id(T) AtS] . ODS, rl LHS => RHS [AtS'] . RlS)
    = axCohComplete(M, Tp, assoc left-id(T) AtS, rl F[LHS] => RHS [AtS'] .)
      axCohCompleteAux(M, op F : Tp Tp' -> Tp'' [assoc left-id(T) AtS] . ODS, RlS)
    if sameKindAll(M, Tp, leastSort(M, LHS)) .
  ceq axCohCompleteAux(M, op F : Tp Tp' -> Tp'' [assoc left-id(T) AtS] . ODS, crl LHS => RHS if Cond [AtS'] . RlS)
    = axCohComplete(M, Tp, assoc left-id(T) AtS, crl F[LHS] => RHS if Cond [AtS'] .)
      axCohCompleteAux(M, op F : Tp Tp' -> Tp'' [assoc left-id(T) AtS] . ODS, RlS)
    if sameKindAll(M, Tp, leastSort(M, LHS)) .
  ceq axCohCompleteAux(M, op F : Tp Tp' -> Tp'' [assoc right-id(T) AtS] . ODS, rl LHS => RHS [AtS'] . RlS)
    = axCohComplete(M, Tp, assoc right-id(T) AtS, rl F[LHS] => RHS [AtS'] .)
      axCohCompleteAux(M, op F : Tp Tp' -> Tp'' [assoc right-id(T) AtS] . ODS, RlS)
    if sameKindAll(M, Tp, leastSort(M, LHS)) .
  ceq axCohCompleteAux(M, op F : Tp Tp' -> Tp'' [assoc right-id(T) AtS] . ODS, crl LHS => RHS if Cond [AtS'] . RlS)
    = axCohComplete(M, Tp, assoc right-id(T) AtS, crl F[LHS] => RHS if Cond [AtS'] .)
      axCohCompleteAux(M, op F : Tp Tp' -> Tp'' [assoc right-id(T) AtS] . ODS, RlS)
    if sameKindAll(M, Tp, leastSort(M, LHS)) .
  eq axCohCompleteAux(M, ODS, RlS) = RlS [owise] .

  ceq axCohComplete(M, op F : Tp Tp' -> Tp'' [assoc AtS] . ODS, eq F[TL] = RHS [AtS'] . EqS)
    = axCohComplete(M, Tp, assoc AtS, eq F[TL] = RHS [AtS'] .)
      axCohComplete(M, op F : Tp Tp' -> Tp'' [assoc AtS] . ODS, EqS)
    if sameKindAll(M, Tp, eLeastSort(M, TL)) .
  ceq axCohComplete(M, op F : Tp Tp' -> Tp'' [assoc AtS] . ODS, ceq F[TL] = RHS if Cond [AtS'] . EqS)
    = axCohComplete(M, Tp, assoc AtS, ceq F[TL] = RHS if Cond [AtS'] .)
      axCohComplete(M, op F : Tp Tp' -> Tp'' [assoc AtS] . ODS, EqS)
    if sameKindAll(M, Tp, eLeastSort(M, TL)) .
  eq axCohComplete(M, ODS, EqS) = axCohCompleteAux(M, ODS, EqS) [owise] .

  ceq axCohCompleteAux(M, op F : Tp Tp' -> Tp'' [assoc id(T) AtS] . ODS, eq LHS = RHS [AtS'] . EqS)
    = axCohComplete(M, Tp, assoc id(T) AtS, eq F[LHS] = RHS [AtS'] .)
      axCohCompleteAux(M, op F : Tp Tp' -> Tp'' [assoc id(T) AtS] . ODS, EqS)
    if sameKindAll(M, Tp, leastSort(M, LHS)) .
  ceq axCohCompleteAux(M, op F : Tp Tp' -> Tp'' [assoc id(T) AtS] . ODS, ceq LHS = RHS if Cond [AtS'] . EqS)
    = axCohComplete(M, Tp, assoc id(T) AtS, ceq F[LHS] = RHS if Cond [AtS'] .)
      axCohCompleteAux(M, op F : Tp Tp' -> Tp'' [assoc id(T) AtS] . ODS, EqS)
    if sameKindAll(M, Tp, leastSort(M, LHS)) .
  ceq axCohCompleteAux(M, op F : Tp Tp' -> Tp'' [assoc left-id(T) AtS] . ODS, eq LHS = RHS [AtS'] . EqS)
    = axCohComplete(M, Tp, assoc left-id(T) AtS, eq F[LHS] = RHS [AtS'] .)
      axCohCompleteAux(M, op F : Tp Tp' -> Tp'' [assoc left-id(T) AtS] . ODS, EqS)
    if sameKindAll(M, Tp, leastSort(M, LHS)) .
  ceq axCohCompleteAux(M, op F : Tp Tp' -> Tp'' [assoc left-id(T) AtS] . ODS, ceq LHS = RHS if Cond [AtS'] . EqS)
    = axCohComplete(M, Tp, assoc left-id(T) AtS, ceq F[LHS] = RHS if Cond [AtS'] .)
      axCohCompleteAux(M, op F : Tp Tp' -> Tp'' [assoc left-id(T) AtS] . ODS, EqS)
    if sameKindAll(M, Tp, leastSort(M, LHS)) .
  ceq axCohCompleteAux(M, op F : Tp Tp' -> Tp'' [assoc right-id(T) AtS] . ODS, eq LHS = RHS [AtS'] . EqS)
    = axCohComplete(M, Tp, assoc right-id(T) AtS, eq F[LHS] = RHS [AtS'] .)
      axCohCompleteAux(M, op F : Tp Tp' -> Tp'' [assoc right-id(T) AtS] . ODS, EqS)
    if sameKindAll(M, Tp, leastSort(M, LHS)) .
  ceq axCohCompleteAux(M, op F : Tp Tp' -> Tp'' [assoc right-id(T) AtS] . ODS, ceq LHS = RHS if Cond [AtS'] . EqS)
    = axCohComplete(M, Tp, assoc right-id(T) AtS, ceq F[LHS] = RHS if Cond [AtS'] .)
      axCohCompleteAux(M, op F : Tp Tp' -> Tp'' [assoc right-id(T) AtS] . ODS, EqS)
    if sameKindAll(M, Tp, leastSort(M, LHS)) .
  eq axCohCompleteAux(M, ODS, EqS) = EqS [owise] .

  ceq axCohComplete(M, op F : Tp Tp' -> Tp'' [assoc AtS] . ODS, eq F[TL] = RHS [AtS'] . EqS)
    = axCohComplete(M, Tp, assoc AtS, eq F[TL] = RHS [AtS'] .)
      axCohComplete(M, op F : Tp Tp' -> Tp'' [assoc AtS] . ODS, EqS)
    if sameKind(M, Tp, Tp')
    /\ sameKind(M, Tp', Tp'')
    /\ sameKindAll(M, Tp, eLeastSort(M, TL)) .
  ceq axCohComplete(M, op F : Tp Tp' -> Tp'' [assoc AtS] . ODS, ceq F[TL] = RHS if Cond [AtS'] . EqS)
    = axCohComplete(M, Tp, assoc AtS, ceq F[TL] = RHS if Cond [AtS'] .)
      axCohComplete(M, op F : Tp Tp' -> Tp'' [assoc AtS] . ODS, EqS)
    if sameKind(M, Tp, Tp')
    /\ sameKind(M, Tp', Tp'')
    /\ sameKindAll(M, Tp, eLeastSort(M, TL)) .
  eq axCohComplete(M, ODS, eq LHS = RHS [AtS] . EqS)
    = eq LHS = RHS [AtS] . axCohComplete(M, ODS, EqS)
    [owise] .
  eq axCohComplete(M, ODS, ceq LHS = RHS if Cond [AtS] . EqS)
    = ceq LHS = RHS if Cond [AtS] . axCohComplete(M, ODS, EqS)
    [owise] .
  eq axCohComplete(M, ODS, (none).EquationSet) = none .

  ---- Given f(t1,...,tn) -> r if C
  ---- if f AC add f(t1,...,tn,x:[s]) -> f(r,x:[s]) if C
  eq axCohComplete(M, Tp, assoc comm AtS, rl F[TL] => RHS [AtS'] .)
    = (rl F[TL] => RHS [AtS'] .)
      (rl F[TL, qid("X@@@:" + string(getKind(M, Tp)))] => getTerm(metaNormalize(M, F[RHS, qid("X@@@:" + string(getKind(M, Tp)))])) [AtS'] .)
    [owise] .
  eq axCohComplete(M, Tp, assoc comm AtS, crl F[TL] => RHS if Cond [AtS'] .)
    = (crl F[TL] => RHS if Cond [AtS'] .)
      (crl F[TL, qid("X@@@:" + string(getKind(M, Tp)))] => getTerm(metaNormalize(M, F[RHS, qid("X@@@:" + string(getKind(M, Tp)))])) if Cond [AtS'] .)
    [owise] .
  ---- if f ACU replace by f(t1,...,tn,x:[s]) -> f(r,x:[s]) if C
  eq axCohComplete(M, Tp, assoc comm id(T) AtS, rl F[TL] => RHS [AtS'] .)
    = (rl F[TL, qid("X@@@:" + string(getKind(M, Tp)))] => getTerm(metaNormalize(M, F[RHS, qid("X@@@:" + string(getKind(M, Tp)))])) [AtS'] .) .
  eq axCohComplete(M, Tp, assoc comm id(T) AtS, crl F[TL] => RHS if Cond [AtS'] .)
    = (crl F[TL, qid("X@@@:" + string(getKind(M, Tp)))] => getTerm(metaNormalize(M, F[RHS, qid("X@@@:" + string(getKind(M, Tp)))])) if Cond [AtS'] .) .
  ---- if f AU replace by f(x:[s],t1,...,tn,y:[s]) -> f(x:[s],r,y:[s]) if C
  ceq axCohComplete(M, Tp, assoc id(T) AtS, rl F[TL] => RHS [AtS'] .)
    = (rl F[qid("X@@@:" + string(getKind(M, Tp))), TL, qid("Y@@@:" + string(getKind(M, Tp)))]
         => getTerm(metaNormalize(M, F[qid("X@@@:" + string(getKind(M, Tp))), RHS, qid("Y@@@:" + string(getKind(M, Tp)))])) [AtS'] .)
    if not comm in AtS .
  ceq axCohComplete(M, Tp, assoc id(T) AtS, crl F[TL] => RHS if Cond [AtS'] .)
    = (crl F[qid("X@@@:" + string(getKind(M, Tp))), TL, qid("Y@@@:" + string(getKind(M, Tp)))]
         => getTerm(metaNormalize(M, F[qid("X@@@:" + string(getKind(M, Tp))), RHS, qid("Y@@@:" + string(getKind(M, Tp)))])) if Cond [AtS'] .)
    if not comm in AtS .
  ---- if f ALU replace by f(x:[s],t1,...,tn,y:[s]) -> f(x:[s],r,y:[s]) if C
  ----             and add f(x:[s],t1,...,tn) -> f(x:[s],r) if C
  eq axCohComplete(M, Tp, assoc left-id(T) AtS, rl F[TL] => RHS [AtS'] .)
    = (rl F[qid("X@@@:" + string(getKind(M, Tp))), TL, qid("Y@@@:" + string(getKind(M, Tp)))]
         => getTerm(metaNormalize(M, F[qid("X@@@:" + string(getKind(M, Tp))), RHS, qid("Y@@@:" + string(getKind(M, Tp)))])) [AtS'] .)
      (rl F[qid("X@@@:" + string(getKind(M, Tp))), TL]
         => getTerm(metaNormalize(M, F[qid("X@@@:" + string(getKind(M, Tp))), RHS])) [AtS'] .)  .
  eq axCohComplete(M, Tp, assoc left-id(T) AtS, crl F[TL] => RHS if Cond [AtS'] .)
    = (crl F[qid("X@@@:" + string(getKind(M, Tp))), TL, qid("Y@@@:" + string(getKind(M, Tp)))]
         => getTerm(metaNormalize(M, F[qid("X@@@:" + string(getKind(M, Tp))), RHS, qid("Y@@@:" + string(getKind(M, Tp)))])) if Cond [AtS'] .)
      (crl F[qid("X@@@:" + string(getKind(M, Tp))), TL]
         => getTerm(metaNormalize(M, F[qid("X@@@:" + string(getKind(M, Tp))), RHS])) if Cond [AtS'] .)  .
  ---- if f ARU replace by f(x:[s],t1,...,tn,y:[s]) -> f(x:[s],r,y:[s]) if C
  ----             and add f(t1,...,tn,y:[s]) -> f(r,y:[s]) if C
  eq axCohComplete(M, Tp, assoc right-id(T) AtS, rl F[TL] => RHS [AtS'] .)
    = (rl F[qid("X@@@:" + string(getKind(M, Tp))), TL, qid("Y@@@:" + string(getKind(M, Tp)))]
         => getTerm(metaNormalize(M, F[qid("X@@@:" + string(getKind(M, Tp))), RHS, qid("Y@@@:" + string(getKind(M, Tp)))])) [AtS'] .)
      (rl F[TL, qid("Y@@@:" + string(getKind(M, Tp)))]
         => getTerm(metaNormalize(M, F[RHS, qid("Y@@@:" + string(getKind(M, Tp)))])) [AtS'] .) .
  eq axCohComplete(M, Tp, assoc right-id(T) AtS, crl F[TL] => RHS if Cond [AtS'] .)
    = (crl F[qid("X@@@:" + string(getKind(M, Tp))), TL, qid("Y@@@:" + string(getKind(M, Tp)))]
         => getTerm(metaNormalize(M, F[qid("X@@@:" + string(getKind(M, Tp))), RHS, qid("Y@@@:" + string(getKind(M, Tp)))])) if Cond [AtS'] .)
      (crl F[TL, qid("Y@@@:" + string(getKind(M, Tp)))]
         => getTerm(metaNormalize(M, F[RHS, qid("Y@@@:" + string(getKind(M, Tp)))])) if Cond [AtS'] .) .
  ---- if f A add f(x:[s],t1,...,tn,y:[s]) -> f(x:[s],r,y:[s]) if C
  ----            f(x:[s],t1,...,tn) -> f(x:[s],r) if C
  ----            f(t1,...,tn,y:[s]) -> f(r,y:[s]) if C
  ceq axCohComplete(M, Tp, assoc AtS, rl F[TL] => RHS [AtS'] .)
    = (rl F[TL] => RHS [AtS'] .)
      (rl F[qid("X@@@:" + string(getKind(M, Tp))), TL, qid("Y@@@:" + string(getKind(M, Tp)))]
         => getTerm(metaNormalize(M, F[qid("X@@@:" + string(getKind(M, Tp))), RHS, qid("Y@@@:" + string(getKind(M, Tp)))])) [AtS'] .)
      (rl F[qid("X@@@:" + string(getKind(M, Tp))), TL]
         => getTerm(metaNormalize(M, F[qid("X@@@:" + string(getKind(M, Tp))), RHS])) [AtS'] .)
      (rl F[TL, qid("Y@@@:" + string(getKind(M, Tp)))]
         => getTerm(metaNormalize(M, F[RHS, qid("Y@@@:" + string(getKind(M, Tp)))])) [AtS'] .)
    if not comm in AtS
    [owise] .
  ceq axCohComplete(M, Tp, assoc AtS, crl F[TL] => RHS if Cond [AtS'] .)
    = (crl F[TL] => RHS if Cond [AtS'] .)
      (crl F[qid("X@@@:" + string(getKind(M, Tp))), TL, qid("Y@@@:" + string(getKind(M, Tp)))]
         => getTerm(metaNormalize(M, F[qid("X@@@:" + string(getKind(M, Tp))), RHS, qid("Y@@@:" + string(getKind(M, Tp)))])) if Cond [AtS'] .)
      (crl F[qid("X@@@:" + string(getKind(M, Tp))), TL]
         => getTerm(metaNormalize(M, F[qid("X@@@:" + string(getKind(M, Tp))), RHS])) if Cond [AtS'] .)
      (crl F[TL, qid("Y@@@:" + string(getKind(M, Tp)))]
         => getTerm(metaNormalize(M, F[RHS, qid("Y@@@:" + string(getKind(M, Tp)))])) if Cond [AtS'] .)
    if not comm in AtS
    [owise] .

  ---- Given f(t1,...,tn) -> r if C
  ---- if f AC add f(t1,...,tn,x:[s]) -> f(r,x:[s]) if C
  eq axCohComplete(M, Tp, assoc comm AtS, eq F[TL] = RHS [AtS'] .)
    = (eq F[TL] = RHS [AtS'] .)
      (eq F[TL, qid("X@@@:" + string(getKind(M, Tp)))] = getTerm(metaNormalize(M, F[RHS, qid("X@@@:" + string(getKind(M, Tp)))])) [AtS'] .)
    [owise] .
  eq axCohComplete(M, Tp, assoc comm AtS, ceq F[TL] = RHS if Cond [AtS'] .)
    = (ceq F[TL] = RHS if Cond [AtS'] .)
      (ceq F[TL, qid("X@@@:" + string(getKind(M, Tp)))] = getTerm(metaNormalize(M, F[RHS, qid("X@@@:" + string(getKind(M, Tp)))])) if Cond [AtS'] .)
    [owise] .
  ---- if f ACU replace by f(t1,...,tn,x:[s]) -> f(r,x:[s]) if C
  eq axCohComplete(M, Tp, assoc comm id(T) AtS, eq F[TL] = RHS [AtS'] .)
    = (eq F[TL, qid("X@@@:" + string(getKind(M, Tp)))] = getTerm(metaNormalize(M, F[RHS, qid("X@@@:" + string(getKind(M, Tp)))])) [AtS'] .) .
  eq axCohComplete(M, Tp, assoc comm id(T) AtS, ceq F[TL] = RHS if Cond [AtS'] .)
    = (ceq F[TL, qid("X@@@:" + string(getKind(M, Tp)))] = getTerm(metaNormalize(M, F[RHS, qid("X@@@:" + string(getKind(M, Tp)))])) if Cond [AtS'] .) .
  ---- if f AU replace by f(x:[s],t1,...,tn,y:[s]) -> f(x:[s],r,y:[s]) if C
  ceq axCohComplete(M, Tp, assoc id(T) AtS, eq F[TL] = RHS [AtS'] .)
    = (eq F[qid("X@@@:" + string(getKind(M, Tp))), TL, qid("Y@@@:" + string(getKind(M, Tp)))]
         = getTerm(metaNormalize(M, F[qid("X@@@:" + string(getKind(M, Tp))), RHS, qid("Y@@@:" + string(getKind(M, Tp)))])) [AtS'] .)
    if not comm in AtS .
  ceq axCohComplete(M, Tp, assoc id(T) AtS, ceq F[TL] = RHS if Cond [AtS'] .)
    = (ceq F[qid("X@@@:" + string(getKind(M, Tp))), TL, qid("Y@@@:" + string(getKind(M, Tp)))]
         = getTerm(metaNormalize(M, F[qid("X@@@:" + string(getKind(M, Tp))), RHS, qid("Y@@@:" + string(getKind(M, Tp)))])) if Cond [AtS'] .)
    if not comm in AtS .
  ---- if f ALU replace by f(x:[s],t1,...,tn,y:[s]) -> f(x:[s],r,y:[s]) if C
  ----             and add f(x:[s],t1,...,tn) -> f(x:[s],r) if C
  eq axCohComplete(M, Tp, assoc left-id(T) AtS, eq F[TL] = RHS [AtS'] .)
    = (eq F[qid("X@@@:" + string(getKind(M, Tp))), TL, qid("Y@@@:" + string(getKind(M, Tp)))]
         = getTerm(metaNormalize(M, F[qid("X@@@:" + string(getKind(M, Tp))), RHS, qid("Y@@@:" + string(getKind(M, Tp)))])) [AtS'] .)
      (eq F[qid("X@@@:" + string(getKind(M, Tp))), TL]
         = getTerm(metaNormalize(M, F[qid("X@@@:" + string(getKind(M, Tp))), RHS])) [AtS'] .)  .
  eq axCohComplete(M, Tp, assoc left-id(T) AtS, ceq F[TL] = RHS if Cond [AtS'] .)
    = (ceq F[qid("X@@@:" + string(getKind(M, Tp))), TL, qid("Y@@@:" + string(getKind(M, Tp)))]
         = getTerm(metaNormalize(M, F[qid("X@@@:" + string(getKind(M, Tp))), RHS, qid("Y@@@:" + string(getKind(M, Tp)))])) if Cond [AtS'] .)
      (ceq F[qid("X@@@:" + string(getKind(M, Tp))), TL]
         = getTerm(metaNormalize(M, F[qid("X@@@:" + string(getKind(M, Tp))), RHS])) if Cond [AtS'] .)  .
  ---- if f ARU replace by f(x:[s],t1,...,tn,y:[s]) -> f(x:[s],r,y:[s]) if C
  ----             and add f(t1,...,tn,y:[s]) -> f(r,y:[s]) if C
  eq axCohComplete(M, Tp, assoc right-id(T) AtS, eq F[TL] = RHS [AtS'] .)
    = (eq F[qid("X@@@:" + string(getKind(M, Tp))), TL, qid("Y@@@:" + string(getKind(M, Tp)))]
         = getTerm(metaNormalize(M, F[qid("X@@@:" + string(getKind(M, Tp))), RHS, qid("Y@@@:" + string(getKind(M, Tp)))])) [AtS'] .)
      (eq F[TL, qid("Y@@@:" + string(getKind(M, Tp)))]
         = getTerm(metaNormalize(M, F[RHS, qid("Y@@@:" + string(getKind(M, Tp)))])) [AtS'] .) .
  eq axCohComplete(M, Tp, assoc right-id(T) AtS, ceq F[TL] = RHS if Cond [AtS'] .)
    = (ceq F[qid("X@@@:" + string(getKind(M, Tp))), TL, qid("Y@@@:" + string(getKind(M, Tp)))]
         = getTerm(metaNormalize(M, F[qid("X@@@:" + string(getKind(M, Tp))), RHS, qid("Y@@@:" + string(getKind(M, Tp)))])) if Cond [AtS'] .)
      (ceq F[TL, qid("Y@@@:" + string(getKind(M, Tp)))]
         = getTerm(metaNormalize(M, F[RHS, qid("Y@@@:" + string(getKind(M, Tp)))])) if Cond [AtS'] .) .
  ---- if f A add f(x:[s],t1,...,tn,y:[s]) -> f(x:[s],r,y:[s]) if C
  ----            f(x:[s],t1,...,tn) -> f(x:[s],r) if C
  ----            f(t1,...,tn,y:[s]) -> f(r,y:[s]) if C
  ceq axCohComplete(M, Tp, assoc AtS, eq F[TL] = RHS [AtS'] .)
    = (eq F[TL] = RHS [AtS'] .)
      (eq F[qid("X@@@:" + string(getKind(M, Tp))), TL, qid("Y@@@:" + string(getKind(M, Tp)))]
         = getTerm(metaNormalize(M, F[qid("X@@@:" + string(getKind(M, Tp))), RHS, qid("Y@@@:" + string(getKind(M, Tp)))])) [AtS'] .)
      (eq F[qid("X@@@:" + string(getKind(M, Tp))), TL]
         = getTerm(metaNormalize(M, F[qid("X@@@:" + string(getKind(M, Tp))), RHS])) [AtS'] .)
      (eq F[TL, qid("Y@@@:" + string(getKind(M, Tp)))]
         = getTerm(metaNormalize(M, F[RHS, qid("Y@@@:" + string(getKind(M, Tp)))])) [AtS'] .)
    if not comm in AtS
    [owise] .
  ceq axCohComplete(M, Tp, assoc AtS, ceq F[TL] = RHS if Cond [AtS'] .)
    = (ceq F[TL] = RHS if Cond [AtS'] .)
      (ceq F[qid("X@@@:" + string(getKind(M, Tp))), TL, qid("Y@@@:" + string(getKind(M, Tp)))]
         = getTerm(metaNormalize(M, F[qid("X@@@:" + string(getKind(M, Tp))), RHS, qid("Y@@@:" + string(getKind(M, Tp)))])) if Cond [AtS'] .)
      (ceq F[qid("X@@@:" + string(getKind(M, Tp))), TL]
         = getTerm(metaNormalize(M, F[qid("X@@@:" + string(getKind(M, Tp))), RHS])) if Cond [AtS'] .)
      (ceq F[TL, qid("Y@@@:" + string(getKind(M, Tp)))]
         = getTerm(metaNormalize(M, F[RHS, qid("Y@@@:" + string(getKind(M, Tp)))])) if Cond [AtS'] .)
    if not comm in AtS
    [owise] .
endfm

*** To parse some input using the built-in function \texttt{metaParse}, we
*** need to give the metarepresentation of the signature in which the input is
*** going to be parsed.

*** But we do not need to give the complete metarepresentation of such a
*** module. In modules including \texttt{META-LEVEL} it is possible to define
*** terms of sort \texttt{Module} that import built-in modules or any module
*** introduced at the ``object level'' of Core Maude. In this way, it is
*** possible to get the equivalent effect of having the explicit
*** metarepresentation of a module by declaring a constant and adding an
*** equation identifying such a constant with the metarepresentation of an
*** extended module that imports the original module at the object level.

*** The declaration of constructors for bubble sorts at the object level is
*** not supported in the current version of Core Maude. The \texttt{special}
*** attributes linking the constructors for the bubble sorts to the built-in
*** ones are only supported at the metalevel, that is, the declarations of the
*** constructor operators for bubble sorts have to be given in the
*** metarepresentation of a module.

*** To allow the greatest generality and flexibility in future extensions of
*** Full Maude, we have declared its signature as a module
*** \texttt{FULL-MAUDE-SIGN}. Then, in the following module
*** \texttt{META-FULL-MAUDE-SIGN} we declare a constant \texttt{GRAMMAR} of
*** sort \texttt{FModule}, and we give an equation identifying such constant
*** with the metarepresentation of a module \texttt{GRAMMAR} in which there is
*** a declaration importing \texttt{FULL-MAUDE-SIGN}. Declarations for the
*** constructors of the bubble sorts are also included in this module. Note
*** that the bubble sorts \texttt{@Token@}, \texttt{@Bubble@},
*** \texttt{@SortToken@}, and \texttt{@NeTokenList@} are declared in the
*** module \texttt{SIGN\&VIEW-EXPR}, which is imported by
*** \texttt{FULL-MAUDE-SIGN}. These sorts are used in the declarations
*** describing the syntax of the system.

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod META-FULL-MAUDE-SIGN is
---  including META-LEVEL + PRE-VARIANT .
  including META-LEVEL .
  including FM-UNIT .

  op BUBBLES : -> FModule .
  op GRAMMAR : -> FModule [memo] .

  eq BUBBLES
    = (fmod 'GRAMMAR is
        including 'QID-LIST .
        sorts none .
        none
        op 'token : 'Qid -> '@Token@
             [special(
               (id-hook('Bubble, '1 '1)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)))] .
        op 'viewToken : 'Qid -> '@ViewToken@
             [special(
               (id-hook('Bubble, '1 '1)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)))] .
        op 'sortToken : 'Qid -> '@SortToken@
             [special(
               (id-hook('Bubble, '1 '1)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)
                id-hook('Exclude, '`[ '`] '< 'to '`, '. '`( '`) '`{ '`} ': '|
                                  'ditto 'precedence 'prec 'gather
                                  'assoc 'associative 'comm 'commutative
                                  'ctor 'constructor 'id: 'strat 'strategy
                                  'poly 'memo 'memoization 'iter 'frozen
                                  'config 'object 'msg 'metadata 'nonexec 'variant)))] .
        op 'neTokenList : 'QidList -> '@NeTokenList@
             [special(
               (id-hook('Bubble, '1 '-1 '`( '`))
                op-hook('qidListSymbol, '__, 'QidList 'QidList, 'QidList)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)
                id-hook('Exclude, '. ':)))] .
        op 'bubble : 'QidList -> '@Bubble@
             [special(
               (id-hook('Bubble, '1 '-1 '`( '`))
                op-hook('qidListSymbol, '__, 'QidList 'QidList, 'QidList)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)
                id-hook('Exclude, 'eq 'ceq 'rl 'crl 'mb 'cmb 'sd 'csd
                                  'var 'vars 'strat 'endm
                                  'endfm 'endsm 'sorts 'subsort 'subsorts
                                  'subclass 'subclasses 'op 'ops
                                  'protecting 'pr 'including 'inc 'extending
                                  'ctor 'assoc 'comm '==)))] .
        op 'ububble : 'QidList -> '@UBubble@
             [special(
               (id-hook('Bubble, '1 '-1 '`( '`))
                op-hook('qidListSymbol, '__, 'QidList 'QidList, 'QidList)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)))] .
        op 'stbubble : 'QidList -> '@StBubble@
             [special(
               (id-hook('Bubble, '1 '-1 '`( '`))
                op-hook('qidListSymbol, '__, 'QidList 'QidList, 'QidList)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)
                id-hook('Exclude, 'using)))] .
        op 'eqlbubble : 'QidList -> '@EqLBubble@
             [special(
               (id-hook('Bubble, '1 '-1 '`( '`))
                op-hook('qidListSymbol, '__, 'QidList 'QidList, 'QidList)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)
                id-hook('Exclude, '=)))] .
        op 'rllbubble : 'QidList -> '@RlLBubble@
             [special(
               (id-hook('Bubble, '1 '-1 '`( '`))
                op-hook('qidListSymbol, '__, 'QidList 'QidList, 'QidList)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)
                id-hook('Exclude, '=>)))] .
        op 'sdlbubble : 'QidList -> '@SdLBubble@
             [special(
               (id-hook('Bubble, '1 '-1 '`( '`))
                op-hook('qidListSymbol, '__, 'QidList 'QidList, 'QidList)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)
                id-hook('Exclude, ':=)))] .
        op 'rcbubble : 'QidList -> '@RCBubble@
             [special(
               (id-hook('Bubble, '1 '-1 '`( '`))
                op-hook('qidListSymbol, '__, 'QidList 'QidList, 'QidList)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)
                id-hook('Exclude, 'if)))] .
        op 'rbubble : 'QidList -> '@RBubble@
             [special(
               (id-hook('Bubble, '1 '-1 '`( '`))
                op-hook('qidListSymbol, '__, 'QidList 'QidList, 'QidList)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)
                id-hook('Exclude, '.)))] .
        none
        none
     endfm) .

  eq GRAMMAR = addImports((including 'FULL-MAUDE-SIGN .), BUBBLES) .

endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------


*** The \texttt{GRAMMAR} module will be used in calls to the \texttt{metaParse}
*** function in order to get the input parsed in this signature. Note that
*** this module is not the data type in which we shall represent the inputs.
*** From the call to \texttt{metaParse} we shall get a term representing the
*** parse tree of the input. This term will then be transformed into terms of
*** other appropriate data types if necessary.

*** Future extensions to Full Maude will require extending the signature as
*** well. The addition of new commands, new module expressions, or additions
*** of any other kind will require adding new declarations to the present Full
*** Maude signature and defining the corresponding extensions to the data
*** types and functions to deal with the new cases introduced by the
*** extensions.

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

***
*** The Abstract Data Type \texttt{View}
***

*** In this section we present the data type \texttt{View} for views.
*** Basically, the data elements of sort \texttt{View} are composed by the
*** name of the view, the names of the source and target units, and a set of
*** maps representing the maps asserting how the given target unit is claimed
*** to satisfy the source theory (see Section~\ref{Views}).

*** Internally, renaming maps are considered to be a particular case of view
*** maps. The sort \texttt{ViewMap} is declared as a supersort of
*** \texttt{Map}. The only kind of maps in sort \texttt{ViewMap} not in sort
*** \texttt{Map} are maps of operators going to derived operators. We start
*** introducing the declarations for renaming maps and sTS of renaming maps
*** in Section~\ref{renaming-maps}, we then introduce view maps and sTS of
*** view maps in Section~\ref{view-maps}, and finally we introduce the sort
*** \texttt{View}, its constructor, and some operations on it in
*** Section~\ref{viewADT}.

***
*** View Maps
***

*** In addition to the maps of sort \texttt{Renaming},
*** in views there can also be maps from operators to derived
*** operators, that is, terms with variables (see Section~\ref{Views}). Maps
*** of this kind are given with the constructor \texttt{op_to`term_}, which, in
*** addition to the source and target terms, takes the set of variable
*** declarations for the variables used in the map. The source term must be of
*** the form $\texttt{F(X}_1\texttt{,}\ldots,\texttt{X}_n\texttt{)}$, where
*** \texttt{F} is an operator name declared with $n$ arguments of sorts in the
*** connected components of the variables $\texttt{X}_1\ldots\texttt{X}_n$,
*** respectively. We will see in Section~\ref{view-processing} how in the
*** initial processing of a view the variables declared in it are associated
*** to each of the maps in which they are used.


***
*** Views
***

*** The \texttt{View} sort is introduced in the following module
*** \texttt{VIEW}.  In addition to the constructor for views (\texttt{view}),
*** selector functions are added for each of the components of a
*** view (\texttt{name}, \texttt{source}, \texttt{target}, and
*** \texttt{mapSet}), and a constant \texttt{emptyView}, which is identified
*** in an equation with the empty view, is defined.

*** Although the declaration of the constructor for views includes an argument
*** for the list of parameters, parameterized views are not handled yet, so at
*** present this argument must be set to the \texttt{nil}.

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod EXT-RENAMING is
  pr META-MODULE .

  op op_to term_ : Term Term -> Renaming .
endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod VIEW is
  ex META-VIEW .
  pr FM-VIEW-EXPR .
  inc FM-FMAP .

  *** mappings
  op class_to_. : Sort Sort -> SortMapping .
  op attr_._to_. : Qid Sort Qid -> OpMapping .
  op msg_to_. : Qid Qid -> OpMapping .
  op msg_:_->_to_. : Qid TypeList Sort Qid -> OpMapping .

  op strat_to`expr_. : Term Term -> StratMapping . ---- PreMapping

  subsort ViewExpression < Header .

  op null : -> View [ctor] .
  op viewError : QidList -> [View] [ctor format (r o)] .

  eq VE{(nil).ParameterDeclList} = VE .

  vars A A' F F' Q Q' : Qid .
  var QIL : QidList .
  var VH : Header .
  var VE : ViewExpression .
  vars PDL PDL' : ParameterDeclList .
  vars ME ME' ME'' : ModuleExpression .
  vars SMS SMS' : SortMappingSet .
  vars OMS OMS' : OpMappingSet .
  vars TMS TMS' : StratMappingSet .
  vars S S' C : Sort .
  var  Ty : Type .
  var  TyL : TypeList .
  vars T T' : Term .
  var  CS : CallStrategy .
  var  Strat : Strategy .

  op maps2rens : SortMappingSet -> RenamingSet .
  op maps2rens : OpMappingSet -> RenamingSet .
  op maps2rens : StratMappingSet -> RenamingSet .

  eq maps2rens(sort S to S' . SMS) = sort S to S', maps2rens(SMS) .
  eq maps2rens(class S to S' . SMS) = class S to S', maps2rens(SMS) .
  eq maps2rens((none).SortMappingSet) = none .

  eq maps2rens(op F to F' . OMS) = op F to F' [none], maps2rens(OMS) .
  eq maps2rens(op F : TyL -> Ty to F' . OMS) = op F : TyL -> Ty to F' [none], maps2rens(OMS) .
  eq maps2rens(op T to term T' . OMS) = op T to term T', maps2rens(OMS) .
  eq maps2rens(msg F to F' . OMS) = msg F to F' [none], maps2rens(OMS) .
  eq maps2rens(msg F : TyL -> Ty to F' . OMS) = msg F : TyL -> Ty to F' [none], maps2rens(OMS) .
  eq maps2rens(attr A . C to A' . OMS) = attr A . C to A', maps2rens(OMS) .
  eq maps2rens((none).OpMappingSet) = none .

  eq maps2rens(strat F to F' . TMS) = strat F to F', maps2rens(TMS) .
  eq maps2rens(strat F : TyL @ Ty to F' . TMS) = strat F : TyL @ Ty to F', maps2rens(TMS) .
  eq maps2rens(strat CS to expr Strat . TMS) = strat CS to expr Strat, maps2rens(TMS) .
  eq maps2rens((none).StratMappingSet) = none .

*** projection functions
----  op getName : View -> Qid .
----  eq getName(view VE from ME to ME' is SMS OMS TMS endv) = VE [owise] .
----  eq getName(view VE{PDL} from ME to ME' is SMS OMS TMS endv) = VE .

  op getPars : [View] -> ParameterDeclList .
  eq getPars(view VE from ME to ME' is SMS OMS TMS endv) = nil [owise] .
  eq getPars(view VE{PDL} from ME to ME' is SMS OMS TMS endv) = PDL .
  eq getPars(viewError(QIL)) = nil .

  eq getFrom(view VH from ME to ME' is SMS OMS TMS endv) = ME .
  eq getTo(view VH from ME to ME' is SMS OMS TMS endv) = ME' .
  eq getSortMappings(view VH from ME to ME' is SMS OMS TMS endv) = SMS .
  eq getOpMappings(view VH from ME to ME' is SMS OMS TMS endv) = OMS .

*** injection functions
  op setName : View Qid -> View .
  eq setName(view Q from ME to ME' is SMS OMS TMS endv, Q')
    = view Q' from ME to ME' is SMS OMS TMS endv .
  eq setName(view Q{PDL} from ME to ME' is SMS OMS TMS endv, VH) = view VH{PDL} from ME to ME' is SMS OMS TMS endv .
  eq setName(viewError(QIL), VE) = viewError(QIL) .

  op setPars : [View] ParameterDeclList -> [View] .
  eq setPars(view VH from ME to ME' is SMS OMS TMS endv, PDL)
    = view VH{PDL} from ME to ME' is SMS OMS TMS endv [owise] .
  eq setPars(view VH{PDL} from ME to ME' is SMS OMS TMS endv, PDL') = view VH{PDL'} from ME to ME' is SMS OMS TMS endv .
  eq setPars(viewError(QIL), PDL) = viewError(QIL) .

  op setFrom : View ModuleExpression -> View .
  eq setFrom(view VH from ME to ME' is SMS OMS TMS endv, ME'')
    = view VH from ME'' to ME' is SMS OMS TMS endv .
  eq setFrom(viewError(QIL), ME) = viewError(QIL) .

  op setTo : View ModuleExpression -> View .
  eq setTo(view VH from ME to ME' is SMS OMS TMS endv, ME'')
    = view VH from ME to ME'' is SMS OMS TMS endv .
  eq setTo(viewError(QIL), ME) = viewError(QIL) .

  op setSortMappings : View SortMappingSet -> View .
  eq setSortMappings(view VH from ME to ME' is SMS OMS TMS endv, SMS')
    = view VH from ME to ME' is SMS' OMS TMS endv .
  eq setSortMappings(viewError(QIL), SMS') = viewError(QIL) .

  op setOpMappings : View OpMappingSet -> View .
  eq setOpMappings(view VH from ME to ME' is SMS OMS TMS endv, OMS')
    = view VH from ME to ME' is SMS OMS' TMS endv .
  eq setOpMappings(viewError(QIL), OMS') = viewError(QIL) .

  op emptyView : Qid ModuleExpression ModuleExpression -> View .
  eq emptyView(VH, ME, ME') = view VH from ME to ME' is none none none endv .
endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

***
*** The Abstract Data Type \texttt{Database}
***

*** In this section we present the data type \texttt{Database}, which will be
*** used to store information about the units and views in the system. Before
*** discussing this data type in Section~\ref{databaseADT}, we present the
*** predefined units added in Full Maude to those already available in Core
*** Maude.

***
*** Non-Built-In Predefined Modules
***

*** As we shall see in the following section, except for the
*** \texttt{LOOP-MODE} module, all the predefined modules that are available
*** in Core Maude are also available in Full Maude. In addition to these Core
*** Maude predefined modules, in Full Maude there are some additional
*** predefined units. In the present system, the only units with which the
*** database is initialized are the functional theory \texttt{TRIV}, the
*** module \texttt{CONFIGURATION}, and the module \texttt{UP}, which will be
*** used to evaluate the \texttt{up} functions. We shall see in
*** Section~\ref{main-module} how new predefined modules can be added to the
*** initial database.

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod PREDEF-UNITS is
  pr FM-UNIT .

*** The following module \texttt{UP} contains the necessary declarations to
*** be able to parse the \texttt{up} functions presented in
*** Section~\ref{structured-specifications}. We shall see in
*** Section~\ref{evaluation} how a declaration importing the following module
*** \texttt{UP} is added to all the modules importing the predefined module
*** \texttt{META-LEVEL}. With this declaration, it is possible to parse the
*** \texttt{up} commands in the bubbles of such modules or in commands being
*** evaluated in such modules. We shall see in Section~\ref{bubble-parsing}
*** how these commands are then evaluated.

  op #UP# : -> FModule [memo] .
  eq #UP#
    = (fmod '#UP# is
        including 'QID-LIST .
        including 'FM-MOD-EXPR .
        sorts none .
        none
        op 'upTerm : '@ModExp@ '@Bubble@ -> 'Term [none] .
        op 'upModule : '@ModExp@ -> 'Module [none] .
        op '`[_`] : '@Token@ -> 'Module [none] .
        op 'token : 'Qid -> '@Token@
             [special(
               (id-hook('Bubble, '1 '1)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)))] .
        op 'viewToken : 'Qid -> '@ViewToken@
             [special(
               (id-hook('Bubble, '1 '1)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)))] .
        op 'sortToken : 'Qid -> '@SortToken@
             [special(
               (id-hook('Bubble, '1 '1)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)
                id-hook('Exclude, '`[ '`] '< 'to '`, '. '`( '`) '`{ '`} ':
                                  'ditto 'precedence 'prec 'gather
                                  'assoc 'associative 'comm 'commutative
                                  'ctor 'constructor 'id: 'strat 'strategy
                                  'poly 'memo 'memoization 'iter 'frozen
                                  'config 'object 'msg 'metadata 'nonexec 'variant)))] .
        op 'neTokenList : 'QidList -> '@NeTokenList@
             [special(
               (id-hook('Bubble, '1 '-1 '`( '`))
                op-hook('qidListSymbol, '__, 'QidList 'QidList, 'QidList)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)
                id-hook('Exclude, '. ':)))] .
        op 'bubble : 'QidList -> '@Bubble@
             [special(
               (id-hook('Bubble, '1 '-1 '`( '`))
                op-hook('qidListSymbol, '__, 'QidList 'QidList, 'QidList)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)
                id-hook('Exclude, 'eq 'ceq 'rl 'crl 'mb 'cmb 'sd 'csd
                                  'var 'vars 'strat 'endm
                                  'endfm 'endsm 'sorts 'subsort 'subsorts
                                  'subclass 'subclasses 'op 'ops
                                  'protecting 'pr 'including 'inc 'extending
                                  'ctor 'assoc 'comm '==)))] .
        op 'ububble : 'QidList -> '@UBubble@
             [special(
               (id-hook('Bubble, '1 '-1 '`( '`))
                op-hook('qidListSymbol, '__, 'QidList 'QidList, 'QidList)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)))] .
        op 'stbubble : 'QidList -> '@StBubble@
             [special(
               (id-hook('Bubble, '1 '-1 '`( '`))
                op-hook('qidListSymbol, '__, 'QidList 'QidList, 'QidList)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)
                id-hook('Exclude, 'using)))] .
        op 'eqlbubble : 'QidList -> '@EqLBubble@
             [special(
               (id-hook('Bubble, '1 '-1 '`( '`))
                op-hook('qidListSymbol, '__, 'QidList 'QidList, 'QidList)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)
                id-hook('Exclude, '=)))] .
        op 'rllbubble : 'QidList -> '@RlLBubble@
             [special(
               (id-hook('Bubble, '1 '-1 '`( '`))
                op-hook('qidListSymbol, '__, 'QidList 'QidList, 'QidList)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)
                id-hook('Exclude, '=>)))] .
        op 'sdlbubble : 'QidList -> '@SdLBubble@
             [special(
               (id-hook('Bubble, '1 '-1 '`( '`))
                op-hook('qidListSymbol, '__, 'QidList 'QidList, 'QidList)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)
                id-hook('Exclude, ':=)))] .
        op 'rcbubble : 'QidList -> '@RCBubble@
             [special(
               (id-hook('Bubble, '1 '-1 '`( '`))
                op-hook('qidListSymbol, '__, 'QidList 'QidList, 'QidList)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)
                id-hook('Exclude, 'if)))] .
        op 'rbubble : 'QidList -> '@RBubble@
             [special(
               (id-hook('Bubble, '1 '-1 '`( '`))
                op-hook('qidListSymbol, '__, 'QidList 'QidList, 'QidList)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)
                id-hook('Exclude, '.)))] .
        none
        none
     endfm) .
endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

***
*** 7 The Evaluation of Views
***

*** Before being entered into the database, besides containing bubbles, views
*** have a somewhat different structure from that of the views given in
*** Section~\ref{viewADT}. We introduce in the following module a sort
*** \texttt{PreView} with constructor \texttt{view}, which is declared as the
*** constructor for views of sort \texttt{View}, but with an additional
*** argument, namely, a set of variable declarations to hold the declarations
*** of variables in the view. During the processing of views (see
*** Section~\ref{view-processing}), which takes place once the parsing process
*** has concluded, these variables are associated with the corresponding maps
*** where they are used, generating a term of sort \texttt{View}.

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod PRE-VIEW is
  pr VIEW .

  sort PreView .
  op preview_from_to_is____endpv : Header ModuleExpression ModuleExpression
       VariableSet SortMappingSet OpMappingSet StratMappingSet -> PreView
       [ctor format (nir! o r! o r! o r! o o o o r! o)] .
  op null : -> PreView .

  op getName : PreView -> ViewExpression .
  op getPars : PreView -> ParameterDeclList .
  op getFrom : PreView -> ModuleExpression .
  op getTo : PreView -> ModuleExpression .
  op getVars : PreView -> VariableSet .
  op getSortMappings : PreView -> SortMappingSet .
  op getOpMappings : PreView -> OpMappingSet .
  op getStratMappings : PreView -> StratMappingSet .

  var  QI : Qid .
  vars ME ME' : ModuleExpression .
  var  VE : ViewExpression .
  var  VH : Header .
  vars PDL PDL' : ParameterDeclList .
  vars VDS VDS' : VariableSet .
  vars SMS SMS' : SortMappingSet .
  vars OMS OMS' : OpMappingSet .
  vars TMS TMS' : StratMappingSet .

  eq getName(preview VE from ME to ME' is VDS SMS OMS TMS endpv) = VE .
  eq getName(preview VE{PDL} from ME to ME' is VDS SMS OMS TMS endpv) = VE .
  eq getPars(preview VE from ME to ME' is VDS SMS OMS TMS endpv) = nil .
  eq getPars(preview VE{PDL} from ME to ME' is VDS SMS OMS TMS endpv) = PDL .
  eq getFrom(preview VH from ME to ME' is VDS SMS OMS TMS endpv) = ME .
  eq getTo(preview VH from ME to ME' is VDS SMS OMS TMS endpv) = ME' .
  eq getVars(preview VH from ME to ME' is VDS SMS OMS TMS endpv) = VDS .
  eq getSortMappings(preview VH from ME to ME' is VDS SMS OMS TMS endpv) = SMS .
  eq getOpMappings(preview VH from ME to ME' is VDS SMS OMS TMS endpv) = OMS .
  eq getStratMappings(preview VH from ME to ME' is VDS SMS OMS TMS endpv) = TMS .

*** The following functions can be used to add new declarations to the set of
*** declarations already in a preview.

  op addMaps : SortMappingSet PreView -> PreView .
  op addMaps : OpMappingSet PreView -> PreView .
  op addMaps : StratMappingSet PreView -> PreView .
  op addVars : VariableSet PreView -> PreView .

  eq addMaps(SMS, preview VH from ME to ME' is VDS SMS' OMS TMS endpv)
    = preview VH from ME to ME' is VDS (SMS SMS') OMS TMS endpv .
  eq addMaps(OMS, preview VH from ME to ME' is VDS SMS OMS' TMS endpv)
    = preview VH from ME to ME' is VDS SMS (OMS OMS') TMS endpv .
  eq addMaps(TMS, preview VH from ME to ME' is VDS SMS OMS TMS' endpv)
    = preview VH from ME to ME' is VDS SMS OMS (TMS TMS') endpv .

  eq addVars(VDS, preview VH from ME to ME' is VDS' SMS OMS TMS endpv)
    = preview VH from ME to ME' is (VDS ; VDS') SMS OMS TMS endpv .

  op setPars : PreView ParameterDeclList -> PreView .
  eq setPars(preview VE from ME to ME' is VDS SMS OMS TMS endpv, PDL)
    = preview VE{PDL} from ME to ME' is VDS SMS OMS TMS endpv
    [owise] .
  eq setPars(preview VE{PDL} from ME to ME' is VDS SMS OMS TMS endpv, PDL')
    = preview VE{PDL'} from ME to ME' is VDS SMS OMS TMS endpv .

  op emptyPreView : Qid ModuleExpression ModuleExpression -> PreView .
  eq emptyPreView(QI, ME, ME')
    = preview QI from ME to ME' is none none none none endpv .
endfm
 
-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

***
*** The Database
***

*** In order to be able to refer to modules by name, which is extremely useful
*** for module definition purposes at the user level, the evaluation of module
*** expressions takes place in the context of a database, in which we keep
*** information about the modules already introduced in the system, and also
*** about those modules generated internally.  This information is stored as
*** a set of elements of sort \texttt{ModuleInfo} and \texttt{ViewInfo}, in
*** which we hold, respectively, the information concerning units and views.
*** For each unit we save:
*** \begin{itemize}
*** \item Its original form, as introduced by the user, or, in case of an
***       internally generated unit, as generated from the original form of
***       some other unit.
*** \item Its internal representation, in which variables have been renamed
***       to avoid collisions with the names of variables in other units in
***       the same hierarchy.  In the case of object-oriented units, we store
***       its equivalent system module, that is, the result of transforming
***       it into a system module.
*** \item Its signature, which is given as a functional module of sort
***       \texttt{FModule} with no axioms, ready to be used in calls to
***       \texttt{metaParse}. There can only be importation declarations
***       including built-in modules in this module. These are the only
***       inclusions handled by the Core Maude engine.
*** \item Its flattened version, for which, as for signatures, only the
***       importation of built-in modules is left unevaluated.
*** \end{itemize}
*** For each view we keep its name and the view itself.

*** As a simple mechanism to keep the database consistent, for each unit we
*** maintain the list of names of all the units and views ``depending'' on it.
*** Similarly, for each view we maintain the list of names of all the units
*** ``depending'' on it. The idea is that if a unit or view is redefined or
*** removed, all those units and/or views depending on it will also be
*** removed. This dependency does not only mean direct importation. For
*** example, the module resulting from the renaming of some module also
*** depends on the module being renamed; the instantiation of a parameterized
*** module also depends on the parameterized module and on all the views used
*** in its instantiation; a view depends on its source and target units, etc.
*** This dependency is transitive: if a module, theory, or view has to be
*** removed, all the units and/or views depending on them will be removed as
*** well. The dependencies derived from the module expressions themselves are
*** established by the function \texttt{setUpModExpDeps}. The function
*** \texttt{setUpModuleDeps} calls \texttt{setUpModExpDeps},
*** and then \texttt{setUpImportSetDeps} to add the \emph{back
*** references} in the modules being imported. The function
*** \texttt{setUpViewDeps} sTS up the back references for the views
*** being introduced.

*** In addition to this set of information cells for units and views, we also
*** keep lists with the names of all the units and views in the database, and
*** a list of quoted identifiers in which we store the messages generated
*** during the process of treatment of the inputs in order to simplify the
*** communication with the read-eval-print loop process.

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

view ModuleName from TRIV to MOD-NAME is
  sort Elt to ModuleName .
endv

---- view ViewExpression from TRIV to FM-VIEW-EXPR is
----   sort Elt to ViewExpression .
---- endv

view ParameterDecl from TRIV to META-MODULE is
  sort Elt to ParameterDecl .
endv

fmod INFO is
  pr VIEW .
  pr DEFAULT-VALUE{Term} .
  pr (SET * (op _`,_ to _._,
             op empty to emptyModuleNameSet,
             op insert to insertModuleNameSet,
             op delete to deleteModuleNameSet,
             op _in_ to _inModuleNameSet_,
             op |_| to |_|ModuleNameSet,
             op $card to $cardModuleNameSet,
             op union to unionModuleNameSet,
             op intersection to intersectionModuleNameSet,
             op $intersect to $intersectModuleNameSet,
             op _\_ to _\ModuleNameSet_,
             op $diff to $diffModuleNameSet,
             op _subset_ to _subsetModuleNameSet_,
             op _psubset_ to _psubsetModuleNameSet_)){ModuleName} .
  pr (SET * (op _`,_ to _#_,
             op empty to emptyViewExpressionSet,
             op insert to insertViewExpressionSet,
             op delete to deleteViewExpressionSet,
             op _in_ to _inViewExpressionSet_,
             op |_| to |_|ViewExpressionrSet,
             op $card to $cardViewExpressionrSet,
             op union to unionViewExpressionrSet,
             op intersection to intersectionViewExpressionrSet,
             op $intersect to $intersectViewExpressionrSet,
             op _\_ to _\ViewExpressionrSet_,
             op $diff to $diffViewExpressionrSet,
             op _subset_ to _subsetViewExpressionrSet_,
             op _psubset_ to _psubsetViewExpressionrSet_)){ViewExpression} .
  pr (SET * (op _`,_ to _._)){ParameterDecl} .

  var  MN : ModuleName .
  var  MNS : Set{ModuleName} .

  op remove : Set{ModuleName} ModuleName -> Set{ModuleName} .
  eq remove(MN . MNS, MN) = remove(MNS, MN) .
  eq remove(MNS, MN) = MNS [owise] .

  sort ModuleInfo .
  op <_;_;_;_;_;_;_;_> : ModuleName Default{Term} Module Module Module
       VariableSet Set{ModuleName} Set{ViewExpression} -> ModuleInfo
     [ctor
      format
        (nig o g n+++io g nio g nio g nio g nio g nio g nio n---ig o)] .
  op <_;_;_;_;_;_;_;_> : ModuleName Module Module Module Module
       VariableSet Set{ModuleName} Set{ViewExpression} -> ModuleInfo
     [ctor
      format
      (nig ur! g n+++io g nio g nio g nio g nio g nio g nio n---ig o)] .

  *** - Modules can be introduced by the user or can be generated internally.
  ***   When introduced by the user the 2nd arg. keeps the term representation
  ***   of the module as given, so that it can be recompiled later. If the
  ***   module is generated internally as the result of the evaluation of a
  ***   module expression, then this second arg. will be null, the default
  ***   term value. The user can also enter modules with the procModule
  ***   function, providing then the metarepresentation of a module, which
  ***   is directly stored in the database as the 2nd arg. of one of these
  ***   ModuleInfo units of the second kind. This is useful for the ITP for
  ***   example, where the interaction with the database takes place at the
  ***   metalevel and the modules given by the "user" are already at the
  ***   metalevel but still wants the same treatment.
  *** - The sixth arg. stores the variables (corresponding ops.) in the top
  ***   module.

  sort ViewInfo .
  op <_;_;_;_;_> : ViewExpression Default{Term} View Set{ModuleName}
       Set{ViewExpression} -> ViewInfo
       [ctor format (nig o g n+++io g nio g nio g nio n---ig o)] .
  op <_;_;_;_;_> :
       ViewExpression View View Set{ModuleName} Set{ViewExpression} -> ViewInfo
       [ctor format (nig o g n+++io g nio g nio g nio n---ig o)] .

endfm

view ModuleInfo from TRIV to INFO is
  sort Elt to ModuleInfo .
endv

view ViewInfo from TRIV to INFO is
  sort Elt to ViewInfo .
endv

fmod DATABASE-DECLS is
  pr (SET * (op _`,_ to __, op empty to emptyInfoSet)){ModuleInfo} .
  pr (SET * (op _`,_ to __, op empty to emptyInfoSet)){ViewInfo} .

  sort Database .
  op db :
     Set{ModuleInfo}  *** module info tuples
     Set{ModuleName}  *** names of the modules in the database
     Set{ViewInfo}    *** view info tuples
     Set{ViewExpression}     *** names of the views in the db
     Set{ModuleName}  *** modules with set protect on (by default empty)
     Set{ModuleName}  *** modules with set extend on (by default empty)
     Set{ModuleName}  *** modules with set include on (by default empty)
     QidList
       -> Database
     [ctor
      format (nib i++o)] .

  ops getDefPrs getDefExs getDefIncs : Database -> Set{ModuleName} .
  eq getDefPrs(
        db(MIS:Set{ModuleInfo}, MNS:Set{ModuleName}, VIS:Set{ViewInfo},
           VES:Set{ViewExpression}, MNS':Set{ModuleName}, MNS'':Set{ModuleName},
           MNS3:Set{ModuleName}, QIL:QidList))
    = MNS':Set{ModuleName} .
  eq getDefExs(
        db(MIS:Set{ModuleInfo}, MNS:Set{ModuleName}, VIS:Set{ViewInfo},
           VES:Set{ViewExpression}, MNS':Set{ModuleName}, MNS'':Set{ModuleName},
           MNS3:Set{ModuleName}, QIL:QidList))
    = MNS'':Set{ModuleName} .
  eq getDefIncs(
        db(MIS:Set{ModuleInfo}, MNS:Set{ModuleName}, VIS:Set{ViewInfo},
           VES:Set{ViewExpression}, MNS':Set{ModuleName}, MNS'':Set{ModuleName},
           MNS3:Set{ModuleName}, QIL:QidList))
    = MNS3:Set{ModuleName} .
endfm

view Database from TRIV to DATABASE-DECLS is
  sort Elt to Database .
endv

view ModuleExpression from TRIV to META-MODULE is
  sort Elt to ModuleExpression .
endv

fmod DATABASE is
  pr (2TUPLE * (op `(_`,_`) to <_;_>,
                op p1_ to database,
                op p2_ to modExp)) {Database, ModuleExpression} .
  pr PRE-VIEW .
  pr FM-UNIT .
  ----MI pr FM-VIEW-EXPR-TO-QID .

  op evalModule : Module VariableSet Database -> Database .
  *** its definition is in the module FM-EVALUATION

  op procModule : Qid Database -> Database .
  op procView : Qid Database -> Database .
  op procView : View Database -> Database .
  *** their definitions are in the modules UNIT-PROCESSING and VIEW-PROCESSING

  op evalModExp : ModuleExpression Database -> Tuple{Database, ModuleExpression} .
  *** its definition is in the module MOD-EXPR-EVAL

  vars QI X Y F : Qid .
  vars QIL QIL' : QidList .
  vars NQIL NQIL' : NeQidList .
  vars VE VE' VE'' : ViewExpression .
  vars VES VES' VES'' VES3 : Set{ViewExpression} .
  vars MIS MIS' : Set{ModuleInfo} .
  var  VIS : Set{ViewInfo} .
  vars MNS MNS' MNS'' MNS3 MNS4 MNS5 MNS6 : Set{ModuleName} .
  vars PL PL' : ParameterList .
  vars PDS PDS' PDS'' : Set{ParameterDecl} .
  var  PDL : ParameterDeclList .
  var  PD : ParameterDecl .
  vars ME ME' : ModuleExpression .
  vars VI VI' : View .
  var  SMS : SortMappingSet .
  var  OMS : OpMappingSet .
  var  TMS : StratMappingSet .
  vars PU PU' U U' U'' U3 U4 : Module .
  var  M : Module .
  var  DB : Database .
  vars IL IL' : ImportList .
  var  VIf : ViewInfo .
  var  UIf : ModuleInfo .
  vars OPDS : OpDeclSet .
  vars VDS VDS' : VariableSet .
  var  PV : PreView .
  vars T T' : Term .
  var  DT : Default{Term} .
  var  NL : IntList .
  var  TyL : TypeList .
  var  Ty : Type .
  var  AtS : AttrSet .
  var  B : Bool .
  var  I : Import .
  var  MN MN' : ModuleName .

  ops dincluded : ModuleExpression ImportList -> Bool .

  eq dincluded(ME, IL (protecting ME .) IL') = true .
  eq dincluded(ME, IL (extending ME .) IL') = true .
  eq dincluded(ME, IL (including ME .) IL') = true .
  eq dincluded(ME, IL) = false [owise] .

  ops included includedAux : ModuleExpression ImportList Database -> Bool .

  eq included(ME, IL (protecting ME .) IL', DB) = true .
  eq included(ME, IL (extending ME .) IL', DB) = true .
  eq included(ME, IL (including ME .) IL', DB) = true .
  eq included(ME, nil, DB) = false .
  eq included(ME, IL, DB) = includedAux(ME, IL, DB) [owise] .

  eq includedAux(ME, I IL, DB)
    = included(ME, getImports(getTopModule(moduleName(I), DB)), DB)
      or-else includedAux(ME, IL, DB) .
  eq includedAux(ME, nil, DB) = false .

  op defImports : Module Database -> ImportList .
  op defImports : ImportList ImportList Set{ModuleName} Set{ModuleName}
       Set{ModuleName} -> ImportList .

  eq defImports(M, DB)
    = if theory(M)
      then nil
      else defImports(getImports(M), nil,
             getDefPrs(DB), getDefExs(DB), getDefIncs(DB))
      fi .

  eq defImports(IL, IL', MN . MNS, MNS', MNS'')
    = if dincluded(MN, IL IL')
      then defImports(IL, IL', MNS, MNS', MNS'')
      else defImports(IL, IL' (protecting MN .), MNS, MNS', MNS'')
      fi .
  eq defImports(IL, IL', MNS, MN . MNS', MNS'')
    = if dincluded(MN, IL IL')
      then defImports(IL, IL', MNS, MNS', MNS'')
      else defImports(IL, IL' (extending MN .), MNS, MNS', MNS'')
      fi .
  eq defImports(IL, IL', MNS, MNS', MN . MNS'')
    = if dincluded(MN, IL IL')
      then defImports(IL, IL', MNS, MNS', MNS'')
      else defImports(IL, IL' (including MN .), MNS, MNS', MNS'')
      fi .
  eq defImports(IL, IL',
       emptyModuleNameSet, emptyModuleNameSet, emptyModuleNameSet)
    = IL' .

*** The constant \texttt{emptyDatabase} denotes the empty database, and there
*** are predicates \texttt{viewInDatabase} and \texttt{unitInDb} to check,
*** respectively, whether a view and a unit are in a database or not.

  op emptyDatabase : -> Database .
  eq emptyDatabase
    = db(emptyInfoSet, emptyModuleNameSet, emptyInfoSet, emptyViewExpressionSet,
         emptyModuleNameSet, emptyModuleNameSet, 'BOOL, nil) .

  op unitInDb : ModuleName Database -> Bool .
  eq unitInDb(MN, db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, QIL))
    = MN inModuleNameSet MNS .

  op viewInDb : ViewExpression Database -> Bool .
  eq viewInDb(VE, db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, QIL))
    = VE inViewExpressionSet VES .

  op includeBOOL : Database -> Bool .
  eq includeBOOL(db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, QIL))
    = 'BOOL inModuleNameSet MNS' .

*** If a module, theory, or view is being redefined, that is, if there was
*** already in the database a module, theory, or view with the same name,
*** then all the units and/or views depending on it are removed using the
*** functions \texttt{delModules} and \texttt{delViews}. Removing a view
*** or a unit from the database means removing its info cell from the set of
*** cells in the database. Those entered by the user are not completely
*** removed, their term form is saved so that it can be recompiled later.

  op delModules : Set{ModuleName} Database -> Database .
  op delViews : Set{ViewExpression} Database -> Database .

  eq delModules((MN . MNS),
       db(< MN ; T ; U ; U' ; U'' ; VDS ; MNS' ; VES > MIS,
          MN . MNS'', VIS, VES', MNS3, MNS4, MNS5, QIL))
    = delModules((MNS . MNS'),
          delViews(VES,
            db(< MN ; T ; noModule ; noModule ; noModule ; VDS ;
                 emptyModuleNameSet ; emptyViewExpressionSet > MIS,
               MN . MNS'', VIS, VES', MNS3, MNS4, MNS5, QIL))) .
  eq delModules((MN . MNS),
       db(< MN ; U ; U' ; U'' ; U3 ; VDS ; MNS' ; VES > MIS,
          MN . MNS'', VIS, VES', MNS3, MNS4, MNS5, QIL))
    = delModules((MNS . MNS'),
          delViews(VES,
            db(< MN ; U ; noModule ; noModule ; noModule ; VDS ;
                 emptyModuleNameSet ; emptyViewExpressionSet > MIS,
               MN . MNS'', VIS, VES', MNS3, MNS4, MNS5, QIL))) .
  eq delModules((MN . MNS),
       db(< MN ; null ; U ; U' ; U'' ; VDS ; MNS' ; VES > MIS,
          MN . MNS'', VIS, VES', MNS3, MNS4, MNS5, QIL))
    = delModules((MNS . MNS'),
        delViews(VES,
            db(MIS, MNS'', VIS, VES', MNS3, MNS4, MNS5, QIL))) .
  eq delModules(emptyModuleNameSet, DB) = DB .
  eq delModules((MN . MNS), DB) = delModules(MNS, DB) [owise] .

  eq delViews(VE # VES,
       db(MIS, MNS, < VE ; T ; VI ; MNS' ; VES' > VIS, VE # VES'',
          MNS'', MNS3, MNS4, QIL))
    = delViews(VES # VES',
        delModules(MNS',
          db(MIS, MNS,
             < VE ; T ; null ; emptyModuleNameSet ; emptyViewExpressionSet > VIS,
             VE # VES'', MNS'', MNS3, MNS4, QIL))) .
  eq delViews(VE # VES,
       db(MIS, MNS,
          < VE ; (null).Default{Term} ; VI ; MNS' ; VES' > VIS, VE # VES'',
          MNS'', MNS3, MNS4, QIL))
    = delViews(VES # VES',
        delModules(MNS',
          db(MIS, MNS, VIS, VES'', MNS'', MNS3, MNS4, QIL))) .
  eq delViews(VE # VES,
       db(MIS, MNS, < VE ; VI ; VI' ; MNS' ; VES' > VIS, VE # VES'',
          MNS'', MNS3, MNS4, QIL))
    = delViews(VES # VES',
        delModules(MNS',
          db(MIS, MNS,
             < VE ; VI ; null ; emptyModuleNameSet ; emptyViewExpressionSet > VIS,
             VE # VES'', MNS'', MNS3, MNS4, QIL))) .
  eq delViews(emptyViewExpressionSet, DB) = DB .
  eq delViews(VE # VES, DB) = delViews(VES, DB) [owise] .

*** The \texttt{warning} function allows us to place messages (warning, error,
*** or any other kind of messages) in the last argument of the database
*** constructor. These messages are given in the form of quoted identifier
*** lists, and will be passed to the third argument of the read-eval-print
*** loop, to be printed in the terminal.

  op warning : Database QidList -> Database .
  eq warning(db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, nil), QIL)
    = db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, QIL) .
  eq warning(db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, NQIL), QIL)
    = db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, NQIL QIL) .

  op getMsg : Database -> QidList .
  eq getMsg(db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, QIL)) = QIL .

*** Core Maude built-in modules are handled in a special way in the current
*** version of the system. They are not explicitly defined in the Full Maude
*** database; their importation is directly handled by Core Maude. This has
*** some drawbacks: Core Maude built-in modules cannot be renamed; they cannot
*** be directly used with built-in functions, such as \texttt{metaReduce} or
*** \texttt{sameComponent}, although they can be imported in modules being
*** used in the calls to these functions; and, in general, any function taking
*** as argument or returning as result the metarepresentation of a module
*** cannot take one of these built-in modules as argument. This is the case,
*** for example, for the \texttt{up} function presented in
*** Section~\ref{changing-levels}, or for functions or commands in which the
*** name of a module has to be specified, as the \texttt{select} or
*** \texttt{down} commands, or the \texttt{up} function presented in
*** Section~\ref{structured-specifications}. Nevertheless, there are also
*** some advantages: The flattening of the built-in part of the structure is
*** accomplished more efficiently, and, since these modules do not have to be
*** stored in the database of Full Maude, the size of the database is reduced.

*** Our plan is to have in the future a hybrid solution. Once we have some way
*** of storing the modules entered to Full Maude in Core Maude's database, it
*** will be enough to keep in the Full Maude database just the original form
*** of the top of all the modules, including built-ins, leaving all the
*** importation declarations to be resolved by the engine. The structures will
*** be normalized as they are now, so that the engine will have to deal just
*** with inclusions, but it will be possible to use the predefined modules as
*** any other module. Moreover, the Full Maude database will be relatively
*** smaller and the flattening will be computed more efficiently.

*** When a new module or theory is entered, the names of all the modules,
*** theories, and views depending on it are included in its lists of
*** dependencies with functions \texttt{setUpModuleDeps} and
*** \texttt{setUpViewDeps}. Notice that if new module expressions are
*** defined, the function \texttt{setUpModExpDeps} will have to be
*** extended accordingly.

  op setUpModuleDeps : Module Database -> Database .
  op setUpModExpDeps : ModuleName Database -> Database .
  op setUpModExpDeps : ModuleName Header Database -> Database .
  op setUpModExpDeps : ModuleName ViewExpression Database -> Database .
  op setUpImportDeps : ModuleName ImportList Database -> Database .

  eq setUpModuleDeps(U, DB)
    = setUpImportDeps(getHeader(U), getImports(U),
        setUpModExpDeps(getHeader(U), DB)) .

  eq setUpModExpDeps(QI, DB) = DB .

  eq setUpModExpDeps(pd(X :: ME),
       db(< ME ; DT ; U ; U' ; U'' ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = db(< ME ; DT ; U ; U' ; U'' ; VDS ; (MNS . pd(X :: ME)) ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL) .
  eq setUpModExpDeps(pd(X :: ME),
       db(< ME ; U ; U' ; U'' ; U3 ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = db(< ME ; U ; U' ; U'' ; U3 ; VDS ; (MNS . pd(X :: ME)) ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL) .
  eq setUpModExpDeps(pd(X :: ME), DB)
    = warning(DB, ('\r 'Error: '\o 'Module header2QidList(ME) 'not 'in 'database. '\n))
    [owise] .

---- This could be a bug in Core Maude.
---- It should work if the next 6 equations are replaced by this single equation.
----  ceq setUpImportDeps(MN, (I IL),
----       db((< MN' ; U ; U' ; U'' ; U3 ; VDS ; MNS ; VES > MIS),
----          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
----    = setUpImportDeps(MN, IL,
----        db((< MN' ; U ; U' ; U'' ; U3 ; VDS ; MN . MNS ; VES > MIS),
----           MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
----    if MN' := moduleName(I) .
  eq setUpImportDeps(MN, ((including MN' .) IL),
       db((< MN' ; DT ; U ; U' ; U'' ; VDS ; MNS ; VES > MIS), MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = setUpImportDeps(MN, IL,
        db((< MN' ; DT ; U ; U' ; U'' ; VDS ; MN . MNS ; VES > MIS), MNS', VIS, VES', MNS'', MNS3, MNS4, QIL)) .
  eq setUpImportDeps(MN, ((including MN' .) IL),
       db((< MN' ; U ; U' ; U'' ; U3 ; VDS ; MNS ; VES > MIS), MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = setUpImportDeps(MN, IL,
        db((< MN' ; U ; U' ; U'' ; U3 ; VDS ; MN . MNS ; VES > MIS), MNS', VIS, VES', MNS'', MNS3, MNS4, QIL)) .
  eq setUpImportDeps(MN, ((extending MN' .) IL),
       db((< MN' ; DT ; U ; U' ; U'' ; VDS ; MNS ; VES > MIS), MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = setUpImportDeps(MN, IL,
        db((< MN' ; DT ; U ; U' ; U'' ; VDS ; MN . MNS ; VES > MIS), MNS', VIS, VES', MNS'', MNS3, MNS4, QIL)) .
  eq setUpImportDeps(MN, ((extending MN' .) IL),
       db((< MN' ; U ; U' ; U'' ; U3 ; VDS ; MNS ; VES > MIS), MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = setUpImportDeps(MN, IL,
        db((< MN' ; U ; U' ; U'' ; U3 ; VDS ; MN . MNS ; VES > MIS), MNS', VIS, VES', MNS'', MNS3, MNS4, QIL)) .
  eq setUpImportDeps(MN, ((protecting MN' .) IL),
       db((< MN' ; DT ; U ; U' ; U'' ; VDS ; MNS ; VES > MIS), MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = setUpImportDeps(MN, IL,
        db((< MN' ; DT ; U ; U' ; U'' ; VDS ; MN . MNS ; VES > MIS), MNS', VIS, VES', MNS'', MNS3, MNS4, QIL)) .
  eq setUpImportDeps(MN, ((protecting MN' .) IL),
       db((< MN' ; U ; U' ; U'' ; U3 ; VDS ; MNS ; VES > MIS), MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = setUpImportDeps(MN, IL,
        db((< MN' ; U ; U' ; U'' ; U3 ; VDS ; MN . MNS ; VES > MIS), MNS', VIS, VES', MNS'', MNS3, MNS4, QIL)) .
  eq setUpImportDeps(MN, I IL, DB)
    = warning(DB, '\r 'Error: '\o 'Module header2QidList(moduleName(I)) 'not 'in 'database. '\n)
    [owise] .
  eq setUpImportDeps(MN, nil, DB) = DB .

  op setUpViewDeps : ModuleExpression ViewExpression Database -> Database .
  op setUpViewExpressionDeps : ViewExpression Database -> Database .
  op setUpViewExpressionDeps : ViewExpression ParameterList Database -> Database .

  eq setUpViewDeps(ME, VE,
       db((< ME ; DT ; U ; U' ; U'' ; VDS ; MNS ; VES > MIS), MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = db((< ME ; DT ; U ; U' ; U'' ; VDS ; MNS ; VE # VES > MIS), MNS', VIS, VES', MNS'', MNS3, MNS4, QIL) .
  eq setUpViewDeps(ME, VE,
       db((< ME ; U ; U' ; U'' ; U3 ; VDS ; MNS ; VES > MIS), MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = db((< ME ; U ; U' ; U'' ; U3 ; VDS ; MNS ; VE # VES > MIS), MNS', VIS, VES', MNS'', MNS3, MNS4, QIL) .
  eq setUpViewDeps(ME, VE, DB)
    = warning(DB, '\r 'Error: '\o 'Module header2QidList(ME) 'not 'in 'database. '\n)
    [owise] .

  eq setUpViewExpressionDeps(QI, DB) = DB .
  eq setUpViewExpressionDeps(QI{PL}, DB) = setUpViewExpressionDeps(QI{PL}, PL, DB) .

  eq setUpViewExpressionDeps(VE, (QI, PL),
       db(MIS, MNS, < QI ; DT ; VI ; MNS' ; VES > VIS, VES', MNS'', MNS3, MNS4, QIL))
    = setUpViewExpressionDeps(VE, PL,
        db(MIS, MNS, < QI ; DT ; VI ; MNS' ; VE # VES > VIS, VES', MNS'', MNS3, MNS4, QIL)) .
  eq setUpViewExpressionDeps(VE, (QI, PL),
       db(MIS, MNS, < QI ; VI ; VI' ; MNS' ; VES > VIS, VES', MNS'', MNS3, MNS4, QIL))
    = setUpViewExpressionDeps(VE, PL,
        db(MIS, MNS, < QI ; VI ; VI' ; MNS' ; VE # VES > VIS, VES', MNS'', MNS3, MNS4, QIL)) .
  eq setUpViewExpressionDeps(QI{PL}, PL',
       db(MIS, MNS, < QI ; DT ; VI ; MNS' ; VES > VIS, VES', MNS'', MNS3, MNS4, QIL))
    = db(MIS, MNS, < QI ; DT ; VI ; MNS' ; QI{PL} # VES > VIS, VES', MNS'', MNS3, MNS4, QIL)
    [owise] .
  eq setUpViewExpressionDeps(QI{PL}, PL',
       db(MIS, MNS, < QI ; VI ; VI' ; MNS' ; VES > VIS, VES', MNS'', MNS3, MNS4, QIL))
    = db(MIS, MNS, < QI ; VI ; VI' ; MNS' ; QI{PL} # VES > VIS, VES', MNS'', MNS3, MNS4, QIL)
    [owise] .

  eq setUpViewExpressionDeps(VE, (QI{PL}, PL'),
       db(MIS, MNS, < QI{PL} ; DT ; VI ; MNS' ; VES > VIS, VES', MNS'', MNS3, MNS4, QIL))
    = setUpViewExpressionDeps(VE, PL',
        db(MIS, MNS, < QI{PL} ; DT ; VI ; MNS' ; VE # VES > VIS, VES', MNS'', MNS3, MNS4, QIL)) .
  eq setUpViewExpressionDeps(VE, (QI{PL}, PL'),
       db(MIS, MNS, < QI{PL} ; VI ; VI' ; MNS' ; VES > VIS, VES', MNS'', MNS3, MNS4, QIL))
    = setUpViewExpressionDeps(VE, PL',
        db(MIS, MNS, < QI{PL} ; VI ; VI' ; MNS' ; VE # VES > VIS, VES', MNS'', MNS3, MNS4, QIL)) .
  eq setUpViewExpressionDeps(VE, (QI{PL}, PL'), DB)
    = setUpViewExpressionDeps(VE, PL', DB)
    [owise] .
  eq setUpViewExpressionDeps(VE, empty, DB) = DB .

  op compiledModule : ModuleExpression Database -> Bool .
  op compiledModule : ParameterDecl Database -> Bool .
  op compiledView : ViewExpression Database -> Bool .

  eq compiledView(VE,
       db(MIS, MNS, < VE ; DT ; VI ; MNS' ; VES > VIS, VES', MNS'', MNS3, MNS4, QIL))
    = VI =/= null .
  eq compiledView(ME, DB) = false [owise] .

  eq compiledModule(MN,
       db(< MN ; DT ; U ; U' ; U'' ; VDS ; MNS ; VES > MIS, MNS',
          VIS, VES', MNS'', MNS3, MNS4, QIL))
    = U'' =/= noModule .
  eq compiledModule(MN,
       db(< MN ; U ; U' ; U'' ; U3 ; VDS ; MNS ; VES > MIS, MNS',
          VIS, VES', MNS'', MNS3, MNS4, QIL))
    = U3 =/= noModule .
  eq compiledModule(MN, DB) = false [owise] .

  op insertTermView : ViewExpression Term Database -> Database .
  op insertView : View Database -> Database .
  op getTermView : ViewExpression Database -> Default{Term} .
  op getView : ViewExpression Database -> View .

  eq insertTermView(VE, T,
       db(MIS, MNS, < VE ; DT ; VI ; MNS' ; VES > VIS, VES',
          MNS'', MNS3, MNS4, QIL))
    = delViews(VES,
        delModules(MNS',
          db(MIS, MNS,
            < VE ; T ; null ; emptyModuleNameSet ; emptyViewExpressionSet > VIS, VES',
            MNS'', MNS3, MNS4,
            QIL
            '\g 'Advisory: '\o 'View viewExp2QidList(VE) 'redefined. '\n))) .
  eq insertTermView(VE, T,
       db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, QIL))
    = db(MIS, MNS,
         < VE ; T ; null ; emptyModuleNameSet ; emptyViewExpressionSet > VIS,
         (VE # VES), MNS', MNS'', MNS3, QIL)
    [owise] .

  eq insertView(view VE from ME to ME' is SMS OMS TMS endv,
       db(MIS, MNS, < VE ; DT ; VI ; MNS' ; VES > VIS, VES', MNS'', MNS3, MNS4, QIL))
    = setUpViewExpressionDeps(VE,
        setUpViewDeps(ME, VE,
          setUpViewDeps(ME', VE,
            db(MIS, MNS,
               < VE ; DT ;
                 view VE from ME to ME' is SMS OMS TMS endv ;
                 MNS' ; VES > VIS,
                 VES', MNS'', MNS3, MNS4, QIL)))) .
  eq insertView(view VE{PDL} from ME to ME' is SMS OMS TMS endv,
       db(MIS, MNS, < VE ; DT ; VI ; MNS' ; VES > VIS, VES', MNS'', MNS3, MNS4, QIL))
    = setUpViewExpressionDeps(VE,
        setUpViewDeps(ME, VE,
          setUpViewDeps(ME', VE,
            db(MIS, MNS,
               < VE ; DT ;
                 view VE{PDL} from ME to ME' is SMS OMS TMS endv ;
                 MNS' ; VES > VIS,
                 VES', MNS'', MNS3, MNS4, QIL)))) .
  eq insertView(view VE from ME to ME' is SMS OMS TMS endv,
       db(MIS, MNS, VIS, VES', MNS'', MNS3, MNS4, QIL))
    = setUpViewExpressionDeps(VE,
        setUpViewDeps(ME, VE,
          setUpViewDeps(ME', VE,
            db(MIS, MNS,
               < VE ; (null).Default{Term} ;
                 view VE from ME to ME' is SMS OMS TMS endv ;
                 emptyModuleNameSet ; emptyViewExpressionSet > VIS,
                 VE # VES', MNS'', MNS3, MNS4, QIL))))
    [owise] .
  eq insertView(view VE{PDL} from ME to ME' is SMS OMS TMS endv, db(MIS, MNS, VIS, VES', MNS'', MNS3, MNS4, QIL))
    = setUpViewExpressionDeps(VE,
        setUpViewDeps(ME, VE,
          setUpViewDeps(ME', VE,
            db(MIS, MNS,
               < VE ; (null).Default{Term} ;
                 view VE{PDL} from ME to ME' is SMS OMS TMS endv ;
                 emptyModuleNameSet ; emptyViewExpressionSet > VIS,
                 VE # VES', MNS'', MNS3, MNS4, QIL))))
    [owise] .
  eq insertView(viewError(QIL), DB) = warning(DB, QIL) .
  ceq insertView(view VE:[ViewExpression] from ME:[ModuleExpression] to ME':[ModuleExpression] is SMS:[SortMappingSet] OMS:[OpMappingSet] TMS:[StratMappingSet] endv, DB)
    = warning(DB, 'The 'view QIL QI if QI == '`) then '\s else nil fi 'contains 'errors.)
    if not view VE:[ViewExpression] from ME:[ModuleExpression] to ME':[ModuleExpression] is SMS:[SortMappingSet] OMS:[OpMappingSet] TMS:[StratMappingSet] endv :: View
    /\ QIL QI := eMetaPrettyPrint(VE:[ViewExpression])
    [owise] .
  ceq insertView(view VE:[ViewExpression]{PDL:[ParameterDeclList]} from ME:[ModuleExpression] to ME':[ModuleExpression] is SMS:[SortMappingSet] OMS:[OpMappingSet] TMS:[StratMappingSet] endv, DB)
    = warning(DB, 'The 'view QIL QI if QI == '`) then '\s else nil fi 'contains 'errors.)
    if not view VE:[ViewExpression]{PDL:[ParameterDeclList]} from ME:[ModuleExpression] to ME':[ModuleExpression] is SMS:[SortMappingSet] OMS:[OpMappingSet] TMS:[StratMappingSet] endv :: View
    /\ QIL QI := eMetaPrettyPrint(VE:[ViewExpression])
    [owise] .

  eq getTermView(VE,
       db(MIS, MNS, (< VE ; DT ; VI ; MNS' ; VES > VIS), VES', MNS'', MNS3, MNS4, QIL))
    = DT .
  eq getTermView(VE, db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, QIL))
    = qidError('\r 'Error: '\o 'View viewExp2QidList(VE) 'not 'in 'database. '\n)
    [owise] .

  eq getView(VE,
       db(MIS, MNS, < VE ; DT ; VI ; MNS' ; VES > VIS, VES', MNS'', MNS3, MNS4, QIL))
    = VI .
  eq getView(VE,
       db(MIS, MNS, < VE ; VI ; VI' ; MNS' ; VES > VIS, VES', MNS'', MNS3, MNS4, QIL))
    = VI' .
  eq getView(VE, db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, QIL))
    = viewError('\r 'Error: '\o 'View viewExp2QidList(VE) 'not 'in 'database. '\n)
    [owise] .

*** There are functions to insert the different versions of a unit, and to
*** extract them.  We only give here the equations for the insertion of top
*** units to illustrate the way in which the consistency of the database is
*** maintained.  We assume that when the internal version, the signature, or
*** the flat version of a module is entered in the database, its corresponding
*** top module is already present in it.

  pr 3TUPLE{Term,VariableSet,Module} * (op ((_,_,_)) to <_;_;_>) .

*** extended variable set
  op variableSetError : QidList -> [VariableSet] [ctor format (r o)] .
  eq variableSetError(QIL) variableSetError(QIL') = variableSetError(QIL QIL') .


----  sort Tuple{Term,OpDeclSet,Module} .
----  op <_;_;_> : Default{Term} OpDeclSet Module -> Tuple{Term,OpDeclSet,Module} .
  op error : QidList -> [Tuple{Term,VariableSet,Module}] .

  op insTermModule : ModuleName Module Database -> Database .
  op insTermModule : ModuleName Term Database -> Database .
  op insertTopModule : ModuleExpression [Module] Database -> Database .
  op insertInternalModule : ModuleExpression [Module] Database -> Database .
  op insertFlatModule : ModuleExpression [Module] Database -> Database .
  op insertVars : ModuleExpression [VariableSet] Database -> Database .
  op getTermModule : ModuleExpression Database -> [Tuple{Term,VariableSet,Module}] .
  op getTopModule : ModuleExpression Database -> [Module] .
  op getInternalModule : ModuleExpression Database -> [Module] .
  op getFlatModule : ModuleExpression Database -> [Module] .
  op getFlatModuleNeg : ModuleExpression Database -> [Module] .
  op getVars : ModuleExpression Database -> [VariableSet] .
  op insertTopModule : ParameterDecl [Module] Database -> Database .
  op insertInternalModule : ParameterDecl [Module] Database -> Database .
  op insertFlatModule : ParameterDecl [Module] Database -> Database .
  op insertVars : ParameterDecl [OpDeclSet] Database -> Database .
  op getTermModule : ParameterDecl Database -> [Tuple{Term,VariableSet,Module}] .
  op getTopModule : ParameterDecl Database -> [Module] .
  op getInternalModule : ParameterDecl Database -> [Module] .
  op getFlatModule : ParameterDecl Database -> [Module] .
  op getFlatModuleNeg : ParameterDecl Database -> [Module] .
  op getVars : ParameterDecl Database -> [VariableSet] .

  eq insTermModule(MN, T,
       db(< MN ; DT ; U ; U' ; U'' ; VDS ; MNS ; VES > MIS, MNS',
          VIS, VES', MNS'', MNS3, MNS4, QIL))
    = delModules(MNS,
          delViews(VES,
            db(< MN ; T ; noModule ; noModule ; noModule ; none ;
                 emptyModuleNameSet ; emptyViewExpressionSet > MIS,
               MNS', VIS, VES', MNS'', MNS3, MNS4,
               QIL
               '\g 'Advisory: '\o 'Module header2QidList(MN) 'redefined. '\n))).
  eq insTermModule(MN, T,
       db(< MN ; U ; U' ; U'' ; U3 ; VDS ; MNS ; VES > MIS, MNS',
          VIS, VES', MNS'', MNS3, MNS4, QIL))
    = delModules(MNS,
          delViews(VES,
            db(< MN ; T ; noModule ; noModule ; noModule ; none ;
                 emptyModuleNameSet ; emptyViewExpressionSet > MIS,
               MNS', VIS, VES', MNS'', MNS3, MNS4,
               QIL
               '\g 'Advisory: '\o 'Module header2QidList(MN) 'redefined. '\n))).
  eq insTermModule(MN, T,
       db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, QIL))
    = db(< MN ; T ; noModule ; noModule ; noModule ; none ;
           emptyModuleNameSet ; emptyViewExpressionSet > MIS,
         MN . MNS, VIS, VES, MNS', MNS'', MNS3, QIL)
    [owise] .
  eq insTermModule(MN, qidError(QIL), DB) = warning(DB, QIL) .
  eq insTermModule(MN, unitError(QIL), DB) = warning(DB, QIL) .

  eq insTermModule(MN, U,
       db(< MN ; DT ; U' ; U'' ; U3 ; VDS ; MNS ; VES > MIS, MNS',
          VIS, VES', MNS'', MNS3, MNS4, QIL))
    = delModules(MNS,
          delViews(VES,
            db(< MN ; U ; noModule ; noModule ; noModule ; none ;
                 emptyModuleNameSet ; emptyViewExpressionSet > MIS,
               MNS', VIS, VES', MNS'', MNS3, MNS4,
               QIL
               '\g 'Advisory:
               '\o 'Module header2QidList(MN) 'redefined. '\n))).
  eq insTermModule(MN, U,
       db(< MN ; U' ; U'' ; U3 ; U4 ; VDS ; MNS ; VES > MIS, MNS',
          VIS, VES', MNS'', MNS3, MNS4, QIL))
    = delModules(MNS,
          delViews(VES,
            db(< MN ; U ; noModule ; noModule ; noModule ; none ;
                 emptyModuleNameSet ; emptyViewExpressionSet > MIS,
               MNS', VIS, VES', MNS'', MNS3, MNS4,
               QIL
               '\g 'Advisory:
               '\o 'Module header2QidList(MN) 'redefined. '\n))).
  eq insTermModule(MN, U,
       db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, QIL))
    = db(< MN ; U ; noModule ; noModule ; noModule ; none ;
           emptyModuleNameSet ; emptyViewExpressionSet > MIS,
         MN . MNS, VIS, VES, MNS', MNS'', MNS3, QIL)
    [owise] .
  eq insTermModule(MN, qidError(QIL), DB) = warning(DB, QIL) .
  eq insTermModule(MN, unitError(QIL), DB) = warning(DB, QIL) .

  eq insertTopModule(MN, U,
       db(< MN ; null ; U' ; U'' ; U3 ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = db(< MN ; null ; U ; noModule ; noModule ; VDS ; MNS ; VES > MIS,
         MNS', VIS, VES', MNS'', MNS3, MNS4,
         QIL
         '\r 'Advisory: '\o
         'Internally 'generated 'module header2QidList(MN) 'redefined. '\n) .
  eq insertTopModule(MN, U,
       db(< MN ; T ; U' ; U'' ; U3 ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = setUpModuleDeps(U,
        db(< MN ; T ; U ; noModule ; noModule ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL)) .
  eq insertTopModule(MN, U,
       db(< MN ; U' ; U'' ; U3 ; U4 ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = setUpModuleDeps(U,
        db(< MN ; U' ; U ; noModule ; noModule ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL)) .
  eq insertTopModule(MN, U,
       db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, QIL))
    = setUpModuleDeps(U,
        db(< MN ; null ; U ; noModule ; noModule ;
              none ; emptyModuleNameSet ; emptyViewExpressionSet > MIS,
           MN . MNS, VIS, VES, MNS', MNS'', MNS3, QIL))
    [owise] .
  eq insertTopModule(MN, unitError(QIL), DB) = warning(DB, QIL) .

  eq insertInternalModule(MN, U,
       db(< MN ; DT ; U' ; U'' ; U3 ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = db(< MN ; DT ; U' ; U ; U3 ; VDS ; MNS ; VES > MIS,
         MNS', VIS, VES', MNS'', MNS3, MNS4, QIL) .
  eq insertInternalModule(MN, U,
       db(< MN ; U' ; U'' ; U3 ; U4 ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = db(< MN ; U' ; U'' ; U ; U4 ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL) .
  eq insertInternalModule(MN, unitError(QIL), DB) = warning(DB, QIL) .

  eq insertFlatModule(MN, U,
       db(< MN ; DT ; U' ; U'' ; U3 ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = db(< MN ; DT ; U' ; U'' ; U ; VDS ; MNS ; VES > MIS,
         MNS', VIS, VES', MNS'', MNS3, MNS4, QIL) .
  eq insertFlatModule(MN, U,
       db(< MN ; U' ; U'' ; U3 ; U4 ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = db(< MN ; U' ; U'' ; U3 ; U ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL) .
  eq insertFlatModule(MN, unitError(QIL), DB) = warning(DB, QIL) .

  eq insertVars(MN, VDS,
       db(< MN ; DT ; U' ; U'' ; U3 ; VDS' ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = db(< MN ; DT ; U' ; U'' ; U3 ; VDS ; MNS ; VES > MIS,
         MNS', VIS, VES', MNS'', MNS3, MNS4, QIL) .
  eq insertVars(MN, VDS,
       db(< MN ; U' ; U'' ; U3 ; U4 ; VDS' ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = db(< MN ; U' ; U'' ; U3 ; U4 ; VDS ; MNS ; VES > MIS,
         MNS', VIS, VES', MNS'', MNS3, MNS4, QIL) .
  eq insertVars(MN, variableSetError(QIL), DB) = warning(DB, QIL) .

  eq getTermModule(MN,
       db(< MN ; null ; U ; U' ; U'' ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = error('\r 'Error: '\o header2QidList(MN) 'is 'an 'internal 'module. '\n) .
  eq getTermModule(MN,
       db(< MN ; DT ; U ; U' ; U'' ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = < DT ; none ; noModule > .
  eq getTermModule(MN,
       db(< MN ; U ; U' ; U'' ; U3 ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = < null ; VDS ; U > .
  eq getTermModule(MN, DB)
    = error('\r 'Error: '\o 'Module header2QidList(MN)  '\n)
    [owise] .

  eq getTopModule(MN,
      db(< MN ; DT ; U ; U' ; U'' ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = U .
  eq getTopModule(MN,
       db(< MN ; U ; U' ; U'' ; U3 ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = U' .
  eq getTopModule(MN, DB)
    = unitError('\r 'Error: '\o 'Module header2QidList(MN) 'not 'in 'database. '\n)
    [owise] .

  eq getInternalModule(MN,
       db(< MN ; DT ; U ; U' ; U'' ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = U' .
  eq getInternalModule(MN,
       db(< MN ; U ; U' ; U'' ; U3 ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = U'' .
  eq getInternalModule(MN, DB)
    = unitError('\r 'Error: '\o 'Module header2QidList(MN) 'not 'in 'database. '\n)
    [owise] .

  eq getVars(MN,
       db(< MN ; DT ; U ; U' ; M ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = VDS .
  eq getVars(MN,
       db(< MN ; U ; U' ; U'' ; M ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = VDS .
  eq getVars(MN, DB) = none [owise] .

*** The name of the signature and the flattened module is not the
*** module expression used as the name of the module but the result of
*** converting it into a quoted identifier.

  eq getFlatModule(MN,
       db(< MN ; DT ; U ; U' ; M ; VDS ; MNS ; VES > MIS, MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = if M == noModule
      then unitError('\r 'Error: '\o 'Module header2QidList(MN) 'not 'compiled. '\n)
      else remNegAnns(M)
      fi .
  eq getFlatModule(MN,
       db(< MN ; U ; U' ; U'' ; M ; VDS ; MNS ; VES > MIS, MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = if M == noModule
      then unitError('\r 'Error: '\o 'Module header2QidList(MN) 'not 'compiled. '\n)
      else remNegAnns(M)
      fi .
  eq getFlatModule(MN, DB)
    = unitError('\r 'Error: '\o 'Module header2QidList(MN) 'not 'in 'database. '\n)
    [owise] .

  *** Handling of negative annotations (by Santiago Escobar)

  eq getFlatModuleNeg(MN,
       db(< MN ; DT ; U ; U' ; M ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = M .
  eq getFlatModuleNeg(MN,
       db(< MN ; U ; U' ; U'' ; M ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = M .
  eq getFlatModuleNeg(MN,
       db(< MN ; DT ; U ; U' ; noModule ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = unitError('\r 'Error: '\o
                'Module header2QidList(MN) 'not 'compiled. '\n) .
  eq getFlatModuleNeg(MN,
      db(< MN ; U ; U' ; U'' ; noModule ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = unitError('\r 'Error: '\o
                'Module header2QidList(MN) 'not 'compiled. '\n) .
  eq getFlatModuleNeg(MN, DB)
    = unitError('\r 'Error: '\o 'Module header2QidList(MN) 'not 'in 'database. '\n)
    [owise] .

  *** removeNegAnnotations
  op remNegAnns : Module -> Module .
  op remNegAnns : OpDeclSet -> OpDeclSet .
  op remNegAnns : AttrSet -> AttrSet .
  op remNegAnns : IntList -> IntList .

  eq remNegAnns(M) = setOps(M, remNegAnns(getOps(M))) .

  eq remNegAnns(op F : TyL -> Ty [AtS] . OPDS)
    = op F : TyL -> Ty [remNegAnns(AtS)] . remNegAnns(OPDS) .
  eq remNegAnns((none).OpDeclSet) = (none).OpDeclSet .

  eq remNegAnns(strat(NL:NatList) AtS) = strat(NL:NatList) AtS .
  eq remNegAnns(strat(IL:IntList) AtS) = AtS [owise] .
  eq remNegAnns(AtS) = AtS [owise] .

endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

***
*** The Evaluation of Modules
***

*** The general principle for the evaluation of units in our design consists in
*** first evaluating any module expression, reducing it to a canonical form in
*** which only unit inclusions appear, that is, to a unit hierarchy, which can
*** be seen as a partial order of unit inclusions. The design of the Full Maude
*** system has been based upon the principle of evaluating all module
*** expressions to irreducible structured units, and on using the flat version
*** of the units only for execution purposes. We have then two different
*** processes clearly distinguished: a first step in which the structured unit
*** is evaluated and reduced to its normal form, and a second step in which
*** this normal form is flattened.

*** As explained in Section~\ref{execution-environment}, the process of
*** evaluation to normal form is also responsible for the parsing of the
*** bubbles in the premodules, which is accomplished once the signature has
*** been built. The parsing of bubbles is discussed in
*** Section~\ref{bubble-parsing}. To be able to handle the \texttt{up}
*** function and the \texttt{down} command presented in
*** Section~\ref{structured-specifications}, it is necessary to be able to
*** move terms and modules from one level of reflection to another. The
*** functionality to move between levels is presented in
*** Section~\ref{changing-levels}, where functions \texttt{up} and
*** \texttt{down} on sorts \texttt{Module} and \texttt{Term} are defined. The
*** transformation of object-oriented modules into system modules in discussed
*** in Section~\ref{omod2modfunction}. The evaluation of module expressions is
*** discussed in Sections~\ref{evalModExp}, \ref{application-of-maps},
*** \ref{instantiation}, and~\ref{renaming}.

***
*** Changing Levels
***

*** Moving terms of sorts \texttt{Term} and \texttt{Module} from one
*** level of reflection to another is possible thanks to the
*** \texttt{up} and \texttt{down} functions, which are defined,
*** respectively, in the following modules \texttt{MOVE-UP} and
*** \texttt{MOVE-DOWN}.

***
*** The \texttt{up} Function
***

*** Given a term of sort \texttt{Module} or \texttt{Term}, the
*** \texttt{up} function, defined in the following module
*** \texttt{MOVE-UP}, returns the term metarepresenting it. The
*** function is just call the \texttt{upTerm} predefined function.

*** We shall see in Section~\ref{bubble-parsing} how the \texttt{up} function
*** is used to evaluate the homonymous function discussed in
*** Section~\ref{structured-specifications}. In Section~\ref{instantiation} we
*** shall discuss how the \texttt{up} function is used to evaluate the
*** \texttt{META-LEVEL} module expression (see
*** Section~\ref{structured-specifications}).

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod MOVE-UP is
---  pr META-LEVEL + PRE-VARIANT .
  pr META-LEVEL .
  pr CONVERSION .
  op up : Module -> Term .
  op up : Term -> Term .
  op up : EquationSet -> Term .

  eq up(M:Module) = upTerm(M:Module) .
  eq up(T:Term) = upTerm(T:Term) .
  eq up(EqS:EquationSet) = upTerm(EqS:EquationSet) .

endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

***
*** Parsing of Bubbles
***

*** As discussed in Section~\ref{implementation-introduction}, in Full Maude,
*** the parsing process is split into two phases. In a first stage, the input
*** is parsed using the top-level grammar for Full Maude modules, theories,
*** views, and commands. Once this first stage is completed, we get a term
*** with bubbles in it, which is converted into a module, theory, or view.
*** This unit or view may still have the bubbles in it. We say that a module
*** with bubbles is a premodule, a view with bubbles a preview, and so on. The
*** second stage of the process consists in taking this preunit or preview and
*** converting the bubbles in it into terms by parsing them in the appropriate
*** signatures, obtaining a `valid' unit or view out of it, or otherwise a
*** parsing error. In the case of commands, if they contain any bubble, the
*** same will have to be done. All bubbles have to be parsed in the
*** appropriate signature before any further processing can be done with the
*** module, view, or command in which they appear.

***
*** Parsing of Module Expressions
***

*** Before introducing the \texttt{parseDecl} function, we present some
*** auxiliary functions. For example, the following functions
*** \texttt{parseType}, \texttt{parseSortSet}, and \texttt{parseTypeList}
*** return, respectively, the sort, set of sorts, and list of sorts
*** represented by the term given as argument. Note that these functions, as
*** most of the functions in this module, are partial functions. We assume
*** that the term given as argument is in fact the representation of, for
*** example, a valid sort, or set of sorts, etc. In the case of
*** \texttt{parseDecl} we assume that the term is the representation of a
*** predeclaration.

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod FM-MOD-EXP-PARSING is
  pr MOVE-DOWN .
  pr FM-INT-LIST .
  -----MI pr FM-VIEW-EXPR-TO-QID .

  vars T T' T'' T3 T4 : Term .
  vars T? T?' : [Term] .
  var  TL TL' : TermList .
  var  QIL  : QidList .
  var  Ct : Constant .
  var  AtS : AttrSet .
  vars QI F : Qid .
  var  CD? : [Condition] .
  vars S S' : Sort .
  var  TyL : TypeList .

  op parseSort : Term ~> Sort .
  op parseType : Term ~> Type .
  op parseSortSet : Term ~> SortSet .
  op parseTypeList : Term ~> TypeList .
  op parseViewExpression : Term ~> ViewExpression .
  op parseParameterList : Term ~> ParameterList .

  eq parseSort('sortToken[T])
    = if downQid(T) :: Type
      then downQid(T)
      else qidError('\r 'Warning: '\o downQid(T) 'is 'not 'a 'valid 'sort. '\n)
      fi .
  eq parseSort('_`{_`}[T, T'])
    = qid(string(parseSort(T))
          + "{" + string(parameterList2Qid(parseParameterList(T'))) + "}") .
  eq parseSort(T) = qidError('\r 'Warning: '\o 'invalid 'sort. '\n) [owise] .

  eq parseType('`[_`][T])
    ---- = kind(parseSort(T)) .
    = qid("[" + string(parseSort(T)) + "]") .
  eq parseType(T) = parseSort(T) [owise] .

  eq parseSortSet('__[T, T']) = (parseSort(T) ; parseSortSet(T')) .
  eq parseSortSet(T) = parseSort(T) [owise].

  eq parseTypeList('__[T, T']) = (parseType(T) parseTypeList(T')) .
  eq parseTypeList(T) = parseType(T) [owise] .

  eq parseViewExpression('viewToken[T])
    = if downQid(T) :: Sort
      then downQid(T)
      else qidError('\r 'Warning: '\o downQid(T) 'is 'not 'a 'valid 'sort. '\n)
      fi .
  eq parseViewExpression('_`{_`}[T, T'])
    = parseViewExpression(T){parseParameterList(T')} .
  eq parseViewExpression(T)
    = qidError('\r 'Warning: '\o 'invalid 'view 'expression. '\n)
    [owise] .

  eq parseParameterList('_`,_[T, T'])
    = parseViewExpression(T), parseParameterList(T') .
  eq parseParameterList(T) = parseViewExpression(T) [owise] .

*** The function \texttt{parseModExp} takes a term representing a
*** module expression and returns the corresponding term in sort
*** \texttt{ModuleExpression}. In case of adding new constructors for module
*** expressions, as it will be done in Section~\ref{extension}, new equations d
*** efining the semantics of the function on them will have to be given.

  op parseModExp : Term -> ModuleExpression .
  op parseMaps : Term -> RenamingSet .

  op parseAttrs : Term -> AttrSet .

  eq parseModExp('token[T]) = downQid(T) .
  eq parseModExp('`(_`)[T]) = parseModExp(T) .
  eq parseModExp('_`{_`}[T, T'])
    = _`{_`}(parseModExp(T), parseParameterList(T')) .
  eq parseModExp('_*`(_`)[T, T']) = _*`(_`)(parseModExp(T), parseMaps(T')) .
  eq parseModExp('_+_[T, T']) = parseModExp(T) + parseModExp(T') .
  eq parseModExp('TUPLE`[_`]['token[T]]) = TUPLE[parseNat(T)] .
  eq parseModExp('POWER`[_`]['token[T]]) = POWER[parseNat(T)] .

  eq parseMaps('_`,_[T, T']) = (parseMaps(T), parseMaps(T')) .

  eq parseMaps('sort_to_[T, T']) = (sort parseType(T) to parseType(T')) .
  eq parseMaps('label_to_['token[T], 'token[T']])
    = (label downQid(T) to downQid(T')) .
  eq parseMaps('class_to_[T, T']) = (class parseType(T) to parseType(T')) .
  eq parseMaps('attr_._to_[T, 'token[T'], 'token[T'']])
    = (attr downQid(T') . parseType(T) to downQid(T'')) .
  eq parseMaps('msg_to_['token[T], 'token[T']])
    = (msg downQid(T) to downQid(T')) .
  eq parseMaps('msg_:_->_to_['token[T], T', T'', 'token[T3]])
    = (msg downQid(T) : parseTypeList(T') -> parseType(T'') to downQid(T3)) .
  eq parseMaps('msg_:`->_to_['token[T], T', 'token[T'']])
    = (msg downQid(T) : nil -> parseType(T') to downQid(T'')) .
  eq parseMaps('op_to_`[_`]['token[T], 'token[T'], T''])
    = (op downQid(T) to downQid(T') [parseAttrs(T'')]) .
  eq parseMaps('op_:_->_to_`[_`]['token[T], T', T'', 'token[T3], T4])
    = (op downQid(T) : parseTypeList(T') -> parseType(T'') to downQid(T3)
            [parseAttrs(T4)]) .
  eq parseMaps('op_:`->_to_`[_`]['token[T], T', 'token[T''], T3])
    = (op downQid(T) : nil -> parseType(T') to downQid(T'')
          [parseAttrs(T3)]) .
  eq parseMaps('op_:_~>_to_`[_`]['token[T], T', T'', 'token[T3], T4])
    = (op downQid(T) : kind(parseTypeList(T')) -> kind(parseType(T''))
            to downQid(T3) [parseAttrs(T4)]) .
  eq parseMaps('op_:`~>_to_`[_`]['token[T], T', 'token[T''], T3])
    = (op downQid(T) : nil -> kind(parseType(T')) to downQid(T'')
          [parseAttrs(T3)]) .
  eq parseMaps('op_to_['token[T], 'token[T']])
    = (op downQid(T) to downQid(T') [none]) .
  eq parseMaps('op_:_->_to_['token[T], T', T'', 'token[T3]])
    = (op downQid(T) : parseTypeList(T') -> parseType(T'') to downQid(T3)
          [none]) .
  eq parseMaps('op_:`->_to_['token[T], T', 'token[T'']])
    = (op downQid(T) : nil -> parseType(T') to downQid(T'') [none]) .
  eq parseMaps('op_:_~>_to_['token[T], T', T'', 'token[T3]])
    = (op downQid(T) : kind(parseTypeList(T')) -> kind(parseType(T''))
          to downQid(T3) [none]) .
  eq parseMaps('op_:`~>_to_['token[T], T', 'token[T'']])
    = (op downQid(T) : nil -> kind(parseType(T')) to downQid(T'') [none]) .
  eq parseMaps('strat_to_['token[T], 'token[T']])
    = (strat downQid(T) to downQid(T')) .
  eq parseMaps('strat_:_@_to_['token[T], T', T'', 'token[T3]])
    = (strat downQid(T) : parseTypeList(T') @ parseType(T'') to downQid(T3)) .
  eq parseMaps('strat_@_to_['token[T], T', 'token[T'']])
    = (strat downQid(T) : nil @ parseType(T') to downQid(T'')) .

  eq parseAttrs('__[T, T']) = (parseAttrs(T) parseAttrs(T')) .
  eq parseAttrs('assoc.@Attr@) = assoc .
  eq parseAttrs('associative.@Attr@) = assoc .
  eq parseAttrs('comm.@Attr@) = comm .
  eq parseAttrs('commutative.@Attr@) = comm .
  eq parseAttrs('idem.@Attr@) = idem .
  eq parseAttrs('idempotent.@Attr@) = idem .
  eq parseAttrs('id:_[T]) = none .
  eq parseAttrs('identity:_[T]) = none .
  eq parseAttrs('left`id:_[T]) = none .
  eq parseAttrs('left`identity:_[T]) = none .
  eq parseAttrs('right`id:_[T]) = none .
  eq parseAttrs('right`identity:_[T]) = none .
  eq parseAttrs('poly`(_`)[T]) = poly(parseInt(T)) .
  eq parseAttrs('strat`(_`)[T]) = none .
  eq parseAttrs('strategy`(_`)[T]) = none .
  eq parseAttrs('memo.@Attr@) = none .
  eq parseAttrs('memoization.@Attr@) = none .
  eq parseAttrs('prec_['token[T]]) = prec(parseNat(T)) .
  eq parseAttrs('precedence_['token[T]]) = prec(parseNat(T)) .
  eq parseAttrs('prec_['`(_`)['token[T]]]) = prec(parseNat(T)) .
  eq parseAttrs('precedence_['`(_`)['token[T]]]) = prec(parseNat(T)) .
  eq parseAttrs('gather`(_`)['neTokenList[T]]) = gather(downQidList(T)) .
  eq parseAttrs('gathering`(_`)['neTokenList[T]]) = gather(downQidList(T)) .
  eq parseAttrs('format`(_`)['neTokenList[T]]) = none .
  eq parseAttrs('ctor.@Attr@) = ctor .
  eq parseAttrs('constructor.@Attr@) = ctor .
  eq parseAttrs('frozen.@Attr@) = none .
  eq parseAttrs('frozen`(_`)[T]) = none .
  eq parseAttrs('iter.@Attr@) = iter .
  eq parseAttrs('ditto.@Attr@) = ditto .
  eq parseAttrs('special`(_`)[T]) = parseSpecial(parseHookList(T)) .
  eq parseAttrs('config.@Attr@) = config .
  eq parseAttrs('object.@Attr@) = object .
  eq parseAttrs('msg.@Attr@) = msg .
  eq parseAttrs('message.@Attr@) = msg .
  eq parseAttrs('metadata_['token[T]]) = metadata(downString(downQid(T))) .
  eq parseAttrs('variant.@Attr@) = variant .
  eq parseAttrs('nonexec.@Attr@) = nonexec .

  op parseSpecial : Set<Hook> -> Attr .
  op parseHookList : Term -> Set<Hook> .
  op hookList : Set<Hook> -> HookList .
  sort Set<Hook> .
  subsort Hook < Set<Hook> .
  op none : -> Set<Hook> .
  op _._ : Set<Hook> Set<Hook> -> Set<Hook> [assoc comm id: none] .
  var  SH : Set<Hook> .
  var  H : Hook .

  eq parseSpecial(none) = none .
  eq parseSpecial(SH) = special(hookList(SH)) [owise] .

  eq parseHookList('__[T, TL]) = parseHookList(T) . parseHookList(TL) .
  eq parseHookList('id-hook_['token[T]]) = id-hook(downQid(T), nil) .
  eq parseHookList('id-hook_`(_`)['token[T], 'neTokenList[T']])
    = id-hook(downQid(T), downQidList(T')) .
  eq parseHookList(
       'op-hook_`(_:_->_`)[
          'token[T], 'token[T'], 'neTokenList[T''], 'token[T3]])
    = op-hook(downQid(T), downQid(T'), downTypes(T''), downQid(T3)) .
  eq parseHookList('op-hook_`(_:`->_`)['token[T], 'token[T'], 'token[T'']])
    = op-hook(downQid(T), downQid(T'), nil, downQid(T'')) .
  eq parseHookList(
       'op-hook_`(_:_~>_`)[
          'token[T], 'token[T'], 'neTokenList[T''], 'token[T3]])
    = op-hook(downQid(T), downQid(T'), downTypes(T''), downQid(T3)) .
  eq parseHookList('op-hook_`(_:`~>_`)['token[T], 'token[T'], 'token[T'']])
    = op-hook(downQid(T), downQid(T'), nil, downQid(T'')) .
  eq parseHookList('term-hook_`(_`)['token[T], T']) = none .

  eq hookList(H) = H .
  eq hookList(H . SH) = H hookList(SH) [owise] .

*** Given a term representing a machine integer, the function
*** \texttt{parseInt} returns the corresponding integer.

  op parseNat : Term -> Nat .

  op parseInt : Term -> Int .
  op parseInt : TermList -> IntList .

  eq parseInt(('neTokenList['__[TL]], TL')) = parseInt(TL) parseInt(TL') .
  eq parseInt(('neTokenList[QI], TL)) = parseInt(QI) parseInt(TL) .
  eq parseInt(empty) = nil .

  eq parseInt((T, TL)) = parseInt(T) parseInt(TL) [owise] .
  eq parseInt(nil) = nil .

  eq parseInt(Ct)
    = downNat(
        qid(substr(string(getName(Ct)), 1, length(string(getName(Ct))))
            + ".Int")) .

  eq parseNat(Ct)
    = downNat(
        qid(substr(string(getName(Ct)), 1, length(string(getName(Ct))))
            + ".Nat")) .

endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

***
*** Parsing of Bubbles
***

*** In the following module \texttt{BUBBLE-PARSING}, the definitions for the
*** basic processing of bubbles are introduced. In it we declare a function
*** \texttt{solveBubbles} which takes a bubble and some other arguments and
*** returns the term resulting from parsing it.


-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod BUBBLE-PARSING is
  pr DATABASE .
  pr MOVE-UP .
  pr MOVE-DOWN .
  pr FM-MOD-EXP-PARSING .
  pr FM-PRINT-SYNTAX-ERROR .

  vars T T' : Term .
  vars M M' : Module .
  var  B : Bool .
  var  QIL : QidList .
  vars DB DB' : Database .
  var  TL : TermList .
  var  S : Sort .
  var  QI QI' F : Qid .
  var  OPDS : OpDeclSet .
  var  VDS : VariableSet .
  var  C : Constant .
  var  V : Variable .
  var  N : Nat .
  var  Tp : Type .
  var  RP : [ResultPair] .
  var  MN : ModuleName .
  var  ME : ModuleExpression .
  var  U : Module .
  var  Cond : Condition .

  op resultPairError : QidList -> [ResultPair] [ctor] .

*** As we shall see in Section~\ref{evaluation}, a declaration importing the
*** predefined module \texttt{UP} (see Section~\ref{non-built-in-predefined})
*** is added to all modules importing the \texttt{META-LEVEL} module. The
*** \texttt{solveBubbles} function is called with a `flag' indicating whether
*** the module can contain calls to the \texttt{up} function or not. Thus,
*** when we call \texttt{metaParse} with some bubble and the module in which
*** such bubble has to be parsed, if there are occurrences of the function
*** \texttt{up} in it, they will be of the form \verb~'token[T]]~ or
*** \verb~'up['token[T], 'bubble[T']]~ for terms \texttt{T} and \texttt{T'}.
*** The function \texttt{solveUps} will evaluate them.

  op solveBubbles : Term Module Bool VariableSet Database -> [Term] .
  op solveUps : TermList Database -> [TermList] .
  op solveUpsCondition : Condition Database -> Condition .
  op solveUpsModExp : TermList Database -> [TermList] .

  eq solveBubbles('ububble[T], M, true, VDS, DB)
    = solveBubbles('bubble[T], M, true, VDS, DB) .
  ceq solveBubbles('bubble[T], M, true, VDS, DB)
    *** if META-LEVEL is a submodule the ups need to be solved
    = if RP :: ResultPair
      then solveUps(getTerm(RP), DB)
      else qidError('\r 'Warning: '\o printSyntaxError(RP, QIL) '\n
                    '\r 'Error: '\o 'no 'parse 'for QIL '\n)
      fi
    if QIL := downQidList(T)
    /\ RP := metaParse(M, VDS, QIL, anyType) .

  eq solveBubbles('ububble[T], M, false, VDS, DB)
    = solveBubbles('bubble[T], M, false, VDS, DB) .
  ceq solveBubbles('bubble[T], M, false, VDS, DB)
    = if RP :: ResultPair
      then getTerm(RP)
      else qidError('\r 'Warning: '\o printSyntaxError(RP, QIL) '\n
                    '\r 'Error: '\o 'no 'parse 'for QIL '\n)
      fi
    if QIL := downQidList(T)
    /\ RP := metaParse(M, VDS, QIL, anyType) .

*** The \texttt{solveBubbles1} function is in charge of calling the function
*** \texttt{metaParse}. The flag indicating the inclusion of the module
*** \texttt{META-LEVEL} in the module in which the term appears decides
*** whether the function \texttt{solveUps} is called or not, so the extra
*** price of searching for calls to the \texttt{up} function is paid only
*** when an occurrence of the function is possible. This function takes care
*** of the occurrences of the \texttt{up} function that may exist in such
*** bubbles.

*** The function \texttt{solveUps} goes through the term looking for a term
*** with \texttt{'up} as top operator and \texttt{'token} as top operator of
*** its unique argument if there is only one argument, or with \texttt{'token}
*** and \texttt{'bubble} as top operators of its first and second arguments,
*** respectively, if there are two. If a term of the form
*** \mbox{\texttt{'up['token[T]]}} is reached, it is replaced by the
*** metarepresentation of the flat version of the module in the database with
*** the name given by the token. If a term of form
*** \mbox{\texttt{'up['token[T], 'bubble[T']]}} is reached, the
*** metarepresentation of the result of parsing the bubble in the signature
*** of the module with the name given by the token, after solving possible
*** nested calls to the \texttt{up} function, is returned.

  eq solveUps(QI, DB) = QI .
  eq solveUps(F[TL], DB) = F[solveUps(TL, DB)] [owise] .
  ceq solveUps((T, TL), DB)
    = (solveUps(T, DB), solveUps(TL, DB))
    if TL =/= empty .

  eq solveUps('upModule['token[T]], DB)
    = solveUpsModExp('upModule['token[T]], DB) .
  eq solveUps('upModule['`(_`)[T]], DB)
    = solveUpsModExp('upModule['`(_`)[T]], DB) .
  eq solveUps('upModule['_`{_`}[T, T']], DB)
    = solveUpsModExp('upModule['_`{_`}[T, T']], DB) .
  eq solveUps('upModule['_*`(_`)[T, T']], DB)
    = solveUpsModExp('upModule['_*`(_`)[T, T']], DB) .
  eq solveUps('upModule['_+_[T, T']], DB)
    = solveUpsModExp('upModule['_+_[T, T']], DB) .
  eq solveUps('upModule['TUPLE`[_`]['token[T]]], DB)
    = solveUpsModExp('upModule['TUPLE`[_`]['token[T]]], DB) .
  eq solveUps('upModule['POWER`[_`]['token[T]]], DB)
    = solveUpsModExp('upModule['POWER`[_`]['token[T]]], DB) .

  eq solveUpsCondition(T = T' /\ Cond, DB)
    = solveUps(T, DB) = solveUps(T', DB) /\ solveUpsCondition(Cond, DB) .
  eq solveUpsCondition(T : S /\ Cond, DB)
    = solveUps(T, DB) : S /\ solveUpsCondition(Cond, DB) .
  eq solveUpsCondition(T := T' /\ Cond, DB)
    = T := solveUps(T', DB) /\ solveUpsCondition(Cond, DB) .
  eq solveUpsCondition(T => T' /\ Cond, DB)
    = solveUps(T, DB) => solveUps(T', DB) /\ solveUpsCondition(Cond, DB) .
  eq solveUpsCondition(nil, DB) = nil .

  ceq solveUpsModExp('upModule[T], DB)
    = up(getFlatModule(MN, DB'))
    if < DB' ; MN > := evalModExp(parseModExp(T), DB)
    /\ unitInDb(MN, DB') .
  ceq solveUpsModExp('upModule[T], DB)
    = qidError('\r 'Error: '\o 'Module header2QidList(MN) 'not 'in 'database. '\n)
    if MN := parseModExp(T)
    [owise] .

  eq solveUps('upTerm[T, 'ububble[T']], DB)
    = solveUps('upTerm[T, 'bubble[T']], DB) .
  eq solveUps('upTerm['token[T], 'bubble[T']], DB)
    = solveUpsModExp('upTerm['token[T], 'bubble[T']], DB) .
  eq solveUps('upTerm['`(_`)[T], 'bubble[T']], DB)
    = solveUpsModExp('upTerm['`(_`)[T], 'bubble[T']], DB) .
  eq solveUps('upTerm['_`{_`}[T, T'], 'bubble[T']], DB)
    = solveUpsModExp('upTerm['_`{_`}[T, T'], 'bubble[T']], DB) .
  eq solveUps('upTerm['_*`(_`)[T, T'], 'bubble[T']], DB)
    = solveUpsModExp('upTerm['_*`(_`)[T, T'], 'bubble[T']], DB) .
  eq solveUps('upTerm['_+_[T, T'], 'bubble[T']], DB)
    = solveUpsModExp('upTerm['_+_[T, T'], 'bubble[T']], DB) .
  eq solveUps('upTerm['TUPLE`[_`]['token[T]], 'bubble[T']], DB)
    = solveUpsModExp('upTerm['TUPLE`[_`]['token[T]], 'bubble[T']], DB) .
  eq solveUps('upTerm['POWER`[_`]['token[T]], 'bubble[T']], DB)
    = solveUpsModExp('upTerm['POWER`[_`]['token[T]], 'bubble[T']], DB) .

  eq solveUpsModExp('upTerm[T, 'ububble[T']], DB)
    = solveUpsModExp('upTerm[T, 'bubble[T']], DB) .
  ceq solveUpsModExp('upTerm[T, 'bubble[T']], DB)
    = if included('META-MODULE, getImports(getInternalModule(MN, DB')), DB')
      then if metaParse(U, VDS, QIL, anyType) :: ResultPair
           then up(solveUps(getTerm(metaParse(U, VDS, QIL, anyType)), DB'))
           else qidError('\r 'Warning: '\o
                  'No 'parse 'for 'argument 'of 'up
                  printSyntaxError(metaParse(U, VDS, QIL, anyType), QIL)
                  '\n)
           fi
      else if metaParse(U, VDS, QIL, anyType) :: ResultPair
           then up(getTerm(metaParse(U, VDS, QIL, anyType)))
           else qidError('\r 'Warning: '\o
                  'No 'parse 'for 'argument 'of 'up
                  printSyntaxError(metaParse(U, VDS, QIL, anyType), QIL)
                  '\n)
           fi
      fi
    if < DB' ; MN > := evalModExp(parseModExp(T), DB)
    /\ U := getFlatModule(MN, DB')
    /\ VDS := getVars(MN, DB')
    /\ QIL := downQidList(T').
  ceq solveUpsModExp('upTerm[T, 'bubble[T']], DB)
    = qidError('\r 'Error: 'op '\o 'Module header2QidList(ME) 'not 'in 'database. '\n)
    if ME := parseModExp(T)
    [owise] .

  eq solveUps('`[_`][QI], DB) = '`[_`][QI] .
  ceq solveUps('`[_`]['token[T]], DB)
    = up(getFlatModule(QI, database(evalModExp(QI, DB))))
    if QI := downQid(T) .
  eq solveUps('`[_`][F[TL]], DB) = '`[_`][F[solveUps(TL, DB)]] [owise] .

endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

***
*** Parsing the Bubbles in a Module
***

*** The \texttt{solveBubbles} function defined in the
*** \texttt{UNIT-BUBBLE-PARSING} module takes a term of sort \texttt{Module} (a
*** preunit in fact) and a signature, and returns the unit resulting from the
*** evaluation (parsing) of all the bubbles in it.

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

view AttrSet from TRIV to META-LEVEL is
  sort Elt to AttrSet .
endv


fmod UNIT-BUBBLE-PARSING is
  pr BUBBLE-PARSING .
  pr DATABASE .
  pr MOVE-UP .
  pr MOVE-DOWN .
  pr FM-PRINT-SYNTAX-ERROR .
  pr FM-PARSE-STRATEGY .

  vars T T' T'' T1 T2 T3 T4 : Term .
  vars T? T?' : [Term] .
  vars TL TL' TL'' : TermList .
  vars TL? TL?' : [TermList] .
  var  B : Bool .
  vars M M' M'' : Module .
  var  DB : Database .
  vars PU U U' : Module .
  var  K : Kind .
  var  KS : KindSet .
  vars S S' : Sort .
  var  SS : SortSet .
  var  VE : ViewExpression .
  vars Ty Ty' Tp : Type .
  vars TyL TyL' : TypeList .
  var  At : Attr .
  vars AtS AtS' AtS'' AtS1 AtS2 : AttrSet .
  var  NL : IntList .
  vars Q QI QI' QI'' QI3 QI4 QI5 V F L : Qid .
  vars QIL QIL' QIL1 QIL2 QIL3 : QidList .
  var  Vs : QidSet .
  var  I : Nat .
  var  Hk : Hook .
  var  HkL : HookList .
  var  MAS : MembAxSet .
  var  Eq : Equation .
  var  EqS : EquationSet .
  var  Rl : Rule .
  var  RlS Rls : RuleSet .
  var  OPD : OpDecl .
  vars OPDS OPDS' OPDS'' : OpDeclSet .
  var  VDS : VariableSet .
  var  CD? : [Condition] .
  var  Ct : Constant .
  var  RP : [ResultPair] .
  var  St : String .
  var  SDfs : StratDefSet .
  var  SDcs StratDecls : StratDeclSet .
  var  Strat : Strategy .
  vars Strat? Strat1? Strat2? : Strategy? .

*** In the parsing of bubbles themselves, we consider three different cases:
*** The case of having one single bubble in which no context is
*** considered (used to parse bubbles in term maps in views and in the
*** special attributes of operators); the case of two bubbles to be parsed in
*** the same connected component (used for bubbles in equations and rules),
*** and the case of one bubble to be parsed in a specific sort (used for the
*** bubbles appearing in the identity element attributes in the declarations
*** of operators, and in membership axioms). These three cases are reduced to
*** the case of one single bubble without context, which is handled by the
*** function \texttt{solveBubbles3}.

  op solveBubblesEq : Term Term Module Bool VariableSet Database -> Term .
  op solveBubblesCEq : Term Term Module Bool VariableSet Database -> Term .
  op solveBubblesRl : Term Term Module Bool VariableSet Database -> Term .
  op solveBubblesCRl : Term Term Module Bool VariableSet Database -> Term .
  op solveBubbles2 : Term [Type] Module Bool VariableSet Database -> Term .
  op solveBubblesCond : Term Module Module Bool VariableSet Database -> [Condition] .

  op conditionError : QidList -> [Condition] [ctor format (r o)] .

*** The case of two bubbles, generated in the case of equations and rules, is
*** reduced to the case with one single bubble using the polymorphic operator
*** \verb~_==_~ and enclosing each of the bubbles in parentheses. Below, we
*** shall see how after calling this function the terms corresponding to each
*** of the bubbles is extracted.

  ceq solveBubblesEq(T, T', M, B, VDS, DB)
    = if RP :: ResultPair
      then if B
           then solveUps(getTerm(RP), DB)
           else getTerm(RP)
           fi
      else qidError('\r 'Warning:
                 '\o printSyntaxError(RP, QIL '= QIL') '\n
                 '\r 'Error: '\o 'no 'parse 'for 'eq QIL '\s '= '\s QIL' '\n)
      fi
    if M' := addOps(op 'eq_=_. : 'Universal 'Universal -> '@@@ [poly(1 2) gather('& '&)] .,
               addSorts('@@@, M))
       /\ QIL := downQidList(T)
       /\ QIL' := downQidList(T')
       /\ RP := metaParse(M', VDS, 'eq QIL '= QIL' '., '@@@) .

  ceq solveBubblesCEq(T, T', M, B, VDS, DB)
    = if RP :: ResultPair
      then if B
           then solveUps(getTerm(RP), DB)
           else getTerm(RP)
           fi
      else qidError('\r 'Warning:
                 '\o printSyntaxError(RP, '`( QIL '`) '= '`( QIL' '`)) '\n
                 '\r 'Error: '\o 'no 'parse 'for 'ceq QIL '\s '= '\s QIL' '\n)
      fi
    if M' := addOps(op 'eq_=_. : 'Universal 'Universal -> '@@@ [poly(1 2) gather('& '&)] .,
               addSorts('@@@, M))
       /\ QIL := downQidList(T)
       /\ QIL' := downQidList(T')
       /\ RP := metaParse(M', VDS, 'eq QIL '= QIL' '., '@@@) .

  eq solveBubblesRl('ububble[T], 'ububble[T'], M, B, VDS, DB)
    = solveBubblesRl(T, T', M, B, VDS, DB) .
  ceq solveBubblesRl(T, T', M, B, VDS, DB)
    = if RP :: ResultPair
      then if B
           then solveUps(getTerm(RP), DB)
           else getTerm(RP)
           fi
      else qidError('\r 'Warning:
                 '\o printSyntaxError(RP, QIL '=> QIL') '\n
                 '\r 'Error: '\o 'no 'parse 'for 'rl QIL '\s '=> '\s QIL' '\n)
      fi
    if M' := addOps(op 'rl_=>_. : 'Universal 'Universal -> '@@@ [poly(1 2) gather('& '&)] .,
               addSorts('@@@, M))
       /\ QIL := downQidList(T)
       /\ QIL' := downQidList(T')
       /\ RP := metaParse(M', VDS, 'rl QIL '=> QIL' '., '@@@)
    [owise] .
  ceq solveBubblesCRl(T, T', M, B, VDS, DB)
    = if RP :: ResultPair
      then if B
           then solveUps(getTerm(RP), DB)
           else getTerm(RP)
           fi
      else qidError('\r 'Warning:
                 '\o printSyntaxError(RP, QIL '=> QIL') '\n
                 '\r 'Error: '\o 'no 'parse 'for 'crl QIL '\s '=> '\s QIL' '\n)
      fi
    if M' := addOps(op 'rl_=>_. : 'Universal 'Universal -> '@@@ [poly(1 2) gather('& '&)] .,
               addSorts('@@@, M))
       /\ QIL := downQidList(T)
       /\ QIL' := downQidList(T')
       /\ RP := metaParse(M', VDS, 'rl QIL '=> QIL' '., '@@@)
    [owise] .

  ceq solveBubbles2(T, T?:Type?, M, true, VDS, DB)
    = if RP :: ResultPair
      then solveUps(getTerm(RP), DB)
      else qidError('\r 'Warning:
                 '\o printSyntaxError(RP, QIL) '\n
                 '\r 'Error: 'No 'parse 'for QIL '\n)
      fi
    if QIL := downQidList(T)
       /\ RP := metaParse(M, VDS, QIL, T?:Type?) .
  ceq solveBubbles2(T, T?:Type?, M, false, VDS, DB)
    = if RP :: ResultPair
      then getTerm(RP)
      else qidError('\r 'Warning: '\o printSyntaxError(RP, QIL) '\n
                 '\r 'Error: 'No 'parse 'for QIL '\n)
      fi
    if QIL := downQidList(T)
       /\ RP := metaParse(M, VDS, QIL, T?:Type?) .

  op addInfoConds : Module -> [Module] .
  op addInfoConds : Module SortSet -> Module .

  eq addInfoConds(M) = addInfoConds(M, getAllSorts(M)) .

  eq addInfoConds(M, '@Token@ ; SS) = addInfoConds(M, SS) .
  eq addInfoConds(M, '@Bubble@ ; SS) = addInfoConds(M, SS) .
  eq addInfoConds(M, '@UBubble@ ; SS) = addInfoConds(M, SS) .
  eq addInfoConds(M, '@StBubble@ ; SS) = addInfoConds(M, SS) .
  eq addInfoConds(M, '@EqLBubble@ ; SS) = addInfoConds(M, SS) .
  eq addInfoConds(M, '@RlLBubble@ ; SS) = addInfoConds(M, SS) .
  eq addInfoConds(M, '@SdLBubble@ ; SS) = addInfoConds(M, SS) .
  eq addInfoConds(M, '@RCBubble@ ; SS) = addInfoConds(M, SS) .
  eq addInfoConds(M, '@RBubble@ ; SS) = addInfoConds(M, SS) .
  eq addInfoConds(M, S ; SS)
    = addInfoConds(
        addOps(op qid(string(S)) : nil -> '@Sort@ [ctor] .
               op '_:_ : S '@Sort@ -> '@Condition@ [ctor prec(71)] ., M),
        SS)
    [owise] .
  eq addInfoConds(M, none)
    = addOps(op '_/\_ : '@Condition@ '@Condition@ -> '@Condition@
                               [ctor assoc prec(73)] .
             op '_=_  : 'Universal 'Universal -> '@Condition@
                               [ctor poly(1 2) gather('& '&) prec(71)] .
             op '_:=_ : 'Universal 'Universal -> '@Condition@
                               [ctor poly(1 2) gather('& '&) prec(71)] .
             op '_=>_ : 'Universal 'Universal -> '@Condition@
                               [ctor poly(1 2) gather('& '&) prec(71)] .,
        addSorts('@Condition@ ; '@Sort@,
          if 'Bool in getSorts(M)
          then addSubsorts(subsort 'Bool < '@Condition@ ., M)
          else M
          fi)) .

  ceq solveBubblesCond(T, M, M', B, VDS, DB)
    = if 'Bool in getSorts(M)
         and-then metaParse(M, VDS, QIL, 'Bool) :: ResultPair
      then if B
           then solveUps(getTerm(metaParse(M, VDS, QIL, 'Bool)), DB) = 'true.Bool
           else getTerm(metaParse(M, VDS, QIL, 'Bool)) = 'true.Bool
           fi
      else if metaParse(M', VDS, QIL, '@Condition@) :: ResultPair
           then if B
                then solveUpsCondition(parseCond(getTerm(metaParse(M', VDS, QIL, '@Condition@))), DB)
                else parseCond(getTerm(metaParse(M', VDS, QIL, '@Condition@)))
                fi
           else conditionError('\r 'Warning: '\o
                  printSyntaxError(metaParse(M', VDS, QIL, '@Condition@), QIL) '\n)
           fi
      fi
    if QIL := downQidList(T) .

  op parseCond : Term -> Condition .

  eq parseCond('_/\_[T, T']) = parseCond(T) /\ parseCond(T') .
  eq parseCond('_=_[T, T']) = T = T' .
  eq parseCond('_:_[T, T']) = T : getName(T') .
  eq parseCond('_:=_[T, T']) = T := T' .
  eq parseCond('_=>_[T, T']) = T => T' .
  eq parseCond(T) = T = 'true.Bool [owise] .

*** Since bubbles can only appear in the identity or special attributes in the
*** declaration of operators, in equations, membership axioms, and rules, the
*** evaluation of bubbles on a preunit is reduced to calls to the
*** \texttt{solveBubbles} functions on each of these sTS of declarations.

  op solveBubblesMod : Module OpDeclSet RuleSet Module Bool VariableSet Database -> Module .
  op solveBubblesModAux : Module RuleSet Module Module Bool VariableSet Database -> Module .

  op solveBubbles : EquationSet Module [Module] Bool VariableSet Database -> EquationSet .
  op solveBubbles : RuleSet Module [Module] Bool VariableSet Database -> RuleSet .
  op solveBubbles : MembAxSet Module [Module] Bool VariableSet Database -> MembAxSet .
  op solveBubbles : StratDefSet Module [Module] Bool VariableSet Database -> StratDefSet .
  op solveBubbles : Condition Module Bool VariableSet Database -> Condition .
  op solveBubblesOps : OpDeclSet OpDeclSet Module Module -> OpDeclSet .
  op solveBubblesOps : OpDeclSet OpDeclSet Module -> OpDeclSet .
  op solveBubblesOpsAux : OpDeclSet Module -> OpDeclSet .
  op solveBubblesAts : AttrSet TypeList Type Module -> AttrSet .
  op solveBubblesHooks : HookList Type Module -> HookList .

  ceq solveBubblesMod(PU, OPDS, Rls, M, B, VDS, DB)
    = solveBubblesModAux( ---- we need to parse rls before solving strategies' bubbles
        setOps(
          setEqs(
            setMbs(
              setRls(PU,
                solveBubbles(getRls(PU), M, M'', B, VDS, DB)),
              solveBubbles(getMbs(PU), M, M'', B, VDS, DB)),
            solveBubbles(getEqs(PU), M, M'', B, VDS, DB)),
          solveBubblesOps(getOps(PU), OPDS, M)),
        Rls, M, M'', B, VDS, DB)
    if M'' := addInfoConds(M) .

  eq solveBubblesModAux(PU, Rls, M, M', B, VDS, DB)
    = setStratDefs(PU,
        solveBubbles(
          getStratDefs(PU),
          setRls(addStratDcls(getStratDcls(PU), M), Rls getRls(PU)),
          M', B, VDS, DB)) .
  eq solveBubblesModAux(unitError(QIL), Rls, M, M', B, VDS, DB)
    = unitError(QIL) .

*** To avoid the parsing ambiguities in the identity elements we add the sort
*** of the operator to be used as context in which doing the parsing. We
*** assume that the term given as identity element of an operator is in the
*** kind of the sort of such operator.

  eq solveBubblesOps(OPDS, OPDS', M)
    = solveBubblesOps(OPDS, OPDS',
        setSubsorts(
          setSorts(emptyFModule('DUMMY), getSorts(M)), getSubsorts(M)), M) .

  ceq solveBubblesOps(op F : TyL -> Ty [ditto AtS] . op F : TyL' -> Ty' [AtS'] . OPDS, OPDS', M, M')
    = solveBubblesOps(
        op F : TyL -> Ty [AtS removeCtorMetadata(AtS'')] . op F : TyL' -> Ty' [AtS''] . OPDS,
        OPDS', M, M')
    if not ditto in AtS'
    /\ sameKind(M, TyL Ty, TyL' Ty')
    /\ AtS'' := AtS' .
  ceq solveBubblesOps(op F : TyL -> Ty [ditto AtS] . OPDS, op F : TyL' -> Ty' [AtS'] . OPDS', M, M')
    = solveBubblesOps(op F : TyL -> Ty [AtS removeCtorMetadata(AtS')] . OPDS, op F : TyL' -> Ty' [AtS'] . OPDS', M, M')
    if not ditto in AtS'
    /\ sameKind(M, TyL Ty, TyL' Ty') .
  eq solveBubblesOps(OPDS, OPDS', M, M')
    = solveBubblesOpsAux(OPDS, M')
    [owise] .

  op removeCtorMetadata : AttrSet -> AttrSet .
  eq removeCtorMetadata(ctor AtS) = removeCtorMetadata(AtS) .
  eq removeCtorMetadata(metadata(St) AtS) = removeCtorMetadata(AtS) .
  eq removeCtorMetadata(AtS) = AtS [owise] .

  eq solveBubblesOpsAux(op F : TyL -> Ty [AtS] . OPDS, M)
    = op F : TyL -> Ty [solveBubblesAts(AtS, TyL, Ty, M)] .
      solveBubblesOpsAux(OPDS, M) .
  eq solveBubblesOpsAux(none, M) = none .

  eq solveBubblesAts(id('bubble[T]) AtS, TyL, Ty, M)
    = (id(solveBubbles2(T, Ty, M, false, none, emptyDatabase))
       solveBubblesAts(AtS, TyL, Ty, M)) .
  eq solveBubblesAts(left-id('bubble[T]) AtS, Ty TyL, Ty', M)
    = (left-id(solveBubbles2(T, Ty, M, false, none, emptyDatabase))
       solveBubblesAts(AtS, Ty TyL, Ty', M)) .
  eq solveBubblesAts(right-id('bubble[T]) AtS, TyL Ty, Ty', M)
    = (right-id(solveBubbles2(T, Ty, M, false, none, emptyDatabase))
       solveBubblesAts(AtS, TyL Ty, Ty', M)) .
  eq solveBubblesAts(special(HkL) AtS, TyL, Ty, M)
    = (special(solveBubblesHooks(HkL, Ty, M))
       solveBubblesAts(AtS, TyL, Ty, M)) .
  eq solveBubblesAts(AtS, TyL, Ty, M) = AtS [owise] .

  eq solveBubblesHooks(term-hook(QI, 'bubble[T]) HkL, Ty, M)
    = term-hook(QI,
        solveBubbles2('bubble[T], anyType, M, false, none, emptyDatabase))
      solveBubblesHooks(HkL, Ty, M) .
  eq solveBubblesHooks(Hk HkL, Ty, M)
    = Hk solveBubblesHooks(HkL, Ty, M)
    [owise] .
  eq solveBubblesHooks(nil, Ty, M) = nil .

*** Since both sides of any equation or rule have to be in the same connected
*** component of sorts, we parse the two bubbles together using the
*** polymorphic operator \verb~_==_~\footnote{Note that if including
*** \texttt{BOOL} the operator \texttt{\_\,==\_\,} is added for each kind.}.
*** That is, given for example an equation as \verb~eq T = T' .~, we parse
*** \verb~T == T'~, forcing them to be parsed in the same connected component,
*** if possible. We add functions \texttt{lhs} and \texttt{rhs} to extract,
*** respectively, the lefthand and righthand side terms from the result. Note
*** that these are partial functions.

  pr 2TUPLE{Term,AttrSet}
       * (op p1_ to term, op p2_ to attrSet,
          op `(_`,_`) : Term AttrSet -> Tuple{Term,AttrSet} to `{_`,_`}) .

  op pullStmtAttrOut : Term VariableSet -> [Tuple{Term,AttrSet}] .
  op pullStmtAttrOutAux : Term TermList AttrSet VariableSet -> [Tuple{Term,AttrSet}] .
  op pullLabelOut : Term -> [Tuple{Term,AttrSet}] .

  eq pullStmtAttrOut(QI, VDS) = {QI, none} .
  eq pullStmtAttrOut('__[QI, QI'], VDS) = {'__[QI, QI'], none} .
  eq pullStmtAttrOut('__[QI, QI', QI''], VDS) = {'__[QI, QI', QI''], none} .
  eq pullStmtAttrOut('__[QI, QI', TL, QI''], VDS)
    = if QI'' =/= ''`].Qid
      then {'__[QI, QI', TL, QI''], none}
      else pullStmtAttrOutAux('__[QI, QI', TL, QI''], (QI, QI', TL), none, VDS)
      fi .

  eq pullStmtAttrOutAux(T, (TL, ''`[.Qid), AtS, VDS)
    = if AtS =/= none
      then {'__[TL], AtS}
      else {T, none}
      fi .
  eq pullStmtAttrOutAux(T, (TL, QI, ''nonexec.Qid), AtS, VDS)
    = pullStmtAttrOutAux(T, (TL, QI), AtS nonexec, VDS) .
  eq pullStmtAttrOutAux(T, (TL, QI, ''variant.Qid), AtS, VDS)
    = pullStmtAttrOutAux(T, (TL, QI), AtS variant, VDS) .
  eq pullStmtAttrOutAux(T, (TL, QI, ''owise.Qid), AtS, VDS)
    = pullStmtAttrOutAux(T, (TL, QI), AtS owise, VDS) .
  eq pullStmtAttrOutAux(T, (TL, QI, ''otherwise.Qid), AtS, VDS)
    = pullStmtAttrOutAux(T, (TL, QI), AtS owise, VDS) .
  eq pullStmtAttrOutAux(T, (TL, QI, ''label.Qid, QI'), AtS, VDS)
    = if downQid(QI') :: Qid
      then pullStmtAttrOutAux(T, (TL, QI), AtS label(downQid(QI')), VDS)
      else {T, none}
      fi .
  eq pullStmtAttrOutAux(T, (TL, QI, ''metadata.Qid, QI'), AtS, VDS)
    = if downString(downQid(QI')) :: String
      then pullStmtAttrOutAux(T, (TL, QI), AtS metadata(downString(downQid(QI'))), VDS)
      else {T, none}
      fi .
  ceq pullStmtAttrOutAux(T, (TL, QI, ''`[.Qid, TL',  ''print.Qid, TL''), AtS, VDS)
    = pullStmtAttrOutAux(T, (TL, QI, ''`[.Qid, TL'), AtS print(printArg(TL'', VDS)), VDS)
    if printArg(TL'', VDS) : QidList .
  eq pullStmtAttrOutAux(T, TL, AtS, VDS) = {T, none} [owise] .

  op printArg : TermList VariableSet ~> QidList .
  ceq printArg((T, TL), V ; VDS)
    = qid(string(downQid(T)) + ":" + string(getType(V))) printArg(TL, VDS)
    if getName(V) = downQid(T) .
  ceq printArg((T, TL), VDS)
    = downQid(T) printArg(TL, VDS)
    if downString(downQid(T)) : String .
  eq printArg(empty, VDS) = nil .

  eq pullLabelOut(QI) = {QI, none} .
  eq pullLabelOut('__[QI, QI']) = {'__[QI, QI'], none} .
  eq pullLabelOut('__[QI, QI', QI'']) = {'__[QI, QI', QI''], none} .
  eq pullLabelOut('__[QI, QI', QI'', QI3]) = {'__[QI, QI', QI'', QI3], none} .
  eq pullLabelOut('__[QI, QI', QI'', QI3, TL])
    = if QI == ''`[.Qid and-then (QI'' == ''`].Qid and-then QI3 == '':.Qid)
      then {'__[TL], label(downQid(QI'))}
      else {'__[QI, QI', QI'', QI3, TL], none}
      fi .

  ops lhs rhs : Term -> Term .
  eq lhs(F[T, T']) = T .
  eq lhs(F[T, T']) = T .
  eq rhs(F[T, T']) = T' .
  eq rhs(F[T, T']) = T' .
  eq lhs(qidError(QIL)) = qidError(QIL) .
  eq rhs(qidError(QIL)) = qidError(QIL) .

  eq solveBubbles(EqS, M, unitError(QIL), B, VDS, DB) = equationError(QIL) .
  eq solveBubbles(RlS, M, unitError(QIL), B, VDS, DB) = ruleError(QIL) .
  eq solveBubbles(MAS, M, unitError(QIL), B, VDS, DB) = membAxError(QIL) .
  eq solveBubbles(SDfs, M, unitError(QIL), B, VDS, DB) = stratDefError(QIL) .

  eq solveBubbles(eq 'eqlbubble[T] = 'rbubble[T'] [AtS] . EqS, M, M', B, VDS, DB)
    = ((eq lhs(solveBubblesEq(term(pullLabelOut(T)), term(pullStmtAttrOut(T', VDS)),
                 M, B, VDS, DB))
          = rhs(solveBubblesEq(term(pullLabelOut(T)), term(pullStmtAttrOut(T', VDS)),
                  M, B, VDS, DB))
            [attrSet(pullLabelOut(T)) attrSet(pullStmtAttrOut(T', VDS)) AtS] .)
       solveBubbles(EqS, M, M', B, VDS, DB)) .
  eq solveBubbles(ceq 'eqlbubble[T] = 'rcbubble[T'] if 'rbubble[T''] = 'true.Bool [AtS] . EqS,
       M, M', B, VDS, DB)
    = (ceq lhs(solveBubblesCEq(term(pullLabelOut(T)), T', M, B, VDS, DB))
          = rhs(solveBubblesCEq(term(pullLabelOut(T)), T', M, B, VDS, DB))
          if solveBubblesCond(term(pullStmtAttrOut(T'', VDS)), M, M', B, VDS, DB)
          [attrSet(pullLabelOut(T)) attrSet(pullStmtAttrOut(T'', VDS)) AtS] .
       solveBubbles(EqS, M, M', B, VDS, DB)) .
  eq solveBubbles((none).EquationSet, M, M', B, VDS, DB) = none .

  eq solveBubbles(rl 'rllbubble[T] => 'rbubble[T'] [AtS] . RlS, M, M', B, VDS, DB)
    = ((rl lhs(solveBubblesRl(term(pullLabelOut(T)),
                 term(pullStmtAttrOut(T', VDS)), M, B, VDS, DB))
        => rhs(solveBubblesRl(term(pullLabelOut(T)),
                 term(pullStmtAttrOut(T', VDS)), M, B, VDS, DB))
             [attrSet(pullLabelOut(T)) attrSet(pullStmtAttrOut(T', VDS)) AtS] .)
       solveBubbles(RlS, M, M', B, VDS, DB)) .
  eq solveBubbles(crl 'rllbubble[T] => 'rcbubble[T'] if 'rbubble[T''] = 'true.Bool [AtS] . RlS,
       M, M', B, VDS, DB)
    = (crl lhs(solveBubblesCRl(term(pullLabelOut(T)), T', M, B, VDS, DB))
          => rhs(solveBubblesCRl(term(pullLabelOut(T)), T', M, B, VDS, DB))
          if solveBubblesCond(term(pullStmtAttrOut(T'', VDS)), M, M', B, VDS, DB)
          [attrSet(pullLabelOut(T)) attrSet(pullStmtAttrOut(T'', VDS)) AtS] .
       solveBubbles(RlS, M, M', B, VDS, DB)) .
  eq solveBubbles((none).RuleSet, M, M', B, VDS, DB) = none .

*** In the call to solve the bubbles in membership axioms we add the sort to
*** which it is constrained to be used as context.

  eq solveBubbles(mb T : S [AtS] . MAS, M, M', B, VDS, DB)
    = ((mb solveBubbles2(term(pullLabelOut(T)), S, M, B, VDS, DB) : S
          [attrSet(pullLabelOut(T)) AtS] .)
       solveBubbles(MAS, M, M', B, VDS, DB)) .
  eq solveBubbles(cmb T : S if T' = 'true.Bool [AtS] . MAS, M, M', B, VDS, DB)
    = ((cmb solveBubbles2(term(pullLabelOut(T)), S, M, B, VDS, DB) : S
          if solveBubblesCond(T', M, M', B, VDS, DB)
          [attrSet(pullLabelOut(T)) AtS] .)
       solveBubbles(MAS, M, M', B, VDS, DB)) .
  eq solveBubbles((none).MembAxSet, M, M', B, VDS, DB) = none .

 ceq solveBubbles(sd 'sdlbubble[T] := 'rbubble[T'] [AtS] . SDfs, M, M', B, VDS, DB)
    = if Strat1? :: CallStrategy
      then if Strat2? :: Strategy
           then sd Strat1? := Strat2? [AtS1 AtS2 AtS] .
           else stratDefError('\r 'Warning:
                      '\o printSyntaxError(Strat2?, QIL2) '\n
                      '\r 'Error: '\o 'no 'parse 'for 'sd QIL1 '\s ':= '\s QIL2 '\n)
           fi
      else stratDefError('\r 'Warning:
                 '\o printSyntaxError(Strat2?, QIL1) '\n
                 '\r 'Error: '\o 'no 'parse 'for 'sd QIL1 '\s ':= '\s QIL2 '\n)
      fi
      solveBubbles(SDfs, M, M', B, VDS, DB)
    if {T1, AtS1} := pullLabelOut(T)
    /\ {T2, AtS2} := pullStmtAttrOut(T', VDS)
    /\ QIL1 := downQidList(T1)
    /\ QIL2 := downQidList(T2)
    /\ Strat1? := metaParseCallStrategy(M, VDS, QIL1)
    /\ Strat2? := metaParseStrategy(M, VDS, QIL2) .
 ceq solveBubbles(csd 'sdlbubble[T] := 'rcbubble[T'] if 'rbubble[T''] = 'true.Bool [AtS] . SDfs,
       M, M', B, VDS, DB)
    = if Strat1? :: CallStrategy
      then if Strat2? :: Strategy
           then csd Strat1? := Strat2?
                  if solveBubblesCond(T3, M, M', B, VDS, DB)
                  [AtS1 AtS2 AtS] .
           else stratDefError('\r 'Warning:
                         '\o printSyntaxError(Strat2?, QIL2) '\n
                         '\r 'Error: '\o 'no 'parse 'for 'sd QIL1 '\s ':= '\s QIL2 '\n)
           fi
      else stratDefError('\r 'Warning:
                    '\o printSyntaxError(Strat1?, QIL1) '\n
                    '\r 'Error: '\o 'no 'parse 'for 'sd QIL1 '\s ':= '\s QIL2 '\n)
      fi
      solveBubbles(SDfs, M, M', B, VDS, DB)
    if {T1, AtS1} := pullLabelOut(T)
    /\ {T3, AtS2} := pullStmtAttrOut(T'', VDS)
    /\ QIL1 := downQidList(T1)
    /\ QIL2 := downQidList(T')
    /\ Strat1? := metaParseStrategy(M, VDS, QIL1)
    /\ Strat2? := metaParseStrategy(M, VDS, QIL2) .
  eq solveBubbles((none).StratDefSet, M, M', B, VDS, DB) = none .

  op metaParseCallStrategy : Module QidSet QidList -> CallStrategy .
  eq metaParseCallStrategy(M, Vs, QIL1)
   = metaParseStrategy(M, Vs, QIL1) .

*** The parsing process may generate error terms. Since in the
*** current version of the system Core Maude is generating the appropriate
*** error messages, we just have to worry about the elimination of these
*** terms. The effect is the same one as introducing a module at the object
*** level of Core Maude: If there is any term in an identity attribute in an
*** operator declaration, equation, rule, or membership axiom with a parsing
*** error a message is generated and the axiom is eliminated.

  eq (op F : TyL -> Ty [id(qidError(QIL)) AtS] .) = opDeclError(QIL) .
  eq (op F : TyL -> Ty [left-id(qidError(QIL)) AtS] .) = opDeclError(QIL) .
  eq (op F : TyL -> Ty [right-id(qidError(QIL)) AtS] .) = opDeclError(QIL) .

  eq (conditionError(QIL) /\ T = T' /\ CD?) = conditionError(QIL) .
  eq (conditionError(QIL) /\ T : S /\ CD?) = conditionError(QIL) .
  eq (conditionError(QIL) /\ T := T' /\ CD?) = conditionError(QIL) .
  eq (conditionError(QIL) /\ T => T' /\ CD?) = conditionError(QIL) .

  eq (eq qidError(QIL) = T? [AtS] .) = equationError(QIL) .
  eq (eq T? = qidError(QIL) [AtS] .) = equationError(QIL) .
  eq (ceq qidError(QIL) = T? if CD? [AtS] .) = equationError(QIL) .
  eq (ceq T? = qidError(QIL) if CD? [AtS] .) = equationError(QIL) .
  eq (ceq T? = T?' if conditionError(QIL) [AtS] .) = equationError(QIL) .

  eq (mb qidError(QIL) : S [AtS] .) = membAxError(QIL) .
  eq (cmb qidError(QIL) : S if CD? [AtS] .) = membAxError(QIL) .
  eq (cmb T? : S if conditionError(QIL) [AtS] .) = membAxError(QIL) .

  eq (rl qidError(QIL) => T? [AtS] .) = ruleError(QIL) .
  eq (rl T? => qidError(QIL) [AtS] .) = ruleError(QIL) .
  eq (crl qidError(QIL) => T? if CD? [AtS] .) = ruleError(QIL) .
  eq (crl T? => qidError(QIL) if CD? [AtS] .) = ruleError(QIL) .
  eq (crl T? => T?' if conditionError(QIL) [AtS] .) = ruleError(QIL) .

  eq F[qidError(QIL), TL?] = qidError(QIL) .
  eq F[TL?, qidError(QIL)] = qidError(QIL) .
  eq F[TL?, qidError(QIL), TL?'] = qidError(QIL) .
endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

*** The function \texttt{solveBubbles} defined in the following
*** \texttt{VIEW-BUBBLE-PARSING} module parses the bubbles in a set of preview
*** maps. It takes two modules, the signature of the view's source theory,
*** with the variables declared in the view, to parse the source term in the
*** term maps, and the target theory, with the mappings of the variable
*** declarations in the view, to parse the target terms.

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod VIEW-BUBBLE-PARSING is
  pr BUBBLE-PARSING .
  pr PRE-VIEW .
  pr UNIT-BUBBLE-PARSING .

  var  OMS : OpMappingSet .
  var  TMS : StratMappingSet .
  vars T T' : Term .
  vars M M' : Module .
  var  U : Module .
  vars QIL QIL1 QIL2 : QidList .
  vars VDS VDS' : VariableSet .
  vars Strat1? Strat2? : [Strategy] .

  op solveBubbles : OpMappingSet VariableSet VariableSet Module Module -> OpMappingSet .
  op solveBubbles : StratMappingSet VariableSet VariableSet Module Module -> StratMappingSet .

  eq solveBubbles(OMS, VDS, VDS', U, unitError(QIL)) = none .
  eq solveBubbles(OMS, VDS, VDS', unitError(QIL), U) = none .
  eq solveBubbles((op_to`term_.(T, T') OMS), VDS, VDS', M, M')
    = (op_to`term_.(
         solveBubbles(T, M, false, VDS, emptyDatabase),
         solveBubbles(T', M', false, VDS', emptyDatabase))
      solveBubbles(OMS, VDS, VDS', M, M')) .
  eq solveBubbles(OMS, VDS, VDS', M, M') = OMS [owise] .

  eq solveBubbles(TMS, VDS, VDS', U, unitError(QIL)) = none .
  eq solveBubbles(TMS, VDS, VDS', unitError(QIL), U) = none .
 ceq solveBubbles(strat_to`expr_.('bubble[T], 'bubble[T']) TMS, VDS, VDS', M, M')
    = if Strat1? :: CallStrategy
      then if Strat2? :: Strategy
           then strat_to`expr_.(Strat1?, Strat2?)
           else none
           fi
      else none
      fi
      solveBubbles(TMS, VDS, VDS', M, M')
    if QIL1 := downQidList(T)
    /\ QIL2 := downQidList(T')
    /\ Strat1? := metaParseStrategy(M, VDS, QIL1)
    /\ Strat2? := metaParseStrategy(M', VDS', QIL2) .
  eq solveBubbles(TMS, VDS, VDS', M, M') = TMS [owise] .
endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

***
*** Module Expression Evaluation
***

*** So far we have not introduced more module expressions than those given by
*** simple quoted identifiers. We will introduce some later, but the scheme
*** followed for evaluating them is very simple and can be presented in a
*** generic way. Given a module expression and a database state, the
*** evaluation of a module expression results in the generation of a new
*** module, which is introduced in the database, with the module expression
*** as its name. The resulting database is then returned. If there is already
*** a module in the database with that name, the function returns the original
*** database without any change. The evaluation of a module expression may
*** produce the evaluation of other module expressions contained in the
*** modules involved in the process. This is the case, for example, for the
*** renaming of modules, in which not only the top module is renamed but,
*** perhaps, some of its submodules as well; it is also the case for the
*** instantiation of parameterized modules, where the module being
*** instantiated may contain submodules which are parameterized by some of
*** the parameter theories of the parameterized module in which are imported.
*** We shall discuss in more detail the renaming and instantiation of module
*** expressions in Sections~\ref{renaming} and~\ref{instantiation},
*** respectively.

*** We saw in Section~\ref{module-expressions} how it is possible to import a
*** module expression in which a parameterized module is instantiated by some
*** of the formal parameters of the parameterized module into which it is
*** imported. To be able to evaluate this kind of module expression, the list
*** of parameters of the module in which the module expression appears has to
*** be given.

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod MOD-EXPR-EVAL is
  pr DATABASE .

  *** decl. moved to module DATABASE
  *** op evalModExp : ModuleExpression Database -> Database .
  op evalModExp : ModuleExpression ParameterDeclList Database -> Tuple{Database, ModuleExpression} .
  op evalViewExpression : ViewExpression ParameterDeclList Database -> Database .
  op evalViewExpression : ParameterList ParameterDeclList Database -> Database .

  var  S : Sort .
  var  QI : Qid .
  var  ME : ModuleExpression .
  var  PDL : ParameterDeclList .
  var  DB : Database .
  vars VE VE' VE'' : ViewExpression .
  vars PL PL' : ParameterList .

  eq evalModExp(ME, DB) = evalModExp(ME, nil, DB) .

  eq evalModExp(ME, PDL, DB) = < DB ; ME > [owise] .

  eq evalModExp(QI, PDL, DB)
    = if unitInDb(QI, DB)
      then if compiledModule(QI, DB)
           then < DB ; QI >
           else < procModule(QI, DB) ; QI >
           fi
      else if upModule(QI, false) :: Module
           then < procModule(QI, insTermModule(QI, upModule(QI, false), DB)) ; QI >
           else < warning(DB, '\r 'Error: '\o 'Module QI 'not 'in 'database. '\n) ; QI >
           fi
      fi .

  eq evalViewExpression(QI, PDL, DB)
    = if labelInParameterDeclList(QI, PDL)
      then DB
      else if viewInDb(QI, DB)
           then if compiledView(QI, DB)
                then DB
                else procView(QI, DB)
                fi
           else if upView(QI) :: View
                then procView(upView(QI), DB)
                else warning(DB, ('\r 'Error: '\o 'View QI 'not 'in 'database. '\n))
                fi
           fi
      fi .
  eq evalViewExpression(S{PL}, PDL, DB)
    = if viewInDb(S{PL}, DB)
      then DB
      else viewInst(S, PL, PDL, evalViewExpression(S, PDL, evalViewExpression(PL, PDL, DB)))
      fi .
  ceq evalViewExpression(VE ;; VE', PDL, DB)
    = evalViewExpression(VE, PDL, evalViewExpression(VE', PDL, DB))
    if VE =/= mtViewExpression /\ VE' =/= mtViewExpression .
  eq evalViewExpression((S, PL), PDL, DB)
    = evalViewExpression(S, PDL, evalViewExpression(PL, PDL, DB))
    [owise] .
  eq evalViewExpression((S{PL}, PL'), PDL, DB)
    = evalViewExpression(S{PL}, PDL, evalViewExpression(PL', PDL, DB))
    [owise] .
  eq evalViewExpression(nil, PDL, DB) = DB .

  op viewInst : ViewExpression ViewExpression ParameterDeclList Database -> Database .

*******************************************************************************
*** The equations specifying its behavior are later, in FM-INST-EXPR-EVALUATION **
*******************************************************************************

endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

***
*** The Transformation of Object-Oriented Modules to System Modules
***

*** The transformation of object-oriented modules into system modules has
*** already been discussed in Section~\ref{omod2mod}, and also in
*** \cite{Meseguer93b,ClavelDuranEkerLincolnMarti-OlietMeseguerQuesada99}.
*** We focus here on the part of the process accomplished by each of the main

*** functions involved in the transformation. The transformation discussed
*** in~\cite{DuranMeseguer98} assumed that object-oriented modules were
*** flattened before being transformed into system modules. However, doing it
*** in this way, the transformations already made for the modules in the
*** structure were not reused. In the current system, the transformation is
*** done only for the module being introduced, the top of the structure, and
*** dusing the `internal' representations of the submodules stored in the
*** ddatabase for the rest of the structure.

*** This approach requires gathering all class and subclass relation
*** declarations in the structure before starting with the transformation
*** process itself. The function \texttt{prepClasses} collects all these
*** declarations in the structure, and completes all the declarations of
*** classes with the attributes inherited from their superclasses.
*** \begin{comment}
*** This function makes use of a `dummy' module, in which the classes are
*** introduced as sorts and the subclass relations as subsort relations to be
*** able to compute all the operations on the subclass relation using the
*** built-in functions on sorts.
*** \end{comment}

*** Once all the class declarations in the structure have been collected and
*** completed, the transformation is accomplished in two stages. First, the
*** function \texttt{omod2modAux} carries out the
*** following tasks:
*** \begin{itemize}
*** \item For each class declaration of the form
***       $\texttt{class }C\texttt{ | }a_1\texttt{:} S_1\texttt{,}
***       \ldots\texttt{,} a_n\texttt{:} S_n$, the following items are
***       introduced: a subsort $C$ of sort \texttt{Cid}, a constant
***       $C$ of sort $C$, and declarations of operations $a_i
***       \texttt{\ :\_} \texttt{ :\,\,} S_i \texttt{ -> Attribute}$
***       for each attribute $a_i$ (the function
***       \texttt{ops4Attr} creates these declarations).
*** \item For each subclass relation of the form
***       $\texttt{subclass\ }C\texttt{\ <\ }C'$, a subsort
***       declaration $\texttt{subsort\ }C\texttt{\ <\ }C'$ is
***       introduced.
*** \item For each message declaration of the form \verb~msg F : TyL
***       -> S~, an operator declaration \verb~op F : TyL -> S~ is added.
*** \end{itemize}
*** When this process has been completed, the function \texttt{prepAxs} is
***  called.  This function applies to the membership axioms, equations, and
*** rewriting rules in the module the transformations indicated in
*** Section~\ref{omod2mod}, so that they become applicable to all the objects
*** of the given class and of their subclasses. The set of attributes of the
*** objects appearing in the membership axioms, equations, and rewriting rules
*** are completed, so that the default convention of not having to
*** exhaustively mention the set of attributes of a class is supported.

*** Note that in Meseguer's paper~\cite{Meseguer93b} a parallel hierarchy of
*** sorts was defined to deal with objects in different classes, and membership
*** axioms constraining the objects to their corresponding sorts were added.
*** The transformation could be easily completed with sorts, subsort relations,
*** and membership constraints as indicated there. In fact, these declarations
*** were added in an initial version and were then removed because they were
*** computationally expensive. However, there are examples in which it would
*** be interesting to have them; when needed, these declarations can be
*** explicitly added by the user in the current version.

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod FM-EXT-TERMSET is
  protecting FM-TERMSET .
  op |_| : TermSet -> Nat .
  eq | X:Term | T:TermSet | = 1 + | T:TermSet | .
  eq | emptyTermSet | = 0 .
endfm

view TermSet from TRIV to FM-EXT-TERMSET is
  sort Elt to TermSet .
endv

fmod O-O-TO-SYSTEM-MOD-TRANSF is
  pr DATABASE .
  pr CONVERSION .
  pr FM-EXT-TERMSET .

  var  DB : Database .
  var  I : Nat .
  var  ME : Header .
  vars S S' S'' C C' : Sort .
  vars SS SS' SS'' : SortSet .
  var  Ty : Type .
  var  TyL : TypeList .
  vars T T' T'' T3 : Term .
  vars TL TL' : TermList .
  var  PL : ParameterList .
  vars IL IL' IL'' : ImportList .
  vars CDS CDS' : ClassDeclSet .
  vars ADS ADS' : AttrDeclSet .
  var  SSDS : SubsortDeclSet .
  vars SCDS SCDS' : SubclassDeclSet .
  var  OPDS : OpDeclSet .
  var  MDS : MsgDeclSet .
  vars MAS MAS' : MembAxSet .
  vars EqS EqS' : EquationSet .
  vars RlS RlS' : RuleSet .
  var  QIL : QidList .
  var  NQIL : NeQidList .
  vars O O' : Term .
  vars M U : Module .
  vars QI A A' L F : Qid .
  var  V V' : Variable .
  var  CD : ClassDecl .
  vars SCD SCD' : SubclassDecl .
  vars Ct Ct' Ct'' : Constant .
  var  Cond : Condition .
  var  AtS : AttrSet .
  var  H : Header .
  var  PD : ParameterDecl .
  var  PDL : ParameterDeclList .
  var  MN : ModuleName .
  var  CH : ClassHierarchy .
  var  C'' : Sort .
  vars TS TS' : TermSet .


  op newVar : Sort Nat -> Variable .
  eq newVar(S, I) = qid("V#" + string(I, 10) + ":" + string(S)) .

*** The function \texttt{prepClasses} completes all classes in the module with
*** all the attributes they inherit from their superclasses.

  op prepClasses : ClassDeclSet SubclassDeclSet ImportList ParameterDeclList
       Database -> ClassDeclSet .
  op prepClasses2 : ClassDeclSet SubclassDeclSet ImportList
       ImportList Database -> ClassDeclSet .
  op prepClasses3 : ClassDeclSet SubclassDeclSet -> ClassDeclSet .

  eq prepClasses(CDS, SCDS, IL, (PD, PDL), DB)
    = prepClasses(CDS, SCDS, (IL protecting pd(PD) .), PDL, DB) .
  eq prepClasses(CDS, SCDS, IL, nil, DB)
    = prepClasses2(CDS, SCDS, IL, nil, DB) .

  eq prepClasses2(CDS, SCDS, ((including MN .) IL), IL', DB)
    = if (including MN . ) in IL'
      then prepClasses2(CDS, SCDS, IL, IL', DB)
      else prepClasses2(
             (getClasses(getTopModule(MN, DB)) CDS),
             (getSubclasses(getTopModule(MN, DB)) SCDS),
             (getImports(getTopModule(MN, DB)) IL),
             ((including MN .) IL'), DB)
      fi .
  eq prepClasses2(CDS, SCDS, ((extending MN .) IL), IL', DB)
    = if (extending MN . ) in IL'
      then prepClasses2(CDS, SCDS, IL, IL', DB)
      else prepClasses2(
             (getClasses(getTopModule(MN, DB)) CDS),
             (getSubclasses(getTopModule(MN, DB)) SCDS),
             (getImports(getTopModule(MN, DB)) IL),
             ((extending MN .) IL'), DB)
      fi .
  eq prepClasses2(CDS, SCDS, ((protecting MN .) IL), IL', DB)
    = if (protecting MN . ) in IL'
      then prepClasses2(CDS, SCDS, IL, IL', DB)
      else prepClasses2(
             (getClasses(getTopModule(MN, DB)) CDS),
             (getSubclasses(getTopModule(MN, DB)) SCDS),
             (getImports(getTopModule(MN, DB)) IL),
             ((protecting MN .) IL'), DB)
      fi .
  eq prepClasses2(CDS, SCDS, nil, IL, DB) = prepClasses3(CDS, SCDS) .

  eq prepClasses3(CDS, SCDS)
    = addAttrs(buildHierarchy(CDS, SCDS, none, empty), SCDS) .

  sort ClassHierarchy ClassStruct .
  subsort ClassStruct < ClassHierarchy .

  op [_,_] : ClassDecl SortSet -> ClassStruct .

  op empty : -> ClassHierarchy .
  op __ : ClassHierarchy ClassHierarchy -> ClassHierarchy
       [assoc comm id: empty] .

  op buildHierarchy :
       ClassDeclSet SubclassDeclSet SortSet ClassHierarchy -> ClassHierarchy .
  op addAttrs : ClassHierarchy SubclassDeclSet -> ClassDeclSet .
  op addAttrsToItsSons :
       ClassDecl ClassHierarchy SubclassDeclSet -> ClassHierarchy .

  eq buildHierarchy(((class C | ADS .) CDS), SCDS, SS, CH)
    = if C in SS
      then buildHierarchy(CDS, SCDS, SS, CH)
      else buildHierarchy(CDS, SCDS, C ; SS, [(class C | ADS .), none] CH)
      fi .
  eq buildHierarchy(none, (subclass C < C' .) SCDS, SS,
       [(class C | ADS .), SS'] [(class C' | ADS' .), SS''] CH)
    = buildHierarchy(none, SCDS, SS,
        [(class C | ADS .), C' ; SS'] [(class C' | ADS' .), SS''] CH) .
  eq buildHierarchy(none, none, SS, CH) = CH .

  eq addAttrs([(class C | ADS .), none] CH, SCDS)
    = (class C | ADS .)
      addAttrs(addAttrsToItsSons((class C | ADS .), CH, SCDS), SCDS) .
  eq addAttrs(empty, SCDS) = none .

  eq addAttrsToItsSons((class C | ADS .), [(class C' | ADS' .), C ; SS] CH,
       (subclass C' < C .) SCDS)
    = addAttrsToItsSons((class C | ADS .), [(class C' | ADS, ADS' .), SS] CH,
        SCDS) .
  ceq addAttrsToItsSons((class C | ADS .), CH, (subclass C' < C'' .) SCDS)
    = addAttrsToItsSons((class C | ADS .), CH, SCDS)
    if C =/= C'' .
  eq addAttrsToItsSons((class C | ADS .), CH, none) = CH .

----  op inAttrDeclSet : Qid AttrDeclSet -> Bool .
----
----  eq inAttrDeclSet(A, ((attr A' : S), ADS))
----    = (A == A') or-else inAttrDeclSet(A, ADS) .
----  eq inAttrDeclSet(A, none) = false .

*** Given a set of attribute declarations, the \texttt{ops4Attr}
*** function returns a set of operator declarations as indicated above. That
*** is, for each attribute $a\texttt{:} S$, an operator of the form
*** $a \texttt{\ :\_} \texttt{ :\,\,} S \texttt{ -> Attribute}$ is declared.

  op ops4Attr : AttrDeclSet -> OpDeclSet .

  eq ops4Attr(((attr A : S), ADS))
    = ((op qid(string(A) + "`:_") : S -> 'Attribute [gather('&)] .)
       ops4Attr(ADS)) .
  eq ops4Attr(none) = none .

*** The function \texttt{prepLHS} takes the term in the lefthand side of a
*** rule, equation, or membership axiom, and replaces each object
***
***   $\texttt{<\ }O\texttt{\ :\ }C\texttt{\ |\ }ADS\texttt{\ >}$
***
*** in it---with $O$ of sort \texttt{Oid}, $C$ the name of a class, and $ADS$
*** a set of attributes with their corresponding values---by an object
***
***   $\texttt{<\ }O\texttt{\ :\ }V\texttt{\ |\ }ADS\ ADS'\ Atts\texttt{\ >}$
***
*** where the identifier of the class is replaced by a variable $V$ of sort
*** $C$, which is not used in the axiom, and where the set of attributes is
*** completed with attributes $ADS'$ as indicated in Section~\ref{omod2mod}, so
*** that each attribute declared in class $C$ or in any of its superclasses is
*** added with a new variable as value. $Atts$ is a new variable of sort
*** \texttt{AttributeSet}, which is used to range over the additional
*** attributes that may appear in objects of a subclass.

*** The function \texttt{prepLHS} takes as arguments a term (in the initial
*** call, the term in the lefthand side of a rule, equation, or membership
*** axiom), the set of variable declarations of those variables declared in the
*** module that are not used in the axiom---new variables are created only if
*** there are no variables in the module with the appropriate sort---the set of
*** attributes in the* occurrences of the objects---and an index---to make sure
*** that the variables being added have not occurrences of the objects---and an
*** index---to make sure that the variables being added have not been added
*** previously. In the initial call this index is set to zero. \texttt{prepLHS}
*** gives as result a tuple composed of the resulting term, the set of objects
*** in the term (so that the modification of the objects in the righthand side
*** of the rule is simplified), the set of variable declarations corresponding
*** to the new added variables, the set of variable declarations of the
*** variables in the module that have not been used, and the index for the
*** creation of new variables.

*** change (03/20/2002): a new variable is created everytime one is needed

*** The set of objects in the lefthand side will be given as a set of terms.

  pr 4TUPLE{TermList, TermSet, Nat, QidList}
       * (op p1_ to term, op p2_ to objects, op p3_ to index, op p4_ to messages,
          op ((_,_,_,_)) : TermList TermSet Nat QidList -> Tuple{TermList,TermSet,Nat,QidList} to <_;_;_;_>) .

  op prepLHS : TermList ClassDeclSet Nat -> Tuple{TermList, TermSet, Nat, QidList} .

  op crtObject : Term Sort AttrDeclSet Tuple{TermList, TermSet, Nat, QidList} -> Tuple{TermList, TermSet, Nat, QidList} .
  op crtObject2 : Term Variable TermList TermList AttrDeclSet TermSet Nat QidList -> Tuple{TermList, TermSet, Nat, QidList} .
  op crtObject3 : Term Qid TermList AttrDeclSet TermSet Nat QidList -> Tuple{TermList, TermSet, Nat, QidList} .

  eq prepLHS(qidError(QIL), CDS, I) = < qidError(QIL) ; emptyTermSet ; I ; nil > .
  eq prepLHS(F, CDS, I) = < F ; emptyTermSet ; I ; nil > .
  eq prepLHS(Ct, CDS, I) = < Ct ; emptyTermSet ; I ; nil > .

*** \texttt{prepLHS} on a list of terms $\texttt{(}T\texttt{,\ }TL\texttt{)}$,
*** with $T$ a term and $TL$ a list of terms, has to make a call to itself with
*** $T$ and with $TL$. The call with $TL$ has to be made with the result of
*** the call with $T$ so that the variables and the index are right.

  ceq prepLHS((T, TL), CDS, I)
    = < (term(prepLHS(T, CDS, I)),
         term(prepLHS(TL, CDS, index(prepLHS(T, CDS, I))))) ;
        _|_(objects(prepLHS(T, CDS, I)),
                objects(prepLHS(TL, CDS, index(prepLHS(T, CDS, I))))) ;
        index(prepLHS(TL, CDS, index(prepLHS(T, CDS, I)))) ;
        (messages(prepLHS(T, CDS, I))
         messages(prepLHS(TL, CDS, index(prepLHS(T, CDS, I))))) >
    if TL =/= empty .
  ceq prepLHS(F[TL], CDS, I)
    = < F[term(prepLHS(TL, CDS, I))] ;
        objects(prepLHS(TL, CDS, I)) ;
        index(prepLHS(TL, CDS, I)) ;
        messages(prepLHS(TL, CDS, I)) >
      if (F =/= '<_:_|_>) /\ (F =/= '<_:_|`>) .

  ceq prepLHS('<_:_|_>[O, Ct, T], ((class C | ADS .) CDS), I)
    = crtObject(O, C, ADS, prepLHS(T, ((class C | ADS .) CDS), I))
    if getName(Ct) == C .
  ceq prepLHS('<_:_|`>[O, Ct], ((class C | ADS .) CDS), I)
    = crtObject(O, C, ADS,
        prepLHS('none.AttributeSet, ((class C | ADS .) CDS), I))
    if getName(Ct) == C .
  eq prepLHS('<_:_|_>[O, V, T], CDS, I)
    = < '<_:_|_>[O, V, T] ; emptyTermSet ; I ; nil > .
                                                      *** is this eq necessary?
  eq prepLHS('<_:_|`>[O, T], CDS, I)
    = prepLHS('<_:_|_>[O, T, 'none.AttributeSet], CDS, I) .

  eq prepLHS('<_:_|_>[O, T, T'], none, I)
    = < qidError('Error: 'undefined 'class T '\n) ; emptyTermSet ; I ; nil > .

  eq crtObject(O, C, ADS, < T ; TS ; I ; QIL >)
    = crtObject2(O, newVar(C, I), T, 'none.AttributeSet, ADS, TS, (I + 1), QIL) .

*** The function \texttt{crtObject2} is called with the metarepresentation of
*** the list of attributes appearing in the current object (third argument)
*** and the set of attribute declarations of the class to which such object
*** belongs + all the attributes declared in its superclasses (fifth
*** argument). The function proceeds recursively removing the attribute
*** declarations from the set of declarations of attributes for those
*** attributes that appear in the object. Each time an attribute is found, it
*** is passed with its actual value to the fourth argument of
*** \texttt{crtObject2}, which initially has value \verb~'none.AttributeSet~,
*** composing a list of terms with them.

*** We assume that:
*** \begin{itemize}
*** \item The metarepresentation of a list of attributes is always given with
***       form \verb~'_`,_[F[T], T]~, \verb~F[T]~, or
***       \verb~'none.AttributeSet~, where \texttt{TL} is the
***       metarepresentation of a list of attributes with the same form (this
***       is ensured by the \verb~(e E)~ gathering pattern in the corresponding
***       declaration in the signature in which the parsing is done), and
*** \item that all the attributes appearing in an object have been declared in
***       the corresponding class declaration or in one of its superclasses.
*** \end{itemize}

  eq crtObject2(O, V, '_`,_[F[T], TL], TL', ADS, TS, I, QIL)
    = crtObject2(O, V, (F[T], TL), TL', ADS, TS, I, QIL) .

  ceq crtObject2(O, V, (F[T], TL), TL', ((attr A : S), ADS), TS, I, QIL)
    = crtObject2(O, V, TL, (F[T], TL'), ADS, TS, I, QIL)
    if qid(string(A) + "`:_") == F .
  eq crtObject2(O, V, (F[T], TL), TL', ADS, TS, I, QIL)
    = crtObject2(O, V, TL, TL', ADS, TS, I,
        (QIL '\r 'Warning: '\o 'Attribute F 'not 'valid '\n))
    [owise] .

  ceq crtObject2(O, V, F[T], TL, ((attr A : S), ADS), TS, I, QIL)
    = crtObject3(O, V, (F[T], TL), ADS, TS, I, QIL)
    if qid(string(A) + "`:_") == F .
  eq crtObject2(O, V, F[T], TL, ADS, TS, I, QIL)
    = crtObject3(O, V, TL, ADS, TS, I,
        (QIL '\r 'Warning: '\o 'Attribute F 'not 'valid '\n))
    [owise] .

  eq crtObject2(O, V, V', TL, ADS, TS, I, QIL)
    = crtObject3(O, V, TL, ADS, TS, I,
        QIL '\r 'Warning: '\o
            'Variables 'are 'not 'allowed 'in 'the 'set 'of 'attributes
            'of 'an 'object '`( V' '`) '\n) .

  eq crtObject2(O, V, 'none.AttributeSet, TL, ADS, TS, I, QIL)
    = crtObject3(O, V, TL, ADS, TS, I, QIL) .
  eq crtObject2(O, V, empty, TL, ADS, TS, I, QIL)
    = crtObject3(O, V, TL, ADS, TS, I, QIL) .

*** When the function \texttt{crtObject2} has gone through all the
*** attributes in the current object, the function \texttt{crtObject3} is
*** in charge of returning the metarepresentation of the current object
*** completed with the attributes that did not appear in it. These attributes
*** are added with new variables not used in the axiom as value.
*** \texttt{crtObject3} returns a pair composed by this resulting object,
*** and the set of terms representing all the objects in the lefthand
*** side (the current object is added to this set).

  eq crtObject3(O, V, TL, ((attr A : S), ADS), TS, I, QIL)
    = crtObject3(O, V, (qid(string(A) + "`:_")[newVar(S, I)], TL),
        ADS, TS, (I + 1), QIL) .

  eq crtObject3(O, V, TL, none, TS, I, QIL)
    = < '<_:_|_>[O, V, '_`,_[TL, newVar('AttributeSet, I)]] ;
        _|_('<_:_|_>[O, V, '_`,_[TL, newVar('AttributeSet, I)]], TS) ;
        (I + 1) ;
        QIL > .

*** Once the lefthand side of a rule or equation has been `prepared', the
*** function \texttt{prepRHS} is called with the set of objects returned by
*** \texttt{prepLHS} and the term in the righthand side of such rule or
*** equation. The function \texttt{prepRHS} proceeds recursively throughout the
*** term looking for objects. Each time an object is found, its set of
*** attributes is completed with those in the modified object of the lefthand
*** side which do not appear in it.

  op prepRHS : TermSet TermList -> TermList .
  op prepRHS : TermSet Condition -> Condition .

  op adjustObject : TermSet Term -> Term .

  op adjustObjectRHS : TermSet Term -> [Term] .
  op adjustAttrsObjectRHS : Term Term -> [Term] .
  op adjustAttrsObjectRHSAux : TermSet Term -> [Term] .

  op termAttrListToTermSet : TermList -> TermSet .
  op _attrInTermSet_ : Qid TermSet -> Bool .

  eq prepRHS(TS, T = T' /\ Cond)
    = prepRHS(TS, T) = prepRHS(TS, T') /\ prepRHS(TS, Cond) .
  eq prepRHS(TS, T : S /\ Cond)  = prepRHS(TS, T) : S /\ prepRHS(TS, Cond) .
  eq prepRHS(TS, T := T' /\ Cond)
    = prepRHS(TS, T) := prepRHS(TS, T') /\ prepRHS(TS, Cond) .
  eq prepRHS(TS, T => T' /\ Cond)
    = prepRHS(TS, T) => prepRHS(TS, T') /\ prepRHS(TS, Cond) .
  eq prepRHS(TS, (nil).Condition) = nil .

  eq prepRHS(TS, qidError(QIL)) = qidError(QIL) .
  eq prepRHS(TS, F) = F .
  eq prepRHS(TS, Ct) = Ct .
  ceq prepRHS(TS, F[TL])
    = F[prepRHS(TS, TL)]
    if (F =/= '<_:_|_>) and (F =/= '<_:_|`>) .
  eq prepRHS(TS, '<_:_|_>[O, Ct, T])
    = adjustObjectRHS(TS, '<_:_|_>[O, Ct, prepRHS(TS, T)]) .
  eq prepRHS(TS, '<_:_|_>[O, V, T]) = '<_:_|_>[O, V, prepRHS(TS, T)] .
  eq prepRHS(TS, '<_:_|`>[O, Ct])
    = adjustObjectRHS(TS, '<_:_|_>[O, Ct, prepRHS(TS, 'none.AttributeSet)]) .
  eq prepRHS(TS, '<_:_|`>[O, V])
    = '<_:_|_>[O, V, prepRHS(TS, 'none.AttributeSet)] .
  ceq prepRHS(TS, (T, TL))
    = (prepRHS(TS, T), prepRHS(TS, TL))
    if TL =/= empty .

  eq adjustObjectRHS(_|_('<_:_|_>[O, V, T], TS), '<_:_|_>[O', Ct, T'])
    = if O == O'
      then if getType(V) == getType(Ct)
           then '<_:_|_>[O, V, adjustAttrsObjectRHS(T, T')]
           else '<_:_|_>[O', Ct, T']
           fi
      else adjustObjectRHS(TS, '<_:_|_>[O', Ct, T'])
      fi .
  eq adjustObjectRHS(emptyTermSet, '<_:_|_>[O, Ct, T]) = '<_:_|_>[O, Ct, T] .

***  eq adjustObjectRHS(_|_('<_:_|_>[Ct, C, T], TS), '<_:_|_>[O, Ct', T'])
***    = adjustObjectRHS(TS, '<_:_|_>[O, Ct', T']) .
***  eq adjustObjectRHS(
***       _|_('<_:_|_>[Ct, C, T], TS), '<_:_|_>[Ct', Ct'', T'])
***    = if Ct == Ct'
***      then '<_:_|_>[Ct, Ct'', adjustAttrsObjectRHS(T, T')]
***      else adjustObjectRHS(TS, '<_:_|_>[Ct', Ct'', T'])
***      fi .
***  eq adjustObjectRHS(emptyTermSet, '<_:_|_>[Ct, Ct', T])
***    = '<_:_|_>[Ct, Ct', T] .

*** The function \texttt{adjustAttrsObjectRHS} completes the set of
*** attributes of an object in the righthand side with those in the object in
*** the lefthand side or in the class not used in the lefthand side, which
*** have been completed by the function \texttt{crtObject}.

  eq adjustAttrsObjectRHS('_`,_[TL], T)
    = adjustAttrsObjectRHSAux(termAttrListToTermSet(TL), T) .

  eq adjustAttrsObjectRHSAux(_|_(A[T], TS), '_`,_[A[T'], T''])
    = '_`,_[A[T'], adjustAttrsObjectRHSAux(TS, T'')] .
  ceq adjustAttrsObjectRHSAux(TS, '_`,_[A[T], T'])
    = qidError(A 'is 'not 'a 'valid 'attribute)
    if not A attrInTermSet TS .
  eq adjustAttrsObjectRHSAux(_|_(A[T], TS), A[T'])
    = '_`,_[A[T'], adjustAttrsObjectRHSAux(TS, 'none.AttributeSet)] .
  ceq adjustAttrsObjectRHSAux(TS, A[T])
    = qidError(A 'is 'not 'a 'valid 'attribute)
    if not A attrInTermSet TS .
  eq adjustAttrsObjectRHSAux(_|_(A[T], TS), 'none.AttributeSet)
    = '_`,_[A[T], adjustAttrsObjectRHSAux(TS, 'none.AttributeSet)] .
  eq adjustAttrsObjectRHSAux(V, 'none.AttributeSet) = V .

  eq A attrInTermSet _|_(V, TS) = A attrInTermSet TS .
  eq A attrInTermSet _|_(A'[T], TS)
    = (A == A') or-else (A attrInTermSet TS) .
  eq A attrInTermSet emptyTermSet = false .

  ceq termAttrListToTermSet((T, TL))
    = if T == 'none.AttributeSet
      then termAttrListToTermSet(TL)
      else _|_(T, termAttrListToTermSet(TL))
      fi
    if TL =/= empty .
  eq termAttrListToTermSet(T)
    = if T == 'none.AttributeSet
      then emptyTermSet
      else T
      fi .

*** In the case of equations and rules, the function \texttt{prepAxs} calls the
*** function \texttt{prepLHS} with the term in the lefthand side of the axiom,
*** and then use the generated set of objects to call the \texttt{prepRHS}
*** function. For conditional equations, rules, and membership axioms, this set
*** of terms representing the objects in the lefthand side is also used in the
*** calls to \texttt{prepRHS} with each of the terms in the conditions. The
*** term in the lefthand side of the equation, rule, or membership axiom is
*** replaced by the term returned by \texttt{prepLHS}. The index is used in
*** the recursive calls to \texttt{prepAxs}.

*** \texttt{prepLHS} returns as second argument the set of objects (as a set of
*** terms) appearing in it. These objects are returned after extending their
*** set of attributes by those of the class to which they belong not already
*** specified.

  op prepAxs : Module MembAxSet EquationSet RuleSet ClassDeclSet Nat QidList
       -> Module .

  eq prepAxs(U, ((mb T : S [AtS] .) MAS), EqS, RlS, CDS, I, QIL)
    = prepAxs(
        addMbs(mb term(prepLHS(T, CDS, I)) : S [AtS] ., U),
        MAS, EqS, RlS, CDS,
        index(prepLHS(T, CDS, I)),
        (QIL messages(prepLHS(T, CDS, I)))) .
  eq prepAxs(U, ((cmb T : S if Cond [AtS] .) MAS), EqS, RlS, CDS, I, QIL)
    = prepAxs(
        addMbs(cmb term(prepLHS(T, CDS, I)) : S
                 if prepRHS(objects(prepLHS(T, CDS, I)), Cond) [AtS] ., U),
        MAS, EqS, RlS, CDS,
        index(prepLHS(T, CDS, I)),
        (QIL messages(prepLHS(T, CDS, I)))) .
  eq prepAxs(U, MAS, ((eq T = T' [AtS] .) EqS), RlS, CDS, I, QIL)
    = prepAxs(
        addEqs(eq term(prepLHS(T, CDS, I))
                 = prepRHS(objects(prepLHS(T, CDS, I)), T') [AtS] ., U),
        MAS, EqS, RlS, CDS,
        index(prepLHS(T, CDS, I)),
        (QIL messages(prepLHS(T, CDS, I)))) .
  eq prepAxs(U, MAS, ((ceq T = T' if Cond [AtS] .) EqS), RlS, CDS, I, QIL)
    = prepAxs(
        addEqs(ceq term(prepLHS(T, CDS, I))
                 = prepRHS(objects(prepLHS(T, CDS, I)), T')
                 if prepRHS(objects(prepLHS(T, CDS, I)), Cond) [AtS] ., U),
        MAS, EqS, RlS, CDS,
        index(prepLHS(T, CDS, I)),
        (QIL messages(prepLHS(T, CDS, I)))) .

  eq prepAxs(U, MAS, EqS, ((rl T => T' [AtS] .) RlS), CDS, I, QIL)
    = prepAxs(
        addRls(rl term(prepLHS(T, CDS, I))
                 => prepRHS(objects(prepLHS(T, CDS, I)), T') [AtS] ., U),
        MAS, EqS, RlS, CDS,
        index(prepLHS(T, CDS, I)),
        (QIL messages(prepLHS(T, CDS, I)))) .
  eq prepAxs(U, MAS, EqS, ((crl T => T' if Cond [AtS] .) RlS), CDS, I, QIL)
    = prepAxs(
        addRls(crl term(prepLHS(T, CDS, I))
                 => prepRHS(objects(prepLHS(T, CDS, I)), T')
                 if prepRHS(objects(prepLHS(T, CDS, I)), Cond) [AtS] ., U),
        MAS, EqS, RlS, CDS,
        index(prepLHS(T, CDS, I)),
        (QIL messages(prepLHS(T, CDS, I)))) .
  eq prepAxs(U, none, none, none, CDS, I, nil) = U .
  eq prepAxs(U, none, none, none, CDS, I, NQIL) = unitError(NQIL) .
  eq prepAxs(unitError(QIL), MAS, EqS, RlS:[RuleSet], CDS, I, QIL':QidList) = unitError(QIL':QidList QIL) .

*** After completing the set of classes in the module with the attributes from
*** their superclasses, the function \texttt{omod2mod} calls the function
*** \texttt{omod2modAux} with the same module and the set of class
*** declarations. The definition of the \texttt{omod2mod} function is given by
*** the five equations below.

  op omod2mod : OModule Database -> SModule .
  op omod2modAux : OModule ClassDeclSet -> SModule .
  op omod2mod : OTheory Database -> SModule .
  op omod2modAux : OTheory ClassDeclSet -> SModule .

  eq omod2mod(
       omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom,
       DB)
    = omod2modAux(
        omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom,
        prepClasses(CDS, SCDS, IL, getParDecls(H), DB)) .
  eq omod2mod(
       oth H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth,
       DB)
    = omod2modAux(
        oth H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth,
        prepClasses(CDS, SCDS, IL, getParDecls(H), DB)) .

  eq omod2modAux(
       omod H is
          IL sorts SS . SSDS ((class C | ADS .) CDS) SCDS OPDS MDS MAS EqS RlS
       endom,
       CDS')
    = omod2modAux(
        omod H is
           IL sorts (SS ; C) .
           (subsort C < 'Cid . SSDS)
           CDS SCDS
           ((op C : nil -> C [none] .)
            ops4Attr(ADS) OPDS)
           MDS MAS EqS RlS
        endom,
        CDS') .
  eq omod2modAux(
       omod H is
          IL sorts SS . SSDS CDS ((subclass C < C' .) SCDS)
          OPDS MDS MAS EqS RlS
       endom,
       CDS')
    = omod2modAux(
        omod H is
           IL sorts SS . ((subsort C < C' .) SSDS)
           CDS SCDS OPDS MDS MAS EqS RlS
        endom,
        CDS') .
  eq omod2modAux(
        omod H is
           IL sorts SS . SSDS CDS SCDS OPDS
           ((msg F : TyL -> Ty .) MDS) MAS EqS RlS
        endom,
        CDS')
    = omod2modAux(
         omod H is
            IL sorts SS . SSDS CDS SCDS
            ((op F : TyL -> Ty [msg] .) OPDS) MDS MAS EqS RlS
         endom,
         CDS') .
  eq omod2modAux(
       omod H is IL sorts SS . SSDS none none OPDS none MAS EqS RlS endom,
       CDS)
    = prepAxs(mod H is IL sorts SS . SSDS OPDS none none none endm,
        MAS, EqS, RlS, CDS, 0, nil) .

  eq omod2modAux(
       oth H is
          IL sorts SS . SSDS ((class C | ADS .) CDS)
          SCDS OPDS MDS MAS EqS RlS
       endoth,
       CDS')
    = omod2modAux(
        oth H is
           IL sorts (SS ; C) .
           (subsort C < 'Cid . SSDS)
           CDS SCDS
           ((op C : nil -> C [none] .)
            ops4Attr(ADS) OPDS)
           MDS MAS EqS RlS
        endoth,
        CDS') .
  eq omod2modAux(
       oth H is
          IL sorts SS . SSDS CDS ((subclass C < C' .) SCDS)
          OPDS MDS MAS EqS RlS
       endoth,
       CDS')
    = omod2modAux(
        oth H is
           IL sorts SS . ((subsort C < C' .) SSDS)
           CDS SCDS OPDS MDS MAS EqS RlS
        endoth,
        CDS') .
  eq omod2modAux(
        oth H is
           IL sorts SS . SSDS CDS SCDS OPDS
           ((msg F : TyL -> Ty .) MDS) MAS EqS RlS
        endoth,
        CDS')
    = omod2modAux(
         oth H is
            IL sorts SS . SSDS CDS SCDS
            ((op F : TyL -> Ty [msg] .) OPDS) MDS MAS EqS RlS
         endoth,
         CDS') .
  eq omod2modAux(
       oth H is IL sorts SS . SSDS none none OPDS none MAS EqS RlS endoth,
       CDS)
    = prepAxs(
        th H is IL sorts SS . SSDS OPDS none none none endth,
        MAS, EqS, RlS, CDS, 0, nil) .
endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

***
*** Evaluation of Modules and Theories
***

*** As explained in Section~\ref{evaluation-overview}, in our approach
*** transforming a module from its possibly complex structured version to its
*** unstructured form is a two-step process.  First, all module expressions
*** are evaluated, generating an intermediate form in which there are only
*** simple inclusion relationships among the modules. This first step can be
*** seen as the reduction of a structured specification to its structured
*** \emph{normal form}. Then, in a second step, this structured normal form is
*** flattened into an unstructured specification.  Note, however, that the
*** importation of built-in modules is left explicit in the flattened form.
*** The function \texttt{normalize} is in charge of normalizing the
*** structure.

*** The process of evaluation of a preunit has to take into account the
*** possibility of bubbles being contained in it. Depending on whether it is
*** dealing with a preunit or with a unit, the evaluation process is
*** accomplished by two different functions, namely, \texttt{evalPreModule} and
*** \texttt{evalModule}. One function or the other will be called in each case.
*** Evaluating a module already in the database, which is done by
*** \texttt{evalModule}, does not require bubble handling. Besides this
*** difference, both functions proceed in a similar way. Before presenting the
*** functions \texttt{evalPreModule} and \texttt{evalModule} we introduce some
*** auxiliary declarations.

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod FM-EVALUATION is
  pr O-O-TO-SYSTEM-MOD-TRANSF .
  pr MOD-EXPR-EVAL .
  pr UNIT-BUBBLE-PARSING .

  sort List<Module> .
  subsort Module < List<Module> .

  op nil : -> List<Module> .
  op __ : List<Module> List<Module> -> List<Module> [assoc id: nil] .
  eq unitError(QIL) UL unitError(QIL') = unitError(QIL QIL') UL .

  vars M PU U U' U'' : Module .
  vars UL UL' : List<Module> .
  vars DB  DB' : Database .
  vars ME ME' : ModuleExpression .
  var  P : ViewExpression .
  var  PD : ParameterDecl .
  vars PL PL' PL'' : ParameterList .
  vars IL IL' IL'' : ImportList .
  var  I : Import .
  var  CDS : ClassDeclSet .
  var  SSDS : SubsortDeclSet .
  var  SCDS : SubclassDeclSet .
  var  OPD : OpDecl .
  var  OPDS : OpDeclSet .
  var  VDS : VariableSet .
  var  MDS : MsgDeclSet .
  var  MAS : MembAxSet .
  var  EqS : EquationSet .
  var  RlS : RuleSet .
  var  B : Bool .
  vars QI QI' V L L' L'' A A' A'' F F' F'' X Y W Z : Qid .
  vars QIL QIL' SL : QidList .
  vars S S' S'' C C' C'' : Sort .
  vars SS SS' : SortSet .
  vars Ty Ty' : Type .
  vars TyL TyL' : TypeList .
  vars AtS AtS' : AttrSet .
  var  Rl : Rule .
  var  CD : ClassDecl .
  var  ADS : AttrDeclSet .
  var  MD : MsgDecl .
  vars T T' T'' T3 : Term .
  var  TL : TermList .
  var  MAP : Renaming .
  var  MAPS : RenamingSet .
  vars VE VE' VE'' : ViewExpression .
  var  HkL : HookList .
  vars PDL PDL' : ParameterDeclList .
  var  St : String .

*** The \texttt{subunitImports} function returns the list of all the
*** subunits of a given unit. It is called with the list of importations of
*** the given unit as first argument, and proceeds recursively through its
*** structure collecting all the subunits in it.

*** The function \texttt{subunitImports} proceeds storing the importations
*** considered up to that point, so it does not have to go through the same
*** part of the structure more than once. When the function is initially
*** called the second argument is set to \texttt{nil}.

  op subunitImports : ParameterDeclList ImportList Database -> ImportList .
  op subunitImports : ImportList ImportList Database -> ImportList .

  eq subunitImports((PD, PDL), IL, DB)
    = subunitImports(PDL, IL (protecting pd(PD) .), DB) .
  eq subunitImports((nil).ParameterDeclList, IL, DB)
    = subunitImports(IL, nil, DB) .

  eq subunitImports(I IL, IL' I IL'', DB)
    = subunitImports(IL, IL' I IL'', DB)  .
  eq subunitImports(I IL, IL', DB)
    = subunitImports(getImports(getTopModule(moduleName(I), DB)) IL, I IL', DB)
    [owise] .
  eq subunitImports((nil).ImportList, IL, DB) = IL .

*** The function \texttt{getModules} returns the list of those units
*** in the list of importations given as argument which are not built-in.

  op getModules : ImportList Database -> List<Module> .
  op getModules : ImportList List<Module> Database -> List<Module> .

  eq getModules(IL, DB) = getModules(IL, nil, DB) .

  eq getModules(((including ME .) IL), UL, DB)
    = getModules(IL, (UL getInternalModule(ME, DB)), DB) .
  eq getModules(((including pd(PD) .) IL), UL, DB)
    = getModules(IL, (UL getInternalModule(pd(PD), DB)), DB) .
  eq getModules(((extending ME .) IL), UL, DB)
    = getModules(IL, (UL getInternalModule(ME, DB)), DB) .
  eq getModules(((extending pd(PD) .) IL), UL, DB)
    = getModules(IL, (UL getInternalModule(pd(PD), DB)), DB) .
  eq getModules(((protecting ME .) IL), UL, DB)
    = getModules(IL, (UL getInternalModule(ME, DB)), DB) .
  eq getModules(((protecting pd(PD) .) IL), UL, DB)
    = getModules(IL, (UL getInternalModule(pd(PD), DB)), DB) .
  eq getModules(IL, UL unitError(QIL) UL', DB) = unitError(QIL) .
  eq getModules(nil, UL, DB) = UL .

*** The normalization of a structure consists in evaluating each of the module
*** expressions appearing in it. Note that, if the \texttt{evalModExp} function
*** generates new modules, they will be evaluated using the \texttt{evalModule}
*** function, producing recursive calls on the part of the structure not
*** previously normalized. Parameters are handled separatedly. They are
*** folded out when analyzing the interface of a module.

  pr 3TUPLE{ImportList,ParameterDeclList,Database}
       * (op ((_,_,_)) to <_;_;_>,
          op p1_ to importList,
          op p2_ to parameterDeclList,
          op p3_ to database) .

----  sort Tuple{ImportList,ParameterDeclList,Database} .
----  op <_;_;_> : ImportList ParameterDeclList Database
----       -> Tuple{ImportList,ParameterDeclList,Database} .
----  op importList : Tuple{ImportList,ParameterDeclList,Database} -> ImportList .
----  op parameterDeclList :
----       Tuple{ImportList,ParameterDeclList,Database} -> ParameterDeclList .
----  op database : Tuple{ImportList,ParameterDeclList,Database} -> Database .
----  eq importList(< IL ; PDL ; DB >) = IL .
----  eq parameterDeclList(< IL ; PDL ; DB >) = PDL .
----  eq database(< IL ; PDL ; DB >) = DB .

  op normalize : ImportList ParameterDeclList Database
       -> Tuple{ImportList,ParameterDeclList,Database} .
  op normalize : ImportList ImportList ParameterDeclList ParameterDeclList
       Database -> Tuple{ImportList,ParameterDeclList,Database} .
  op createCopy : ParameterDecl Database -> Database .
  ---- its definition is in FM-INST-EXPR-EVALUATION

  eq normalize(IL, PDL, DB) = normalize(nil, IL, nil, PDL, DB) .

  eq normalize(IL, IL', PDL, (X :: ME, PDL'), DB)
    = normalize(IL, IL',
        (PDL, X :: modExp(evalModExp(ME, nil, DB))), PDL',
        createCopy((X :: modExp(evalModExp(ME, nil, DB))),
          database(evalModExp(ME, nil, DB)))) .
  eq normalize(IL, (including ME .) IL', PDL, PDL', DB)
    = normalize(IL (including modExp(evalModExp(ME, PDL, DB)) .), IL',
        PDL, PDL', database(evalModExp(ME, PDL, DB))) .
  eq normalize(IL, (extending ME .) IL', PDL, PDL', DB)
    = normalize(IL (extending modExp(evalModExp(ME, PDL, DB)) .), IL',
        PDL, PDL', database(evalModExp(ME, PDL, DB))) .
  eq normalize(IL, (protecting ME .) IL', PDL, PDL', DB)
    = normalize(IL (protecting modExp(evalModExp(ME, PDL, DB)) .), IL',
        PDL, PDL', database(evalModExp(ME, PDL, DB))) .
  eq normalize(IL, I IL', PDL, PDL', DB)
    = normalize(IL I, IL', PDL, PDL', DB)
    [owise] .
  eq normalize(IL, nil, PDL, nil, DB) = < IL ; PDL ; DB > .

*** \texttt{checkSortClashes} checks whether the intersection of the two sTS
*** of sorts given as arguments is empty or not. If it is nonempty, then there
*** is a clash of names, and a warning message is passed to the database.  The
*** check is very simple, and only reports the name of one of the modules from
*** which the sorts come. Only the name of the module from which the sorts
*** given as second argument come is known at this point. This is the module
*** name given as first argument.
***
***   op checkSortClashes : Header SortSet SortSet Database -> Database .
***
***   eq checkSortClashes(ME, (S ; SS), (S ; SS'), DB)
***     = checkSortClashes(ME, SS, SS',
***         warning(DB,
***           '\g 'Advisory: '\o
***           'Clash 'of 'sort eSortToSort(S) 'from header2Qid(ME) '\n)) .
***   ceq checkSortClashes(ME, (S ; SS), SS', DB)
***     = checkSortClashes(ME, SS, SS', DB)
***     if not (S in SS') .
***   eq check(ME, none, SS, DB) = DB .

*** In the current system, the only transformation handled by the
*** \texttt{transform} function is the one from object-oriented modules to
*** system modules, which is accomplished by the
*** \texttt{omod2mod} function presented in
*** Section~\ref{omod2modfunction}. However, \texttt{transform} has been
*** defined as a general transformation that could affect other kinds of
*** modules in a future extension.

  op transform : Module Database -> Module .

  eq transform(unitError(QIL), DB) = unitError(QIL) .
 ceq transform(U, DB)
    = rmVariantAttrs(U)
    if U :: SModule or U :: STheory or U :: StratModule or U :: StratTheory .
  eq transform(U, DB) = rmVariantAttrs(omod2mod(U, DB)) [otherwise] .

*** The function \texttt{signature} generates a functional module of sort
*** \texttt{FModule}, without equations, by ``forgetting'' the appropriate
*** declarations and converting extended sorts and module names into quoted
*** identifiers.

  op removeIds : OpDeclSet -> OpDeclSet .
  eq removeIds(op F : TyL -> Ty [id(T) AtS] . OPDS)
    = removeIds(op F : TyL -> Ty [AtS] . OPDS) .
  eq removeIds(op F : TyL -> Ty [right-id(T) AtS] . OPDS)
    = removeIds(op F : TyL -> Ty [AtS] . OPDS) .
  eq removeIds(op F : TyL -> Ty [left-id(T) AtS] . OPDS)
    = removeIds(op F : TyL -> Ty [AtS] . OPDS) .
  eq removeIds(op F : TyL -> Ty [special(term-hook(QI, T) HkL) AtS] . OPDS)
    = removeIds(op F : TyL -> Ty [special(HkL) AtS] . OPDS) .
  eq removeIds(OPDS) = OPDS [owise] .

  op removeCtors : Module -> Module .
  op removeCtors : OpDeclSet -> OpDeclSet .
  eq removeCtors(M) = setOps(M, removeCtors(getOps(M))) .
  eq removeCtors(op F : TyL -> Ty [ctor AtS] . OPDS)
    = removeCtors(op F : TyL -> Ty [AtS] . OPDS) .
  eq removeCtors(OPDS) = OPDS [owise] .

  op removeDittos : OpDeclSet Module -> OpDeclSet .
  ceq removeDittos(
        op F : TyL -> Ty [ditto AtS] . op F : TyL' -> Ty' [AtS'] . OPDS, M)
    = removeDittos(
        op F : TyL -> Ty [AtS removeCtorMetadata(AtS')] . op F : TyL' -> Ty' [AtS'] . OPDS, M)
    if not ditto in AtS' /\ sameKind(M, TyL Ty, TyL' Ty') .
  eq removeDittos(OPDS, M) = OPDS [owise] .

  op signature : Module -> Module .
  eq signature(unitError(QIL)) = unitError(QIL) .
  eq signature(U)
    = if U :: StratModule
    then smod header2Qid(getHeader(U)) is
           convertModuleExpressions(getImports(U))
           sorts getSorts(U) .
           getSubsorts(U)
           removeIds(
             removeDittos(getOps(U),
               setSubsorts(
                 setSorts(emptyFModule('DUMMY), getSorts(U)),
                 getSubsorts(U))))
           none
           none
           none
           getStratDcls(U)
           none
         endsm
    else fmod header2Qid(getHeader(U)) is
           convertModuleExpressions(getImports(U))
           sorts getSorts(U) .
           getSubsorts(U)
           removeIds(
             removeDittos(getOps(U),
               setSubsorts(
                 setSorts(emptyFModule('DUMMY), getSorts(U)),
                 getSubsorts(U))))
           none
           none
         endfm
    fi
    [owise] .

*** The function \texttt{flatModule} generates a module of sort \texttt{Module}
*** by ``forgetting'' declarations and converting extended sorts and module
*** identifiers into quoted identifiers.

  op flatModule : Module -> Module .
  eq flatModule(unitError(QIL)) = unitError(QIL) .
  eq flatModule(U)
    = if U :: FModule or U :: FTheory
      then (fmod header2Qid(getHeader(U)) is
               getImports(U)
               sorts getSorts(U) .
               getSubsorts(U)
               getOps(U)
               getMbs(U)
               getEqs(U)
            endfm)
      else if U :: StratModule or U :: StratTheory
        then (smod header2Qid(getHeader(U)) is
                 getImports(U)
                 sorts getSorts(U) .
                 getSubsorts(U)
                 getOps(U)
                 getMbs(U)
                 getEqs(U)
                 getRls(U)
                 getStratDcls(U)
                 getStratDefs(U)
              endsm)
        else (mod header2Qid(getHeader(U)) is
                 getImports(U)
                 sorts getSorts(U) .
                 getSubsorts(U)
                 getOps(U)
                 getMbs(U)
                 getEqs(U)
                 getRls(U)
              endm)
        fi
      fi
    [owise] .

  op convertModuleExpressions : ImportList -> ImportList .
  eq convertModuleExpressions(((protecting ME * (MAPS) .) IL))
    = (protecting ME * (renamings(MAPS)) .) convertModuleExpressions(IL) .
  eq convertModuleExpressions(((extending ME * (MAPS) .) IL))
    = (extending ME * (renamings(MAPS)) .) convertModuleExpressions(IL) .
  eq convertModuleExpressions(((including ME * (MAPS) .) IL))
    = (including ME * (renamings(MAPS)) .) convertModuleExpressions(IL) .
  eq convertModuleExpressions(I IL) = I convertModuleExpressions(IL) [owise] .
  eq convertModuleExpressions(nil) = nil .

  op renamings : RenamingSet -> RenamingSet .
  eq renamings(op F to F' [AtS]) = op F to F' [AtS] .
  eq renamings((op F to F' [AtS], MAPS))
    = (op F to F' [AtS], renamings(MAPS))
    [owise] .
  eq renamings(op F : TyL -> Ty to F' [AtS])
    = op F : TyL -> Ty to F' [AtS] .
  eq renamings((op F : TyL -> Ty to F' [AtS], MAPS))
    = (op F : TyL -> Ty to F' [AtS],
       renamings(MAPS))
    [owise] .
  eq renamings(sort S to S') = sort S to S' .
  eq renamings(((sort S to S'), MAPS))
    = ((sort S to S'), renamings(MAPS))
    [owise] .
  eq renamings(label L to L') = label L to L' .
  eq renamings(((label L to L'), MAPS))
    = ((label L to L'), renamings(MAPS))
    [owise] .
  eq renamings((MAP, MAPS)) = renamings(MAPS) [owise] .
  eq renamings(none) = none .

*** The evaluation process for units without bubbles is as follows. After
*** normalizing the structure, the function \texttt{evalModule} calls
*** \texttt{evalModule1} with an empty copy of the module to which the list of
*** declarations of importations of built-in modules is added, and with the
*** list of its nonbuilt-in subunits.

*** \texttt{evalModule1} accumulates all the declarations in all the
*** nonbuilt-insubmodules in the copy of the module passed as second argument.
*** The top module is then introduced in the database, and, after calling the
*** \texttt{transform} function and renaming all the variables in it, the
*** internal version of such a module is entered in the database as well.

*** Finally, \texttt{evalModule2} generates the signature and the flat version
*** of the module and enters them in the database.

  *** op evalModule : Module Database -> Database .
  ***  moved to MOD-EXPR-EVAL to solve dependency
  op evalModule1 : Module Module List<Module> VariableSet Database -> Database .
  op evalModule2 : Module Module Database -> Database .

  ceq evalModule(U, VDS, DB)
    = evalModule1(setPars(setImports(U, IL), PDL), empty(U),
        getModules(IL', DB'), VDS, DB')
    if < IL ; PDL ; DB' > := normalize(getImports(U), getPars(U), DB)
    /\ IL' := subunitImports(PDL, IL, DB') .
   eq evalModule(U, VDS, DB) = DB [owise] .

  eq evalModule1(U, U', (U'' UL), VDS, DB)
    = evalModule1(U, addDecls(U', setImports(U'', nil)), UL, VDS, DB) .
  eq evalModule1(U, U', nil, VDS, DB)
    = evalModule2(
        setImports(transform(U, DB), nil),
        U',
        insertVars(getHeader(U), VDS,
          insertInternalModule(getHeader(U), transform(U, DB),
            insertTopModule(getHeader(U), U, DB)))) .
  eq evalModule1(U, U', unitError(QIL), VDS, DB) = warning(DB, QIL) .

  eq evalModule2(U, U', DB)
    = insertFlatModule(getHeader(U), flatModule(addDecls(U, U')), DB) .
  eq evalModule2(unitError(QIL), U, DB) = warning(DB, QIL) .

*** The function \texttt{evalPreModule} has to take care of the bubbles in the
*** unit. As we explained in Section~\ref{evaluation-overview}, both the
*** signature and the flattened version of the module are created
*** simultaneously, completing the parsing of the bubbles once the signature
*** has been built, and then completing the flattened module.

*** The \texttt{evalPreModule} function takes as arguments two copies of the
*** module and a database. We shall see in Section~\ref{unit-processing} how
*** these two modules are generated; the one passed as first argument has
*** still bubbles in it, while the other one, which will be used to build the
*** signature, does not contain any bubbles. This module without bubbles is
*** the result of removing the bubbles from the declarations in it, or of
*** removing the declarations themselves when they contain bubbles, as in the
*** case of equations, for example.

*** The \texttt{evalPreModule} function is quite similar to the function
*** \texttt{evalModule}. First, the structure is normalized by calling the
*** \texttt{normalize} function, and then all the subunits in the
*** structure are collected (accomplished by \texttt{subunitImports} and
*** \texttt{getModules}) and the list of importations is updated
*** with the sublist of importations of built-in
*** modules (\texttt{selectBuiltInImports}). Second, the structure of all the
*** subunits below the top is flattened to a single unit. This unit is used to
*** create a first version of the signature (without identity elements of
*** operators) in which all the bubbles in the top preunit are
*** parsed (\texttt{solveBubbles}). The final version of the signature and
*** the flat unit are generated once the bubbles have been parsed. The
*** `internal' version of the module is also generated by renaming the
*** variables in it (\texttt{renameVars}). All these versions of the module
*** are finally entered in the database.

*** Note that if the \texttt{META-LEVEL} module is imported in the module
*** being evaluated, a declaration importing the predefined module
*** \texttt{UP} Section~\ref{non-built-in-predefined}) is added. With the
*** declarations in this module it will be possible to parse bubbles
*** containing calls to the \texttt{up} functions (see
*** Section~\ref{structured-specifications}) in them.

  op evalPreModule : Module Module VariableSet Database -> Database .
  op evalPreModule1 : Module Module List<Module> Module VariableSet Database -> Database .
  op evalPreModule2 : Module Module Module VariableSet Database -> Database .
  op evalPreModule3 : Module Module Module Database -> Database .

  *** evalPreModule just calls evalPreModule1 with a set of the units in the
  *** structure of the given module. Depending on whether the module is
  *** importing META-LEVEL or not UP will be added. BOOL will be added if
  *** the include BOOL flag is set and the module doesn't include it already.

  ceq evalPreModule(PU, U, VDS, DB)
    *** PU  : top unit with bubbles (preunit)
    *** U   : top unit without bubbles (decls with bubbles were removed)
    *** VDS : ops corresponding to the vbles in the top unit
    = evalPreModule1(
        setPars(setImports(PU, IL'), PDL'),
        setName(empty(U), getHeader(U)),
        getModules(IL'', DB'),
        setImports(U, nil),
        VDS,
        DB')
    if IL := getImports(PU)
    /\ PDL := getPars(PU)
    /\ < IL' ; PDL' ; DB' > := normalize(defImports(PU, DB) IL, PDL, DB)
    /\ IL'' := subunitImports(PDL, IL', DB') .
  eq evalPreModule(PU, U, VDS, DB) = DB [owise] .

  *** evalPreModule1 joins all the units in the structure into a single unit,
  *** the one given as second argument; recall that the fourth one is the
  *** top module without bubbles but with the complete list of subunits
  *** being imported explicitly

  eq evalPreModule1(PU, U, (U' UL), U'', VDS, DB)
    = evalPreModule1(PU, addDecls(U, U'), UL, U'', VDS, DB) .
  eq evalPreModule1(PU, U, nil, U', VDS, DB)
    = evalPreModule2(PU, U, signature(transform(addDecls(U', setImports(U, nil)), DB)), VDS, DB)
    [owise] .
  eq evalPreModule1(PU, unitError(QIL), UL, U', VDS, DB) = warning(DB, QIL) .
  eq evalPreModule1(unitError(QIL), U, UL, U', VDS, DB) = warning(DB, QIL) .
  eq evalPreModule1(PU, U, unitError(QIL), U', VDS, DB) = warning(DB, QIL) .

  eq evalPreModule2(PU, U, M, VDS, DB)
    *** PU : top module with bubbles
    *** U  : everything below
    *** M  : complete signature
    = evalPreModule3(
        solveBubblesMod(PU, getOps(U), getRls(U), M,
          included('META-MODULE, getImports(PU), DB), VDS, DB),
        U, M,
        insertVars(getHeader(PU), VDS,
          insertTopModule(getHeader(PU),
            solveBubblesMod(PU, getOps(U), getRls(U), M,
              included('META-MODULE, getImports(PU), DB), VDS, DB), DB))) .

  eq evalPreModule3(PU, U, M, DB)
    *** PU : top module without bubbles
    *** U  : everything below
    *** M  : complete signature
    = insertFlatModule(getHeader(PU),
        flatModule(setImports(transform(addDecls(PU, U), DB), nil)),
        insertInternalModule(getHeader(PU), transform(PU, DB), DB)) .
  eq evalPreModule3(unitError(QIL), U, M, DB) = warning(DB, QIL) .
endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

*** Note that in both \texttt{evalModule} and \texttt{evalPreModule}, the function
*** \texttt{transform} has to be invoked to transform the module into a
*** functional or system module. In the current system, the only
*** transformation available is from object-oriented modules to system modules.

***
*** 6.8 Application of Map STS
***

*** The following two modules deal with the application of a set of renaming
*** maps to a module. Except for the proof obligations and additional checks
*** associated with views---almost none of these checks are performed, and
*** none of these proof obligations is generated in the current version---the
*** way of applying a renaming map and a view map on a module is the same.
*** Internally, they are treated in the same way; the only difference between
*** them consists in the way of calling the function to accomplish this
*** application.

*** Note that there might be some `interference' between sort maps, and
*** operator maps and message maps when they are applied. Let us consider for
*** example a module with an operator declaration
***
***  op f : Foo -> Foo .
***
*** and a renaming map set
***
***  (sort Foo to Bar, op f : Foo -> Foo to g)
***
*** These renamings have to be applied carefully to avoid unintended behaviors.
*** Depending on which of the maps is applied first, the other will be
*** applicable or not.  All the maps must be applied to the original module.
*** To avoid the interference between the sort maps and other maps, the map set
*** is divided into two sTS: The first one contains the sort maps, and the
*** second one contains the other maps.

*** We assume that there are no ambiguous mappings, that is, that we do not
*** have, for example, maps \verb~op f to g~ and \verb~op f to h~. In case of
*** such ambiguity, one of the maps will be arbitrarily chosen.

***
*** 6.8.1 Map STS on Terms
***

*** The application of a set of view maps to a term is defined in the following
*** module \texttt{RENAMING-SET-APPL-ON-TERM}. The function
*** \texttt{applyMapsToTerm} is used to apply a given view map set to terms
*** appearing in equations, rules, identity element declarations, and
*** membership axioms, as part of the process of applying a map set to a unit.

*** Some of the auxiliary functions introduced in this module will also be used
*** in the application of maps to operator and message declarations in the
*** \texttt{RENAMING-SET-APPL-ON-UNIT} module.

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod FM-RENAMING-SET-APPL-ON-TERM is
  pr FM-UNIT .
  pr FM-FMAP .
  pr FM-EXT-SORT .

  var  R : Renaming .
  vars RS RS' RS'' SRS ORS : RenamingSet .
  var  M : Module .
  vars F F' F'' A A' A'' : Qid .
  vars T T' T'' O : Term .
  vars TL TL' TL'' TL3 : TermList .
  vars S S' S'' C C' C'' : Sort .
  var  SS : SortSet .
  var  K : Kind .
  vars TyL TyL' : TypeList .
  vars Ty Ty' : Type .
  vars Subst Subst' Subst'' : Substitution .
  var  AtS : AttrSet .
  var  OPDS : OpDeclSet .
  vars V V' : Variable .
  vars Ct Ct' : Constant .
  var  QIL : QidList .
  var  Cd : Condition .

*** The following functions \texttt{applyMapsToSort} and
*** \texttt{applyMapsToClassSort} apply a set of maps, respectively, to a
*** sort a to a class name in its single identifier form, that is, when they
*** appear qualifying constants. Functions \texttt{applyMapsToType} and
*** \texttt{applyMapsToClassName} are similar but being applied to sort or
*** class names in their normal form.

  op applyMapsToSort : RenamingSet Sort -> Sort .
  eq applyMapsToSort((sort S to S'), S) = S' .
  eq applyMapsToSort((sort S to S'), S'') = S'' [owise] .
  eq applyMapsToSort(((sort S to S'), SRS), S) = S' .
  eq applyMapsToSort(((sort S to S'), SRS), S'')
    = applyMapsToSort(SRS, S'')
    [owise] .
  eq applyMapsToSort(R, S) = S [owise].
  eq applyMapsToSort((R, SRS), S) = applyMapsToSort(SRS, S) [owise].
  eq applyMapsToSort(none, S) = S .

  op applyMapsToSortSet : RenamingSet SortSet -> SortSet .
  eq applyMapsToSortSet(SRS, (S ; SS))
    = (applyMapsToType(SRS, S) ; applyMapsToSortSet(SRS, SS)) .
  eq applyMapsToSortSet(SRS, none) = none .

  op applyMapsToType : RenamingSet Type -> Type .
  eq applyMapsToType((sort S to S'), S) = S' .
  eq applyMapsToType(((sort S to S'), SRS), S) = S' .
  eq applyMapsToType((sort S to S'), K)
    = qid("[" + string(applyMapsToType(sort S to S', getSort(K))) + "]") .
  eq applyMapsToType(((sort S to S'), SRS), K)
    = qid("["
       + string(applyMapsToType(((sort S to S'), SRS), getSort(K)))
       + "]") .
  eq applyMapsToType(SRS, Ty) = Ty [owise] .

  op applyMapsToClassName : RenamingSet Sort -> Sort .
  eq applyMapsToClassName((class C to C'), C) = C' .
  eq applyMapsToClassName(((class C to C'), SRS), C) = C' .
  eq applyMapsToClassName(SRS, C) = C [owise] .

*** \texttt{applyOpMapsToOpId} applies a map set to an operator name.

  op applyOpMapsToOpId : Qid RenamingSet -> Qid .
  eq applyOpMapsToOpId(F, (op F to F' [AtS])) = F' .
  eq applyOpMapsToOpId(F, (op F : TyL -> Ty to F' [AtS])) = F' .
  eq applyOpMapsToOpId(F, RS) = F [owise] .

  op applyStMapsToStId : Qid RenamingSet -> Qid .
  eq applyStMapsToStId(F, (strat F to F')) = F' .
  eq applyStMapsToStId(F, (strat F : TyL @ Ty to F')) = F' .
  eq applyStMapsToStId(F, RS) = F [owise] .

*** Note that all maps introduced in Sections~\ref{renaming-maps}
*** and~\ref{view-maps}, except for label maps, may affect a term. For example,
*** sort maps will be applied to the qualifications of terms, and class and
*** attribute maps have to be applied to the objects appearing in the term.
*** Operator and message maps in which an explicit arity and coarity is given,
*** and operator maps going to derived operators (see Section~\ref{Views})
*** must be applied to the complete family of subsort-overloaded operators.

*** The function \texttt{applyMapsToTerm} takes as arguments two sTS of
*** view maps (the first set for sort maps, and the second for the other maps),
*** the term to which the maps will be applied, and a module to be used in the
*** matching of terms, sort comparisons, etc. Its declaration is as follows.

  op applyMapsToTerm2 : RenamingSet RenamingSet Term Module -> Term .

*** If the term on which the maps have to be applied is not an object,
*** different cases have to be considered for each of the possible forms of a
*** term. If it is a variable or \texttt{error*}, the same term is returned
*** without change (term maps are a special case for this). If it is a sort
*** test or a lazy sort test, with forms \verb~T : S~ and \verb~T :: S~,
*** respectively, the maps are applied to the term \texttt{T} and to the sort
*** \texttt{S}.  In case of being of forms \verb~F.S~ or \verb~F[TL]~ with
*** \texttt{F} an operator name, \texttt{S} a sort, and \texttt{TL} a list of
*** terms, the function \texttt{getRightOpMaps} will return the subset of
*** maps which are applicable on such term. If \texttt{none} is returned then
*** no map is applicable. If more than one map is returned then there is an
*** ambiguity, and any of them will be arbitrarily taken. The function
*** \texttt{imagTerm} is called with the term and the maps applicable on
*** it and return the image of the term. In case of a term of the form
*** \texttt{F[TL]}, \texttt{imageOfTerm} will make recursive calls with the
*** arguments in \texttt{TL}.

*** The application of a term map to a term requires the `matching' of the
*** source term in the map with the term on which the map is applied, and then
*** the application of the obtained substitution. Note, however, that a
*** complete matching algorithm is not required. Given the form of the pattern
*** we can choose beforehand the appropriate map, that is, we know that in
*** fact there is a match when the function is called. Note also that the map
*** has to be applied to the whole family of subsort overloaded operators. We
*** just have to check that the sort of the given variable and the
*** corresponding term are in the same connected component of sorts.  In
*** addition to getting the appropriate substitution, the only thing we need
*** to check is that there are no variables with different assignments, that
*** is, that in case of having a nonlinear pattern, the terms being assigned
*** to each variable are equal. We call \texttt{pseudoMatch} to the function
*** doing this task.

  op applyMapsToTerm2 : RenamingSet RenamingSet TermList Module -> TermList .
  op applyMapsToVars : RenamingSet VariableSet -> VariableSet .
  op imageOfTerm : RenamingSet RenamingSet Term RenamingSet Module -> Term .
  op applyMapsToSubst : RenamingSet RenamingSet Substitution Module -> Substitution .
  op pseudoMatch : TermList TermList Module Substitution -> Substitution .
  op pseudoMatch2 : TermList TermList Module Substitution -> Substitution .
  op pseudoMatchResult : Substitution -> Substitution .
  op pseudoMatchResult : Substitution Assignment Substitution Substitution -> Substitution .

  op getRightOpMaps : Qid TypeList Type RenamingSet Module -> RenamingSet .
  op applyMapsToObjectAttrSet : RenamingSet RenamingSet Sort Term Module -> Term .
  op applyMapsToAttrNameInTerm : RenamingSet Sort Qid Module -> Qid .

  eq applyMapsToTerm2(SRS, ORS, Ct, M)
    = imageOfTerm(SRS, ORS, Ct,
        getRightOpMaps(getName(Ct), nil, getType(Ct), ORS, M), M) .
  eq applyMapsToTerm2(SRS, ORS, V, M)
    = applyMapsToVars(SRS, V) .
  eq applyMapsToTerm2(SRS, ORS, qidError(QIL), M) = qidError(QIL) .
  eq applyMapsToTerm2(SRS, ORS, F[TL], M)
    = imageOfTerm(SRS, ORS, F[TL],
        getRightOpMaps(F, eLeastSort(M, TL), leastSort(M, F[TL]), ORS, M),
        M)
    [owise] .
  eq applyMapsToTerm2(SRS, ORS, '<_:_|_>[O, Ct, T], M)
    = '<_:_|_>[applyMapsToTerm2(SRS, ORS, O, M),
               qid(string(applyMapsToClassName(SRS, getName(Ct)))
                  + "." + string(applyMapsToClassName(SRS, getType(Ct)))),
               applyMapsToObjectAttrSet(SRS, ORS, getName(Ct), T, M)].
  ceq applyMapsToTerm2(SRS, ORS, '<_:_|_>[O, C, T], M)
    = '<_:_|_>[applyMapsToTerm2(SRS, ORS, O, M),
               applyMapsToClassName(SRS, C),
               applyMapsToObjectAttrSet(SRS, ORS, C, T, M)]
    if not C :: Constant .
  eq applyMapsToTerm2(SRS, ORS, '<_:_|`>[O, Ct], M)
    = '<_:_|_>[applyMapsToTerm2(SRS, ORS, O, M),
               qid(string(applyMapsToClassName(SRS, getName(Ct)))
                 + "." + string(applyMapsToClassName(SRS, getType(Ct)))),
               'none.AttributeSet] .
  ceq applyMapsToTerm2(SRS, ORS, '<_:_|`>[O, C], M)
    = '<_:_|_>[applyMapsToTerm2(SRS, ORS, O, M),
         applyMapsToClassName(SRS, C), 'none.AttributeSet]
    if not C :: Constant .
  ceq applyMapsToTerm2(SRS, ORS, F[TL], M)
    = qid("_::`" + string(applyMapsToType(SRS, qid(substr(string(F), 4, length(string(F))))))) [
        applyMapsToTerm2(SRS, ORS, TL, M)]
    if substr(string(F), 0, 4) == "_::`" .

  ceq applyMapsToTerm2(SRS, ORS, (T, TL), M)
    = (applyMapsToTerm2(SRS, ORS, T, M),
       applyMapsToTerm2(SRS, ORS, TL, M))
    if TL =/= empty .
  eq applyMapsToTerm2(SRS, ORS, empty, M) = empty .

*** Application of a map set to the name of an attribute in an object

  eq applyMapsToAttrNameInTerm((attr A . S to A'), C, A'', M)
    = if sameKind(M, S, C) and-then (qid(string(A) + "`:_") == A'')
      then qid(string(A') + "`:_")
      else A''
      fi .
  eq applyMapsToAttrNameInTerm(((attr A . S to A'), ORS), C, A'', M)
    = if sameKind(M, S, C) and-then (qid(string(A) + "`:_") == A'')
      then qid(string(A') + "`:_")
      else applyMapsToAttrNameInTerm(ORS, C, A'', M)
      fi .
  eq applyMapsToAttrNameInTerm(R, C, A, M) = A [owise] .
  eq applyMapsToAttrNameInTerm((R, ORS), C, A, M)
    = applyMapsToAttrNameInTerm(ORS, C, A, M)
    [owise] .
  eq applyMapsToAttrNameInTerm(none, S, A, M) = A .

*** Selection of all the operator or message maps that are applicable on an
*** operator with a given arity and coarity.

  eq getRightOpMaps(F, TyL, Ty, (msg F' to F''), M)
    = getRightOpMaps(F, TyL, Ty, (op F' to F'' [none]), M) .
  eq getRightOpMaps(F, TyL, Ty, ((msg F' to F''), RS), M)
    = getRightOpMaps(F, TyL, Ty, ((op F' to F'' [none]), RS), M) .
  eq getRightOpMaps(F, TyL, Ty, (msg F' : TyL' -> Ty' to F''), M)
    = getRightOpMaps(F, TyL, Ty, op F' : TyL' -> Ty' to F'' [none], M) .
  eq getRightOpMaps(F, TyL, Ty, ((msg F' : TyL' -> Ty' to F''), RS), M)
    = getRightOpMaps(F, TyL, Ty,
        (op F' : TyL' -> Ty' to F'' [none], RS), M) .
  eq getRightOpMaps(F, TyL, Ty, (op F to F' [AtS]), M) = (op F to F' [AtS]) .
  eq getRightOpMaps(F, TyL, Ty, (op F to F' [AtS], RS), M)
    = (op F to F' [AtS], getRightOpMaps(F, TyL, Ty, RS, M)) .
  eq getRightOpMaps(F, TyL, Ty, op F : TyL' -> Ty' to F' [AtS], M)
    = if (size(TyL') == 2 and-then (sameKindAll(M, Ty', TyL) and-then assoc in attrs2SameKind(F, TyL, M)))
         or-else
         sameKind(M, TyL Ty, TyL' Ty')
      then (op F : TyL' -> Ty' to F' [AtS])
      else none
      fi .
  eq getRightOpMaps(F, TyL, Ty, (op F : TyL' -> Ty' to F' [AtS], RS), M)
    = if (size(TyL') == 2 and-then (sameKindAll(M, Ty', TyL) and-then assoc in attrs2SameKind(F, TyL, M)))
         or-else
         sameKind(M, TyL Ty, TyL' Ty')
      then (op F : TyL' -> Ty' to F' [AtS],
            getRightOpMaps(F, TyL, Ty, RS, M))
      else getRightOpMaps(F, TyL, Ty, RS, M)
      fi .
  eq getRightOpMaps(F, TyL, Ty, op_to`term_(F[TL], T), M)
    = if sameKind(M, TyL, varListSort(TL))
      then (op_to`term_(F[TL], T))
      else none
      fi .
  eq getRightOpMaps(F, TyL, Ty, (op_to`term_(F[TL], T), RS), M)
    = if sameKind(M, TyL, varListSort(TL))
      then (op_to`term_(F[TL], T), getRightOpMaps(F, TyL, Ty, RS, M))
      else getRightOpMaps(F, TyL, Ty, RS, M)
      fi .
  eq getRightOpMaps(F, TyL, Ty, (op_to`term_(Ct, T)), M)
    = if TyL == nil
         and-then (F == getName(Ct)
         and-then sameKind(M, Ty, getType(Ct)))
      then (op_to`term_(Ct, T))
      else none
      fi .
  eq getRightOpMaps(F, TyL, Ty, (op_to`term_(Ct, T), RS), M)
    = if TyL == nil
         and-then (F == getName(Ct)
         and-then sameKind(M, Ty, getType(Ct)))
      then (op_to`term_(Ct, T), getRightOpMaps(F, TyL, Ty, RS, M))
      else getRightOpMaps(F, TyL, Ty, RS, M)
      fi .
  eq getRightOpMaps(F, TyL:[Type], Ty:[Type], RS, M) = none [owise].

  op varListSort : TermList -> TypeList .
  eq varListSort((V, TL)) = (getType(V) varListSort(TL)) .
  eq varListSort(empty) = nil .

  op attrs2SameKind : Qid TypeList Module -> AttrSet .
  op attrs2SameKind : Qid TypeList OpDeclSet Module -> AttrSet .
  eq attrs2SameKind(F, Ty Ty' TyL, M) = attrs2SameKind(F, Ty Ty', getOps(M), M) .
 ceq attrs2SameKind(F, TyL, op F : TyL' -> Ty' [AtS] . OPDS, M) ---- all subsort overloaded operators have the same equational attributes
    = AtS
    if sameKind(M, TyL, TyL') .
  eq attrs2SameKind(F, TyL, OPDS, M) = none [owise] .

*** Application of a map set to the set of attributes in an object

  eq applyMapsToObjectAttrSet(RS, RS', C, '_`,_[A[T], TL], M)
    = '_`,_[applyMapsToAttrNameInTerm(RS', C, A, M)
              [applyMapsToTerm2(RS, RS', T, M)],
            applyMapsToObjectAttrSet(RS, RS', C, TL, M)] .
  eq applyMapsToObjectAttrSet(RS, RS', C, A[T], M)
    = applyMapsToAttrNameInTerm(RS', C, A, M)
        [applyMapsToTerm2(RS, RS', T, M)] .
  eq applyMapsToObjectAttrSet(RS, RS', C,
       '_`,_['none.AttributeSet, TL], M)
    = '_`,_['none.AttributeSet,
            applyMapsToObjectAttrSet(RS, RS', C, TL, M)] .
  eq applyMapsToObjectAttrSet(RS, RS', C, 'none.AttributeSet, M)
    = 'none.AttributeSet .

*** Image of a term

  eq imageOfTerm(RS, RS', Ct, none, M)
    = qid(string(getName(Ct)) + "."
          + string(applyMapsToType(RS, getType(Ct)))) .
  eq imageOfTerm(RS, RS', F[TL], none, M)
    = F [ applyMapsToTerm2(RS, RS', TL, M) ] .

  eq imageOfTerm(RS, RS', F[TL], (op F to F' [AtS]), M)
    = F' [ applyMapsToTerm2(RS, RS', TL, M) ] .
  eq imageOfTerm(RS, RS', F[TL], ((op F to F' [AtS]), RS''), M)
    = F' [ applyMapsToTerm2(RS, RS', TL, M) ] .
  eq imageOfTerm(RS, RS', F[TL], (op F : TyL -> Ty to F'[AtS]), M)
    = F' [ applyMapsToTerm2(RS, RS', TL, M) ] .
  eq imageOfTerm(RS, RS', F[TL], (op F : TyL -> Ty to F'[AtS], RS''),M)
    = F' [ applyMapsToTerm2(RS, RS', TL, M) ] .
  eq imageOfTerm(RS, RS', T, op_to`term_(T', T''), M)
    = applySubst(T'',
        applyMapsToSubst(RS, RS', pseudoMatch(T', T, M, none), M)) .
  eq imageOfTerm(RS, RS', T, (op_to`term_(T', T''), RS''), M)
    = applySubst(T'',
        applyMapsToSubst(RS, RS', pseudoMatch(T', T, M, none), M)) .
  ceq imageOfTerm(RS, RS', Ct, (op F to F' [AtS]), M)
    = qid(string(F') + "." + string(applyMapsToType(RS, getType(Ct))))
    if getName(Ct) = F .
  ceq imageOfTerm(RS, RS', Ct, ((op F to F' [AtS]), RS''), M)
    = qid(string(F') + "." + string(applyMapsToType(RS, getType(Ct))))
    if getName(Ct) = F .
  ceq imageOfTerm(RS, RS', Ct, (op F : TyL -> Ty to F' [AtS]), M)
    = qid(string(F') + "." + string(applyMapsToType(RS, getType(Ct))))
    if getName(Ct) = F .
  ceq imageOfTerm(RS, RS', Ct, (op F : TyL -> Ty to F' [AtS], RS''),M)
    = qid(string(F') + "." + string(applyMapsToType(RS, getType(Ct))))
    if getName(Ct) = F .

*** Application of a Substitution on a term

  op applySubst : TermList Substitution -> TermList .
  eq applySubst(T, none) = T .
  eq applySubst(V, ((V' <- T) ; Subst))
    = if getName(V) == getName(V')
      then T
      else applySubst(V, Subst)
      fi .
  eq applySubst(F[TL], Subst) = F[applySubst(TL, Subst)] .
  eq applySubst(Ct, Subst) = Ct .
  ceq applySubst((T, TL), Subst)
    = (applySubst(T, Subst), applySubst(TL,Subst))
    if TL =/= empty .

*** Application of a Substitution to a condition

  op applySubst : Condition Substitution -> Condition .
  eq applySubst(T = T' /\ Cd, Subst)
    = (applySubst(T, Subst) = applySubst(T', Subst)) /\ applySubst(Cd, Subst) .
  eq applySubst(T => T' /\ Cd, Subst)
    = (applySubst(T, Subst) => applySubst(T', Subst)) /\ applySubst(Cd, Subst) .
  eq applySubst(T : S /\ Cd, Subst)
    = (applySubst(T, Subst) : S) /\ applySubst(Cd, Subst) .
  eq applySubst((nil).EqCondition, Subst) = nil .

*** Application of a Substitution to a Substitution

  op applySubst : Substitution Substitution -> Substitution .
  eq applySubst((V <- T ; Subst), Subst')
    = (applySubst(V, Subst) <- applySubst(T, Subst')) ; applySubst(Subst, Subst') .
  eq applySubst((none).Substitution, Subst) = none .

*** PseudoMatch

  eq pseudoMatch(T, T', M, Subst)
    = pseudoMatchResult(pseudoMatch2(T, T', M, Subst)) .

  eq pseudoMatch2(Ct, Ct', M, Subst) = none .
  eq pseudoMatch2(F[TL], F'[TL'], M, Subst)
    = if F == F'
      then pseudoMatch2(TL, TL', M, Subst)
      else none
      fi .
  eq pseudoMatch2((V, TL), (T, TL'), M, Subst)
    = if sameKind(M, getType(V), leastSort(M, T))
      then pseudoMatch2(TL, TL', M, (V <- T ; Subst))
      else none
      fi .
  eq pseudoMatch2(V, T, M, Subst)
    = if sameKind(M, getType(V), leastSort(M, T))
      then (V <- T ; Subst)
      else none
      fi .

  eq pseudoMatch2((V, TL), (T, TL'), M, Subst)
    = if sameKind(M, getType(V), leastSort(M, T))
      then pseudoMatch2(TL, TL', M, (V <- T ; Subst))
      else none
      fi .
  eq pseudoMatch2((Ct, TL), (Ct', TL'), M, Subst)
    = if getName(Ct) == getName(Ct')
      then pseudoMatch2(TL, TL', M, Subst)
      else none
      fi .
  eq pseudoMatch2((F[TL], TL'), (F'[TL''], TL3), M, Subst)
    = if F == F'
      then pseudoMatch2(TL', TL3, M, pseudoMatch2(TL, TL'', M, none) ; Subst)
      else none
      fi .
  eq pseudoMatch2(empty, empty, M, Subst) = Subst .

  *** pseudoMatchResult detects conflicts and eliminates duplicates

  eq pseudoMatchResult((V <- T) ; Subst)
    = pseudoMatchResult(none, (V <- T), none, Subst) .
  eq pseudoMatchResult(none) = none .

  eq pseudoMatchResult(Subst, (V <- T), Subst', (V' <- T') ; Subst'')
    = if V == V'
      then if T == T'
           then pseudoMatchResult(Subst, (V <- T), Subst', Subst'')
           else none
           fi
      else pseudoMatchResult(Subst, (V <- T), Subst' ; (V' <- T'), Subst'')
      fi .
  eq pseudoMatchResult(Subst, (V <- T), (V' <- T') ; Subst', none)
    = pseudoMatchResult(Subst ; (V <- T), (V' <- T'), none, Subst') .
  eq pseudoMatchResult(Subst, (V <- T), none, none) = (Subst ; (V <- T)) .

*** Application of a set of maps to a substitution

  eq applyMapsToSubst(RS, RS', ((V <- T) ; Subst), M)
    = ((applyMapsToTerm2(RS, RS', V, M) <- applyMapsToTerm2(RS, RS', T, M)) ;
       applyMapsToSubst(RS, RS', Subst, M)) .
  eq applyMapsToSubst(RS, RS', none, M) = none .

endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

*** We do not include here the equations defining the semantics of the function
*** \texttt{applyMapsToTerm}. Instead, we present an example illustrating
*** the meaning of the function. Renaming maps and view maps were already
*** discussed in Sections~\ref{Views} and~\ref{module-expressions}.

*** Let us consider the following configuration in the module
*** \texttt{STACK2[Accnt]} presented in Section~\ref{module-expressions}. In
*** this configuration we have objects in the class \texttt{Accnt} which
*** represent the accounts of different clients of a bank, which is
*** represented as an object \texttt{'bank} of class \texttt{Stack[Accnt]}.
*** The object \texttt{'bank} in the example configuration below keeps a stack
*** with the accounts of the bank represented as a linked list of nodes, each
*** of which corresponds to the account of one of the clients.

***   ('bank push 'john)
***   ('peter elt 2000)
***   < 'bank : Stack[Accnt] | first : o ('bank, 1) >
***   < 'paul : Accnt | bal : 5000 >
***   < 'peter : Accnt | bal : 2000 >
***   < 'mary : Accnt | bal : 7200 >
***   < 'john : Accnt | bal : 100 >
***   < o('bank, 0) : Node[Accnt] | node : 'peter, next : null >
***   < o('bank, 1) : Node[Accnt] | node : 'mary, next : o('bank, 0) > .
***
*** Let us apply the following renaming to the previous term.
***
***   (op o to id,
***    class Stack[Accnt] to Bank,
***    msg _push_ : Oid Oid -> Msg to open`account`in_to_,
***    msg _pop to close`account`of_,
***    msg _elt_ to _owns_dollars,
***    attr node . Node[Accnt] to client,
***    attr bal . Accnt to balance)
***
*** The resulting term is as follows.
***
***   (open account in 'bank to 'john)
***   ('peter owns 2000 dollars)
***   < 'bank : Bank | first : id('bank, 1) >
***   < 'paul : Accnt | balance : 5000 >
***   < 'peter : Accnt | balance : 2000 >
***   < 'mary : Accnt | balance : 7200 >
***   < 'john : Accnt | balance : 100 >
***   < id('bank, 0) : Node[Accnt] | client : 'peter, next : null >
***   < id('bank, 1) : Node[Accnt] | client : 'mary, next : id('bank, 0) >

*** The function \texttt{applyMapsToTerm} treats the object constructor
*** \verb~<_:_|_>~ in a special way. It cannot be renamed, and, when an
*** occurrence of such a constructor is found, class and attribute maps require
*** a particular handling. Inside terms these maps are only triggered when
*** this constructor is found, and they are applied in a very restricted way,
*** according to the general pattern for objects.  We assume that the operator
*** \verb~<_:_|_>~ is only used for objects and that objects constructed using
*** it are well-formed.

***
*** 6.8.2 Map STS on Modules
***

*** The application of view maps to modules and theories of the different types
*** is defined in the following module \texttt{RENAMING-SET-APPL-ON-UNIT}. The
*** function \texttt{applyMapsToModule} is defined recursively by applying it
*** to the different components of a unit. When the terms in the different
*** declarations are reached, the function \texttt{applyMapsToTerm} is
*** called. This call is made with the set of maps split conveniently, as
*** explained above.

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

view RenamingSet from TRIV to META-LEVEL is
  sort Elt to RenamingSet .
endv

fmod FM-RENAMING-SET-APPL-ON-UNIT is
  pr FM-RENAMING-SET-APPL-ON-TERM .
  pr FM-INT-LIST .
  ---- MI pr FM-VIEW-EXPR .

  op applyMapsToModule : RenamingSet Module Module -> Module .
  op applyMapsToModuleAux : RenamingSet RenamingSet RenamingSet Module Module -> Module .
  op splitMaps : RenamingSet -> Tuple{RenamingSet,RenamingSet,RenamingSet} .
  op splitMapsAux : RenamingSet RenamingSet RenamingSet RenamingSet -> Tuple{RenamingSet,RenamingSet,RenamingSet} .

  op applyMapsToTypeList : RenamingSet TypeList -> TypeList .
  op applyMapsToSubsorts : RenamingSet SubsortDeclSet -> SubsortDeclSet .
  op applyMapsToOps : RenamingSet RenamingSet OpDeclSet Module -> OpDeclSet .
  op applyMapsToOp : RenamingSet RenamingSet RenamingSet OpDecl Module -> OpDecl .
  op applyMapsToAttrs : RenamingSet RenamingSet AttrSet Module -> AttrSet .
  op applyMapToAttrs : Renaming AttrSet -> AttrSet .
  op applyMapToAttrsAux : AttrSet AttrSet AttrSet -> AttrSet .
  op applyMapsToHooks : RenamingSet RenamingSet HookList Module -> HookList .
  op applyMapsToHooksAux : RenamingSet RenamingSet Hook Module -> Hook .
  op applyMapsToMbs : RenamingSet RenamingSet MembAxSet Module -> MembAxSet .
  op applyMapsToEqs : RenamingSet RenamingSet EquationSet Module -> EquationSet .
  op applyMapsToRls : RenamingSet RenamingSet RuleSet Module -> RuleSet .
  op applyMapsToCond : RenamingSet RenamingSet Condition Module -> Condition .
  op applyMapsToLabel : RenamingSet Qid -> Qid .
  op applyMapsToClassDeclSet : RenamingSet RenamingSet ClassDeclSet -> ClassDeclSet .
  op applyMapsToSubclassDeclSet : RenamingSet SubclassDeclSet -> SubclassDeclSet .
  op applyMapsToMsgDeclSet : RenamingSet RenamingSet MsgDeclSet Module -> MsgDeclSet .
  op applyMapsToMsgDecl : RenamingSet RenamingSet MsgDecl Module -> MsgDecl .
  op applyMapsToAttrName : RenamingSet Sort Qid -> Qid .
  op applyMapsToAttrDeclSet : RenamingSet RenamingSet Sort AttrDeclSet -> AttrDeclSet .
  op applyMapsToStratDcls : RenamingSet RenamingSet RenamingSet StratDeclSet Module -> StratDeclSet .
  op applyMapsToStratDefs : RenamingSet RenamingSet RenamingSet StratDefSet Module -> StratDefSet .
  op applyMapsToStratDcl : RenamingSet RenamingSet RenamingSet StratDecl Module -> StratDecl .
  op applyMapsToStratDef : RenamingSet RenamingSet RenamingSet StratDefinition Module -> StratDefinition .

  vars M U : Module .
  vars QI QI' QI'' L L' L'' F F' F'' A A' A'' : Qid .
  vars V V' : Variable .
  var  Ct : Constant .
  vars QIL QIL' : QidList .
  var  VE : ViewExpression .
  var  H : Header .
  var  ME : ModuleExpression .
  var  PDL : ParameterDeclList .
  var  IL : ImportList .
  vars S S' S'' C C' C'' : Sort .
  vars Ty Ty' : Type .
  vars TyL TyL' : TypeList .
  var  SS : SortSet .
  var  SSDS : SubsortDeclSet .
  var  OPDS : OpDeclSet .
  var  MAS : MembAxSet .
  var  EqS : EquationSet .
  var  RlS : RuleSet .
  var  CDS : ClassDeclSet .
  var  SCDS : SubclassDeclSet .
  var  MDS : MsgDeclSet .
  var  ADS : AttrDeclSet .
  vars T T' T'' T3 O : Term .
  vars TL TL' : TermList .
  var  At : Attr .
  vars AtS AtS' AtS'' : AttrSet .
  vars I I' : Nat .
  vars NL NL' : IntList .
  var  Hk : Hook .
  var  HkL : HookList .
  var  R : Renaming .
  vars RS RS' RS'' RS3 SRS ORS TRS : RenamingSet .
  vars Subst Subst' : Substitution .
  var  Cond : Condition .
  var  St : String .
  var  MN : ModuleName .
  var  StratDcls : StratDeclSet .
  var  StratDefs : StratDefSet .
  var  Strats : StrategyList .
  vars CS CS' : CallStrategy .
  vars Strat Strat' Strat'' : Strategy .
  var  UPS : UsingPairSet .

  pr (3TUPLE * (op `(_`,_`,_`) to <_;_;_>,
                op p1_ to sortMaps,
                op p2_ to opMaps,
                op p3_ to stratMaps)) { RenamingSet,RenamingSet,RenamingSet } .

---(
  sort Tuple{RenamingSet,RenamingSet} .
  op <_;_> : RenamingSet RenamingSet -> Tuple{RenamingSet, RenamingSet} .
  ops sortMaps otherMaps : Tuple{RenamingSet, RenamingSet} -> RenamingSet .
  eq sortMaps(< RS ; RS' >) = RS .
  eq otherMaps(< RS ; RS' >) = RS' .
)

  eq splitMaps(RS) = splitMapsAux(RS, none, none, none) .
  eq splitMapsAux(sort S to S', RS', RS'', RS3)
    = splitMapsAux(none, ((sort S to S'), RS'), RS'', RS3) .
  eq splitMapsAux((sort S to S', RS), RS', RS'', RS3)
    = splitMapsAux(RS, ((sort S to S'), RS'), RS'', RS3) .
  eq splitMapsAux(class S to S', RS', RS'', RS3)
    = splitMapsAux(none, ((class S to S'), RS'), RS'', RS3) .
  eq splitMapsAux((class S to S', RS), RS', RS'', RS3)
    = splitMapsAux(RS, ((class S to S'), RS'), RS'', RS3) .
  eq splitMapsAux(R, RS', RS'', RS3)
    = splitMapsAux(none, RS', (R, RS''), RS3) [owise] .
  eq splitMapsAux((R, RS), RS', RS'', RS3)
    = splitMapsAux(RS, RS', (R, RS''), RS3) [owise] .
  eq splitMapsAux(strat F to F', RS', RS'', RS3)
    = splitMapsAux(none, RS', RS'', (strat F to F', RS3)) .
  eq splitMapsAux((strat F to F', RS), RS', RS'', RS3)
    = splitMapsAux(RS, RS', RS'', (strat F to F', RS3)) .
  eq splitMapsAux(strat F : TyL @ Ty to F', RS', RS'', RS3)
    = splitMapsAux(none, RS', RS'', (strat F : TyL @ Ty to F', RS3)) .
  eq splitMapsAux(((strat F : TyL @ Ty to F'), RS), RS', RS'', RS3)
    = splitMapsAux(RS, RS', RS'', (strat F : TyL @ Ty to F', RS3)) .
  eq splitMapsAux(none, RS, RS', RS3) = < RS ; RS' ; RS3 > .

*** To avoid the interference between the sort and class maps with other maps, the map
*** set is divided in two sets.

  ceq applyMapsToModule(RS, U, M)
    = applyMapsToModuleAux(SRS, ORS, TRS, U, M)
    if < SRS ; ORS ; TRS > := splitMaps(RS) .
  eq applyMapsToModule(RS, U, unitError(QIL)) = unitError(QIL) .

  eq applyMapsToModuleAux(SRS, ORS, TRS, mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm, M)
    = mod H is
          IL
          sorts applyMapsToSortSet(SRS, SS) .
          applyMapsToSubsorts(SRS, SSDS)
          applyMapsToOps(SRS, ORS, OPDS, M)
          applyMapsToMbs(SRS, ORS, MAS, M)
          applyMapsToEqs(SRS, ORS, EqS, M)
          applyMapsToRls(SRS, ORS, RlS, M)
      endm .
  eq applyMapsToModuleAux(SRS, ORS, TRS, th MN is IL sorts SS . SSDS OPDS MAS EqS RlS endth, M)
    = th MN is
          IL sorts applyMapsToSortSet(SRS, SS) .
          applyMapsToSubsorts(SRS, SSDS)
          applyMapsToOps(SRS, ORS, OPDS, M)
          applyMapsToMbs(SRS, ORS, MAS, M)
          applyMapsToEqs(SRS, ORS, EqS, M)
          applyMapsToRls(SRS, ORS, RlS, M)
      endth .
  eq applyMapsToModuleAux(SRS, ORS, TRS, fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm, M)
    = fmod H is
          IL
          sorts applyMapsToSortSet(SRS, SS) .
          applyMapsToSubsorts(SRS, SSDS)
          applyMapsToOps(SRS, ORS, OPDS, M)
          applyMapsToMbs(SRS, ORS, MAS, M)
          applyMapsToEqs(SRS, ORS, EqS, M)
      endfm .
  eq applyMapsToModuleAux(SRS, ORS, TRS, fth MN is IL sorts SS . SSDS OPDS MAS EqS endfth, M)
    = fth MN is
          IL
          sorts applyMapsToSortSet(SRS, SS) .
          applyMapsToSubsorts(SRS, SSDS)
          applyMapsToOps(SRS, ORS, OPDS, M)
          applyMapsToMbs(SRS, ORS, MAS, M)
          applyMapsToEqs(SRS, ORS, EqS, M)
      endfth .
  eq applyMapsToModuleAux(SRS, ORS, TRS, omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom, M)
    = omod H is
           IL
           sorts applyMapsToSortSet(SRS, SS) .
           applyMapsToSubsorts(SRS, SSDS)
           applyMapsToClassDeclSet(SRS, ORS, CDS)
           applyMapsToSubclassDeclSet(SRS, SCDS)
           applyMapsToOps(SRS, ORS, OPDS, M)
           applyMapsToMsgDeclSet(SRS, ORS, MDS, M)
           applyMapsToMbs(SRS, ORS, MAS, M)
           applyMapsToEqs(SRS, ORS, EqS, M)
           applyMapsToRls(SRS, ORS, RlS, M)
      endom .
  eq applyMapsToModuleAux(SRS, ORS, TRS, oth MN is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth, M)
    = oth MN is
           IL
           sorts applyMapsToSortSet(SRS, SS) .
           applyMapsToSubsorts(SRS, SSDS)
           applyMapsToClassDeclSet(SRS, ORS, CDS)
           applyMapsToSubclassDeclSet(SRS, SCDS)
           applyMapsToOps(SRS, ORS, OPDS, M)
           applyMapsToMsgDeclSet(SRS, ORS, MDS, M)
           applyMapsToMbs(SRS, ORS, MAS, M)
           applyMapsToEqs(SRS, ORS, EqS, M)
           applyMapsToRls(SRS, ORS, RlS, M)
      endoth .
  eq applyMapsToModuleAux(SRS, ORS, TRS, smod H is IL sorts SS . SSDS OPDS MAS EqS RlS StratDcls StratDefs endsm, M)
    = smod H is
          IL
          sorts applyMapsToSortSet(SRS, SS) .
          applyMapsToSubsorts(SRS, SSDS)
          applyMapsToOps(SRS, ORS, OPDS, M)
          applyMapsToMbs(SRS, ORS, MAS, M)
          applyMapsToEqs(SRS, ORS, EqS, M)
          applyMapsToRls(SRS, ORS, RlS, M)
          applyMapsToStratDcls(SRS, ORS, TRS, StratDcls, M)
          applyMapsToStratDefs(SRS, ORS, TRS, StratDefs, M)
      endsm .
  eq applyMapsToModuleAux(SRS, ORS, TRS, sth MN is IL sorts SS . SSDS OPDS MAS EqS RlS StratDcls StratDefs endsth, M)
    = sth MN is
          IL sorts applyMapsToSortSet(SRS, SS) .
          applyMapsToSubsorts(SRS, SSDS)
          applyMapsToOps(SRS, ORS, OPDS, M)
          applyMapsToMbs(SRS, ORS, MAS, M)
          applyMapsToEqs(SRS, ORS, EqS, M)
          applyMapsToRls(SRS, ORS, RlS, M)
          applyMapsToStratDcls(SRS, ORS, TRS, StratDcls, M)
          applyMapsToStratDefs(SRS, ORS, TRS, StratDefs, M)
      endsth .

  eq applyMapsToOps(RS, RS', (op F : TyL -> Ty [AtS] . OPDS), M)
    = (applyMapsToOp(RS, getRightOpMaps(F, TyL, Ty, RS', M), RS', (op F : TyL -> Ty [AtS] .), M)
       applyMapsToOps(RS, RS', OPDS, M)) .
  eq applyMapsToOps(RS, RS', none, M) = none .

  eq applyMapsToOp(RS, R, RS', (op F : TyL -> Ty [AtS] .), M)
    = (op applyOpMapsToOpId(F, R) : applyMapsToTypeList(RS, TyL) -> applyMapsToType(RS, Ty)
         [applyMapsToAttrs(RS, RS', applyMapToAttrs(R, AtS), M)] .) .
  eq applyMapsToOp(RS, (R, RS'), RS'', (op F : TyL -> Ty [AtS] .), M)
    *** In case of ambiguous mappings we take one of them arbitrarily
    = (op applyOpMapsToOpId(F, R) : applyMapsToTypeList(RS, TyL) -> applyMapsToType(RS, Ty)
         [applyMapsToAttrs(RS, RS'', applyMapToAttrs(R, AtS), M)] .) .
  eq applyMapsToOp(RS, none, RS', (op F : TyL -> Ty [AtS] .), M)
    *** No map for this declaration
    = (op F : applyMapsToTypeList(RS, TyL) -> applyMapsToType(RS, Ty)
         [applyMapsToAttrs(RS, RS', AtS, M)] .) .

  eq applyMapsToMsgDeclSet(RS, RS', ((msg F : TyL -> Ty .) MDS), M)
    = (applyMapsToMsgDecl(RS, getRightOpMaps(F, TyL, Ty, RS', M), (msg F : TyL -> Ty .), M)
       applyMapsToMsgDeclSet(RS, RS', MDS, M)) .
  eq applyMapsToMsgDeclSet(RS, RS', none, M) = none .

  eq applyMapsToMsgDecl(RS, R, (msg F : TyL -> Ty .), M)
    = (msg applyOpMapsToOpId(F, R) : applyMapsToTypeList(RS, TyL) -> applyMapsToType(RS, Ty) .) .
  eq applyMapsToMsgDecl(RS, (R, RS'), (msg F : TyL -> Ty .), M)
    *** In case of ambiguous mappings we take one of them arbitrarily
    = (msg applyOpMapsToOpId(F, R) : applyMapsToTypeList(RS, TyL) -> applyMapsToType(RS, Ty) .) .
  eq applyMapsToMsgDecl(RS, none, (msg F : TyL -> Ty .), M)
    *** No map for this declaration
    = (msg F : applyMapsToTypeList(RS, TyL) -> applyMapsToType(RS, Ty) .) .

*** The function \texttt{applyMapToAttrs} just takes care of changing the
*** attributes of the operators as indicated in the renamings. The renamings
*** properly said is accomplished by the function
*** \texttt{applyMapsToAttrs}.

  eq applyMapToAttrs((msg F to F'), AtS) = AtS .
  eq applyMapToAttrs((msg F : TyL -> Ty to F'), AtS) = AtS .
  eq applyMapToAttrs(op_to`term_(T, T'), AtS) = AtS .
  eq applyMapToAttrs((op F to F' [AtS]), AtS')
    = applyMapToAttrsAux(AtS, AtS', none) .
  eq applyMapToAttrs((op F : TyL -> Ty to F' [AtS]), AtS')
    = applyMapToAttrsAux(AtS, AtS', none) .
  eq applyMapToAttrs(R, AtS) = AtS [owise] .

  *** add the new syntactic attributes
  eq applyMapToAttrsAux((gather(QIL) AtS), AtS', AtS'')
    = applyMapToAttrsAux(AtS, AtS', (gather(QIL) AtS'')) .
  eq applyMapToAttrsAux((format(QIL) AtS), AtS', AtS'')
    = applyMapToAttrsAux(AtS, AtS', (format(QIL) AtS'')) .
  eq applyMapToAttrsAux((prec(I) AtS), AtS', AtS'')
    = applyMapToAttrsAux(AtS, AtS', (prec(I) AtS'')) .
  eq applyMapToAttrsAux((At AtS), AtS', AtS'')
    = applyMapToAttrsAux(AtS, AtS', AtS'')
    [owise] .

  *** remove the old syntactic attributes
  eq applyMapToAttrsAux(AtS, (format(QIL) AtS'), AtS'')
    = applyMapToAttrsAux(AtS, AtS', AtS'') .
  eq applyMapToAttrsAux(AtS, (gather(QIL) AtS'), AtS'')
    = applyMapToAttrsAux(AtS, AtS', AtS'') .
  eq applyMapToAttrsAux(AtS, (prec(I) AtS'), AtS'')
    = applyMapToAttrsAux(AtS, AtS', AtS'') .

  eq applyMapToAttrsAux(none, (At AtS), AtS')
    = applyMapToAttrsAux(none, AtS, (At AtS')) .
  eq applyMapToAttrsAux(none, none, AtS) = AtS .

  eq applyMapsToTypeList(RS, (Ty TyL))
    = (applyMapsToType(RS, Ty) applyMapsToTypeList(RS, TyL)) .
  eq applyMapsToTypeList(RS, nil) = nil .

  eq applyMapsToSubsorts(RS, ((subsort S < S' .) SSDS))
    = ((subsort applyMapsToType(RS, S) < applyMapsToType(RS, S') .)
       applyMapsToSubsorts(RS, SSDS)) .
  eq applyMapsToSubsorts(RS, none) = none .

  eq applyMapsToAttrs(RS, RS', (id(T) AtS), M)
    = (id(applyMapsToTerm2(RS, RS', T, M))
       applyMapsToAttrs(RS, RS', AtS, M)) .
  eq applyMapsToAttrs(RS, RS', (left-id(T) AtS), M)
    = (left-id(applyMapsToTerm2(RS, RS', T, M))
       applyMapsToAttrs(RS, RS', AtS, M)) .
  eq applyMapsToAttrs(RS, RS', (right-id(T) AtS), M)
    = (right-id(applyMapsToTerm2(RS, RS', T, M))
       applyMapsToAttrs(RS, RS', AtS, M)) .
  eq applyMapsToAttrs(RS, RS', (special(HkL) AtS), M)
    = (special(applyMapsToHooks(RS, RS', HkL, M))
       applyMapsToAttrs(RS, RS', AtS, M)) .
  eq applyMapsToAttrs(RS, RS', (label(L) AtS), M)
    = (label(applyMapsToLabel(RS, L))
       applyMapsToAttrs(RS, RS', AtS, M)) .
  eq applyMapsToAttrs(RS, RS', AtS, M) = AtS [owise] .

  eq applyMapsToHooks(RS, RS', id-hook(QI, QIL) HkL, M)
    = id-hook(QI, QIL)
      applyMapsToHooks(RS, RS', HkL, M).
  eq applyMapsToHooks(RS, RS', op-hook(QI, QI', QIL, QI'') HkL, M)
    = applyMapsToHooksAux(RS,
         getRightOpMaps(QI', QIL, QI'', RS', M),
         op-hook(QI, QI', QIL, QI''), M)
      applyMapsToHooks(RS, RS', HkL, M).
  eq applyMapsToHooks(RS, RS', term-hook(QI, T) HkL, M)
    = term-hook(QI, applyMapsToTerm2(RS, RS', T, M))
      applyMapsToHooks(RS, RS', HkL, M).
  eq applyMapsToHooks(RS, RS', nil, M) = nil .

  eq applyMapsToHooksAux(RS, R, op-hook(QI, F, TyL, Ty), M)
    = op-hook(QI, applyOpMapsToOpId(F, R),
         applyMapsToTypeList(RS, TyL), applyMapsToType(RS, Ty)) .
  eq applyMapsToHooksAux(RS, (R, RS'), op-hook(QI, F, TyL, Ty), M)
    *** In case of ambiguous mappings we take any of them arbitrarily
    = op-hook(QI, applyOpMapsToOpId(F, R),
         applyMapsToTypeList(RS, TyL), applyMapsToType(RS, Ty)) .
  eq applyMapsToHooksAux(RS, none, op-hook(QI, F, TyL, Ty), M)
    = op-hook(QI, F, applyMapsToTypeList(RS, TyL),
        applyMapsToType(RS, Ty)) .

  eq applyMapsToMbs(SRS, ORS, ((mb T : S [AtS] .) MAS), M)
    = ((mb applyMapsToTerm2(SRS, ORS, T, M) : applyMapsToType(SRS, S)
          [applyMapsToAttrs(SRS, ORS, AtS, M)] .)
       applyMapsToMbs(SRS, ORS, MAS, M)) .
  eq applyMapsToMbs(SRS, ORS, ((cmb T : S if Cond [AtS] .) MAS), M)
    = ((cmb applyMapsToTerm2(SRS, ORS, T, M) : applyMapsToType(SRS, S)
          if applyMapsToCond(SRS, ORS, Cond, M)
          [applyMapsToAttrs(SRS, ORS, AtS, M)] .)
       applyMapsToMbs(SRS, ORS, MAS, M)) .
  eq applyMapsToMbs(SRS, ORS, none, M) = none .

  eq applyMapsToEqs(RS, RS', ((ceq T = T' if Cond [AtS] .) EqS), M)
    = ((ceq applyMapsToTerm2(RS, RS', T, M)
          = applyMapsToTerm2(RS, RS', T', M)
          if applyMapsToCond(RS, RS', Cond, M)
        [applyMapsToAttrs(RS, RS', AtS, M)] .)
       applyMapsToEqs(RS, RS', EqS, M)) .
  eq applyMapsToEqs(RS, RS', ((eq T = T' [AtS] .) EqS), M)
    = ((eq applyMapsToTerm2(RS, RS', T, M)
          = applyMapsToTerm2(RS, RS', T', M)
          [applyMapsToAttrs(RS, RS', AtS, M)] .)
       applyMapsToEqs(RS, RS', EqS, M)) .
  eq applyMapsToEqs(RS, RS', none, M) = none .

  eq applyMapsToRls(RS, RS', ((crl T => T' if Cond [AtS] .) RlS), M)
    = ((crl applyMapsToTerm2(RS, RS', T, M)
          => applyMapsToTerm2(RS, RS', T', M)
          if applyMapsToCond(RS, RS', Cond, M)
          [applyMapsToAttrs(RS, RS', AtS, M)] .)
       applyMapsToRls(RS, RS', RlS, M)) .
  eq applyMapsToRls(RS, RS', ((rl T => T' [AtS] .) RlS), M)
    = ((rl applyMapsToTerm2(RS, RS', T, M)
          => applyMapsToTerm2(RS, RS', T', M)
          [applyMapsToAttrs(RS, RS', AtS, M)] .)
       applyMapsToRls(RS, RS', RlS, M)) .
  eq applyMapsToRls(RS, RS', none, M) = none .

  eq applyMapsToCond(RS, RS', T = T' /\ Cond, M)
    = applyMapsToTerm2(RS, RS', T, M) = applyMapsToTerm2(RS, RS', T', M)
      /\ applyMapsToCond(RS, RS', Cond, M) .
  eq applyMapsToCond(RS, RS', T : S /\ Cond, M)
    = applyMapsToTerm2(RS, RS', T, M) : applyMapsToSort(RS, S)
      /\ applyMapsToCond(RS, RS', Cond, M) .
  eq applyMapsToCond(RS, RS', T := T' /\ Cond, M)
    = applyMapsToTerm2(RS, RS', T, M) := applyMapsToTerm2(RS, RS', T', M)
      /\ applyMapsToCond(RS, RS', Cond, M) .
  eq applyMapsToCond(RS, RS', T => T' /\ Cond, M)
    = applyMapsToTerm2(RS, RS', T, M) => applyMapsToTerm2(RS, RS', T', M)
      /\ applyMapsToCond(RS, RS', Cond, M) .
  eq applyMapsToCond(RS, RS', nil, M) = nil .

  eq applyMapsToLabel((label L to L'), L'')
    = if L == L''
      then L'
      else L''
      fi .
  eq applyMapsToLabel(((label L to L'), RS), L'')
    = if L == L''
      then L'
      else applyMapsToLabel(RS, L'')
      fi .
  eq applyMapsToLabel(R, L) = L [owise] .
  eq applyMapsToLabel((R, RS), L)
    = applyMapsToLabel(RS, L)
    [owise] .
  eq applyMapsToLabel(none, L) = L .

  eq applyMapsToClassDeclSet(RS, RS', class C | ADS . CDS)
    = (class applyMapsToClassName(RS, C) | applyMapsToAttrDeclSet(RS, RS', C, ADS) .
       applyMapsToClassDeclSet(RS, RS', CDS)) .
  eq applyMapsToClassDeclSet(RS, RS', none) = none .

  eq applyMapsToAttrDeclSet(RS, RS', C, ((attr A : Ty), ADS))
    = ((attr applyMapsToAttrName(RS', C, A) : applyMapsToType(RS, Ty)),
       applyMapsToAttrDeclSet(RS, RS', C, ADS)) .
  eq applyMapsToAttrDeclSet(RS, RS', C, none) = none .

  eq applyMapsToAttrName((attr A . C to A'), C', A'')
    = if (C == C') and (A == A'')
      then A'
      else A''
      fi .
  eq applyMapsToAttrName(((attr A . C to A'), RS), C', A'')
    = if (C == C') and (A == A'')
      then A'
      else applyMapsToAttrName(RS, C', A'')
      fi .
  eq applyMapsToAttrName(R, C, A) = A [owise] .
  eq applyMapsToAttrName((R, RS), C, A)
    = applyMapsToAttrName(RS, C, A)
    [owise] .
  eq applyMapsToAttrName(none, C, A) = A .

  eq applyMapsToSubclassDeclSet(RS, subclass C < C' . SCDS)
    = (subclass applyMapsToClassName(RS, C) < applyMapsToClassName(RS, C') .
       applyMapsToSubclassDeclSet(RS, SCDS)) .
  eq applyMapsToSubclassDeclSet(RS, none) = none .

  eq applyMapsToStratDcls(RS, RS', RS'', (strat F : TyL @ Ty [AtS] . StratDcls), M)
    = (applyMapsToStratDcl(RS, RS', getRightStratMaps(F, TyL, RS'', M), (strat F : TyL @ Ty [AtS] .), M)
       applyMapsToStratDcls(RS, RS', RS'', StratDcls, M)) .
  eq applyMapsToStratDcls(RS, RS', RS'', none, M) = none .

  eq applyMapsToStratDcl(RS, RS', R, (strat F : TyL @ Ty [AtS] .), M)
    = (strat applyStMapsToStId(F, R) : applyMapsToTypeList(RS, TyL) @ applyMapsToType(RS, Ty)
        [applyMapsToAttrs(RS, RS', AtS, M)] .) .
  eq applyMapsToStratDcl(RS, RS', (R, RS''), (strat F : TyL @ Ty [AtS] .), M)
    *** In case of ambiguous mappings we take one of them arbitrarily
    = (strat applyStMapsToStId(F, R) : applyMapsToTypeList(RS, TyL) @ applyMapsToType(RS, Ty)
        [applyMapsToAttrs(RS, RS', AtS, M)] .) .
  eq applyMapsToStratDcl(RS, RS', none, (strat F : TyL @ Ty [AtS] .), M)
    *** No map for this declaration
    = (strat F : applyMapsToTypeList(RS, TyL) @ applyMapsToType(RS, Ty) [applyMapsToAttrs(RS, RS', AtS, M)] .) .

  eq applyMapsToStratDefs(RS, RS', RS'', csd CS := Strat if Cond [AtS] . StratDefs, M)
    = (csd applyMapsToStrategy(RS, RS', RS'', CS, M)
         := applyMapsToStrategy(RS, RS', RS'', Strat, M)
         if applyMapsToCond(RS, RS', Cond, M)
         [applyMapsToAttrs(RS, RS', AtS, M)] .)
      applyMapsToStratDefs(RS, RS', RS'', StratDefs, M) .
  eq applyMapsToStratDefs(RS, RS', RS'', sd CS := Strat [AtS] . StratDefs, M)
    = (sd applyMapsToStrategy(RS, RS', RS'', CS, M)
         := applyMapsToStrategy(RS, RS', RS'', Strat, M)
         [applyMapsToAttrs(RS, RS', AtS, M)] .)
      applyMapsToStratDefs(RS, RS', RS'', StratDefs, M) .
  eq applyMapsToStratDefs(RS, RS', RS'', none, M) = none .

----  op applyMapsToStrategy : RenamingSet RenamingSet RenamingSet Strategy Module -> Strategy .
  op imageOfCallStrategy : RenamingSet RenamingSet CallStrategy RenamingSet Module -> CallStrategy .
  op pseudoMatch : CallStrategy CallStrategy Module Substitution -> Substitution .
  op pseudoMatchCS : CallStrategy CallStrategy Module Substitution -> Substitution .

  eq imageOfCallStrategy(SRS, ORS, F[[TL]], (strat F to F', TRS), M)
    = F' [[ applyMapsToTerm2(SRS, ORS, TL, M) ]] .
  eq imageOfCallStrategy(SRS, ORS, F[[TL]], strat F to F', M)
    = F' [[ applyMapsToTerm2(SRS, ORS, TL, M) ]] .
  eq imageOfCallStrategy(SRS, ORS, F[[TL]], (strat F : TyL @ Ty to F', TRS), M)
    = F' [[ applyMapsToTerm2(SRS, ORS, TL, M) ]] .
  eq imageOfCallStrategy(SRS, ORS, F[[TL]], strat F : TyL @ Ty to F', M)
    = F' [[ applyMapsToTerm2(SRS, ORS, TL, M) ]] .
  eq imageOfCallStrategy(SRS, ORS, CS, (strat_to`expr_(CS', Strat), TRS), M)
    = applySubst(Strat, applyMapsToSubst(SRS, ORS, pseudoMatch(CS', CS, M, none), M)) .
  eq imageOfCallStrategy(SRS, ORS, CS, strat_to`expr_(CS', Strat), M)
    = applySubst(Strat, applyMapsToSubst(SRS, ORS, pseudoMatch(CS', CS, M, none), M)) .
  eq imageOfCallStrategy(SRS, ORS, F[[TL]], TRS, M)
    = F [[ applyMapsToTerm2(SRS, ORS, TL, M) ]]
    [owise] .

  eq pseudoMatch(CS, CS', M, Subst)
    = pseudoMatchResult(pseudoMatchCS(CS, CS', M, Subst)) .

  eq pseudoMatchCS(F[[TL]], F'[[TL']], M, Subst)
    = if F == F'
      then pseudoMatch2(TL, TL', M, Subst)
      else none
      fi .

  op getRightStratMaps : Qid TypeList RenamingSet Module -> RenamingSet .
  eq getRightStratMaps(F, TyL, (strat F to F'), M) = (strat F to F') .
  eq getRightStratMaps(F, TyL, (strat F to F', RS), M)
    = (strat F to F', getRightStratMaps(F, TyL, RS, M)) .
  eq getRightStratMaps(F, TyL, (strat F : TyL' @ Ty to F', RS), M)
    = if sameKind(M, TyL, TyL')
      then strat F : TyL' @ Ty to F'
      else none
      fi,
      getRightStratMaps(F, TyL, RS, M) .
  eq getRightStratMaps(F, TyL, strat F : TyL' @ Ty to F', M)
    = if sameKind(M, TyL, TyL')
      then strat F : TyL' @ Ty to F'
      else none
      fi .
  eq getRightStratMaps(F, TyL, (strat_to`expr_(F[[TL]], Strat), RS), M)
    = if sameKind(M, TyL, varListSort(TL))
      then strat_to`expr_(F[[TL]], Strat)
      else none
      fi,
      getRightStratMaps(F, TyL, RS, M) .
  eq getRightStratMaps(F, TyL, strat_to`expr_(F[[TL]], Strat), M)
    = if sameKind(M, TyL, varListSort(TL))
      then strat_to`expr_(F[[TL]], Strat)
      else none
      fi .
  eq getRightStratMaps(F, TyL:[Type], RS, M) = none [owise].

  op applyMapsToStrategy : RenamingSet RenamingSet RenamingSet Strategy Module -> Strategy .
  op applyMapsToStrategies : RenamingSet RenamingSet RenamingSet StrategyList Module -> StrategyList .
  op applyMapsToUPS : RenamingSet RenamingSet RenamingSet UsingPairSet Module -> UsingPairSet .

  eq applyMapsToStrategy(SRS, ORS, TRS, F[[TL]], M)
    = imageOfCallStrategy(SRS, ORS, F[[TL]], getRightStratMaps(F, eLeastSort(M, TL), TRS, M), M) .
  eq applyMapsToStrategy(SRS, ORS, TRS, fail, M) = fail .
  eq applyMapsToStrategy(SRS, ORS, TRS, idle, M) = idle .
  eq applyMapsToStrategy(SRS, ORS, TRS, all, M) = all .
  eq applyMapsToStrategy(SRS, ORS, TRS, QI[Subst]{Strats}, M)
    = QI [ applyMapsToSubst(SRS, ORS, Subst, M) ]
         { applyMapsToStrategies(SRS, ORS, TRS, Strats, M) } .
  eq applyMapsToStrategy(SRS, ORS, TRS, top(Strat), M)
    = top(applyMapsToStrategy(SRS, ORS, TRS, Strat, M)) .
  eq applyMapsToStrategy(SRS, ORS, TRS, match T s.t. Cond, M)
    = match applyMapsToTerm2(SRS, ORS, T, M) s.t. applyMapsToCond(SRS, ORS, Cond, M) .
  eq applyMapsToStrategy(SRS, ORS, TRS, xmatch T s.t. Cond, M)
    = xmatch applyMapsToTerm2(SRS, ORS, T, M) s.t. applyMapsToCond(SRS, ORS, Cond, M) .
  eq applyMapsToStrategy(SRS, ORS, TRS, amatch T s.t. Cond, M)
    = amatch applyMapsToTerm2(SRS, ORS, T, M) s.t. applyMapsToCond(SRS, ORS, Cond, M) .
  eq applyMapsToStrategy(SRS, ORS, TRS, Strat or-else Strat', M)
    = applyMapsToStrategy(SRS, ORS, TRS, Strat, M) or-else applyMapsToStrategy(SRS, ORS, TRS, Strat', M) .
  eq applyMapsToStrategy(SRS, ORS, TRS, Strat +, M)
    = applyMapsToStrategy(SRS, ORS, TRS, Strat, M) + .
  eq applyMapsToStrategy(SRS, ORS, TRS, Strat ? Strat' : Strat'', M)
    = applyMapsToStrategy(SRS, ORS, TRS, Strat, M) ?
      applyMapsToStrategy(SRS, ORS, TRS, Strat', M) :
      applyMapsToStrategy(SRS, ORS, TRS, Strat'', M) .
  eq applyMapsToStrategy(SRS, ORS, TRS, matchrew T s.t. Cond by UPS, M)
    = matchrew applyMapsToTerm2(SRS, ORS, T, M) s.t. applyMapsToCond(SRS, ORS, Cond, M)
        by applyMapsToUPS(SRS, ORS, TRS, UPS, M) .
  eq applyMapsToStrategy(SRS, ORS, TRS, xmatchrew T s.t. Cond by UPS, M)
    = xmatchrew applyMapsToTerm2(SRS, ORS, T, M) s.t. applyMapsToCond(SRS, ORS, Cond, M)
        by applyMapsToUPS(SRS, ORS, TRS, UPS, M) .
  eq applyMapsToStrategy(SRS, ORS, TRS, amatchrew T s.t. Cond by UPS, M)
    = amatchrew applyMapsToTerm2(SRS, ORS, T, M) s.t. applyMapsToCond(SRS, ORS, Cond, M)
        by applyMapsToUPS(SRS, ORS, TRS, UPS, M) .
  eq applyMapsToStrategy(SRS, ORS, TRS, one(Strat), M)
    = one(applyMapsToStrategy(SRS, ORS, TRS, Strat, M)) .
  eq applyMapsToStrategy(SRS, ORS, TRS, Strat *, M)
    = applyMapsToStrategy(SRS, ORS, TRS, Strat, M) * .
  eq applyMapsToStrategy(SRS, ORS, TRS, Strat !, M)
    = applyMapsToStrategy(SRS, ORS, TRS, Strat, M) ! .
  eq applyMapsToStrategy(SRS, ORS, TRS, not(Strat), M)
    = not(applyMapsToStrategy(SRS, ORS, TRS, Strat, M)) .
  eq applyMapsToStrategy(SRS, ORS, TRS, test(Strat), M)
    = test(applyMapsToStrategy(SRS, ORS, TRS, Strat, M)) .
  eq applyMapsToStrategy(SRS, ORS, TRS, try(Strat), M)
    = try(applyMapsToStrategy(SRS, ORS, TRS, Strat, M)) .
  ceq applyMapsToStrategy(SRS, ORS, TRS, Strat | Strat', M)
     = applyMapsToStrategy(SRS, ORS, TRS, Strat, M) | applyMapsToStrategy(SRS, ORS, TRS, Strat', M)
     if Strat =/= fail /\ Strat' =/= fail .
  ceq applyMapsToStrategy(SRS, ORS, TRS, Strat ; Strat', M)
     = applyMapsToStrategy(SRS, ORS, TRS, Strat, M) ; applyMapsToStrategy(SRS, ORS, TRS, Strat', M)
     if Strat =/= idle /\ Strat' =/= idle .

  eq applyMapsToStrategies(SRS, ORS, TRS, (Strat, Strats), M)
    = applyMapsToStrategy(SRS, ORS, TRS, Strat, M) .
  eq applyMapsToStrategies(SRS, ORS, TRS, empty, M) = empty .

  eq applyMapsToUPS(SRS, ORS, TRS, (V using Strat, UPS), M)
    = applyMapsToVars(SRS, V) using applyMapsToStrategy(SRS, ORS, TRS, Strat, M),
      applyMapsToUPS(SRS, ORS, TRS, UPS, M) .
  eq applyMapsToUPS(SRS, ORS, TRS, V using Strat, M)
    = applyMapsToVars(SRS, V) using applyMapsToStrategy(SRS, ORS, TRS, Strat, M) .

  op applySubst : StrategyList Substitution -> StrategyList .
  eq applySubst(F[[TL]], Subst) = F[[applySubst(TL, Subst)]] .
  eq applySubst(fail, Subst) = fail .
  eq applySubst(idle, Subst) = idle .
  eq applySubst(all, Subst) = all .
  eq applySubst(QI[Subst]{Strats}, Subst') = QI [ applySubst(Subst, Subst') ] { applySubst(Strats, Subst') } .
  eq applySubst(top(Strat), Subst) = top(applySubst(Strat, Subst)) .
  eq applySubst(match T s.t. Cond, Subst) = match applySubst(T, Subst) s.t. applySubst(Cond, Subst) .
  eq applySubst(xmatch T s.t. Cond, Subst) = xmatch applySubst(T, Subst) s.t. applySubst(Cond, Subst) .
  eq applySubst(amatch T s.t. Cond, Subst) = amatch applySubst(T, Subst) s.t. applySubst(Cond, Subst) .
  eq applySubst(Strat | Strat', Subst) = applySubst(Strat, Subst) | applySubst(Strat', Subst) .
  eq applySubst(Strat ; Strat', Subst) = applySubst(Strat, Subst) ; applySubst(Strat', Subst) .
  eq applySubst(Strat or-else Strat', Subst) = applySubst(Strat, Subst) or-else applySubst(Strat', Subst) .
  eq applySubst(Strat +, Subst) = applySubst(Strat, Subst) + .
  eq applySubst(Strat ? Strat' : Strat'', Subst)
    = applySubst(Strat, Subst) ? applySubst(Strat', Subst) : applySubst(Strat'', Subst) .
  eq applySubst(matchrew T s.t. Cond by UPS, Subst)
    = matchrew applySubst(T, Subst) s.t. applySubst(Cond, Subst) by applySubst(UPS, Subst) .
  eq applySubst(xmatchrew T s.t. Cond by UPS, Subst)
    = xmatchrew applySubst(T, Subst) s.t. applySubst(Cond, Subst) by applySubst(UPS, Subst) .
  eq applySubst(amatchrew T s.t. Cond by UPS, Subst)
    = amatchrew applySubst(T, Subst) s.t. applySubst(Cond, Subst) by applySubst(UPS, Subst) .
  eq applySubst(one(Strat), Subst)
    = one(applySubst(Strat, Subst)) .
  eq applySubst(Strat *, Subst)
    = applySubst(Strat, Subst) * .
  eq applySubst(Strat !, Subst)
    = applySubst(Strat, Subst) ! .
  eq applySubst(not(Strat), Subst)
    = not(applySubst(Strat, Subst)) .
  eq applySubst(test(Strat), Subst)
    = test(applySubst(Strat, Subst)) .
  eq applySubst(try(Strat), Subst)
    = try(applySubst(Strat, Subst)) .

  op applySubst : UsingPairSet Substitution -> UsingPairSet .
  eq applySubst((V using Strat, UPS), Subst)
    = applySubst(V, Subst) using applySubst(Strat, Subst), applySubst(UPS, Subst) .
  eq applySubst(V using Strat, Subst) = applySubst(V, Subst) using applySubst(Strat, Subst) .

endfm

*******************************************************************************

***
*** 6.9 Instantiation of Parameterized Modules and the
***     \texttt{META-LEVEL} Module Expression

*** A parameterized module
*** $\texttt{M[L}_1\texttt{\ ::\ T}_1\texttt{,\}\ldots\texttt{, L}_n
*** \texttt{ :: T}_n\texttt{]}$, with \mbox{$\texttt{L}_1\ldots\texttt{L}_n$}
*** labels and \mbox{$\texttt{T}_1\ldots\texttt{T}_n$} theory identifiers, is
*** represented as a module with name \texttt{M} which contains parameter
*** declarations  \mbox{$\texttt{par\ L}_i\texttt{\ ::\ T}_i$} for
*** $1\leq i\leq n$, and an importation declaration
*** \mbox{$\texttt{inc\ par\ L}_i\texttt{\ ::\ T}_i\texttt{\ .}$} for each
*** parameter \mbox{$\texttt{L}_i\texttt{\ ::\ T}_i$} in its interface.  Note
*** that all modules are handled in a uniform way: nonparameterized modules
*** and theories have their list of parameters set to \texttt{nil}.

*** The instantiation of the formal parameters of a parameterized module with
*** actual modules or theories requires a view from each formal parameter
*** theory to its corresponding actual unit. The process of instantiation
*** results in the replacement of each interface theory by its corresponding
*** actual parameter, using the views to bind actual names to formal names.

*** The naming conventions for sorts have to be taken into account in the
*** instantiation process: every occurrence of a sort coming from a theory in
*** the interface of a module must be qualified by its theory's label, and
*** sorts defined in the body of a parameterized module can be parameterized
*** by the labels in the interface of the module (see
*** Section~\ref{parameterized-modules}).

*** The labeling convention for theories and for the sorts coming from them is
*** very useful to avoid collisions of sort names coming from the parameter
*** theories, and also to allow different uses of the same theory several
*** times in the interface of a module. We assume that all sorts coming from
*** the theory part of the parameter theories are used in their qualified form
*** to manipulate the maps defined in the views before being applied to the
*** body of the module being instantiated. If the target of a view is a
*** theory, the sorts from the theory part of the target theory appearing in
*** the targTS of the maps in the view will be qualified as well, following
*** the same convention.

*** When a parameterized module
*** $\texttt{M[L}_1\texttt{\ ::\ T}_1\texttt{,\ }
***            \ldots\texttt{,\ L}_n\texttt{\ ::\ T}_n\texttt{]}$
*** is instantiated with views $\texttt{V}_1\ldots\texttt{V}_n$, each
*** parameterized sort $\texttt{S[L}_1\texttt{,}\ldots\texttt{,L}_n\texttt{]}$
*** in the body of the parameterized module is renamed to
*** $\texttt{S[V}_1\texttt{,}\ldots\texttt{,V}_n\texttt{]}$.

*** The discussion on the qualification of sorts in views before being used in
*** the instantiation process applies in a completely similar way to class
*** names in parameterized object-oriented modules.

*** As we saw in Section~\ref{module-expressions}, it is possible to import a
*** module expression in which a parameterized module is instantiated by some
*** of the formal parameters of the parameterized module in which it is
*** imported. This is done by using the label of some of the parameters in the
*** interface of a module, say \mbox{$\texttt{L}_k\texttt{\ ::\ T}_k$}, in a
*** module expression in which some parameterized module \texttt{N} with formal
*** parameter $\texttt{T}_k$ is instantiated with $\texttt{L}_k$, that is, we
*** have the module expression $\texttt{N[}\ldots\texttt{L}_k\ldots\texttt{]}$.
*** In this case, $\texttt{L}_k$ is considered as the identity view for the
*** theory $\texttt{T}_k$ with $\texttt{L}_k$ as name. Note that to be able to
*** check whether a label in the interface of a module is used in an
*** instantiation of this form, in the evaluation of a module expression the
*** list of parameters of the module in which the module expression appears
*** must be available. This is the reason why the \texttt{evalModExp} function
*** was defined with \texttt{ParameterList} as one of the sorts in its
*** arity (see Section~\ref{evalModExp}). For module expressions appearing
*** outside of any module, that is, in commands, etc., this list will be set
*** to \texttt{nil}.

*** Note that this kind of instantiation may produce a `cascade' effect. The
*** module being instantiated may itself import other module expressions in
*** which labels of some of its parameter theories are used in the
*** instantiation of some of these imported module expressions. This is handled
*** by `preparing' the module expressions appearing in the importation
*** declarations of the module (\texttt{prepImports}). This process
*** consists in changing the labels of the interface of the module being
*** instantiated which are used in the importations of module expressions by
*** the corresponding view names (\texttt{prepHeader}). After completing the
*** generation of the module resulting from the evaluation of the module
*** expression, this module will be evaluated with the \texttt{evalModule}
*** function, producing the evaluation of these new module expressions. In any
*** extension of the language, new equations for the function
*** \texttt{prepHeader} will have to be added for each new kind of module
*** expression being defined.

*** In Sections~\ref{renaming} and~\ref{extension} we shall see how new
*** equations completing the semantics of \texttt{prepHeader} are added for
*** each new module expression being defined. In the case of the renaming
*** module expression, the renaming maps will have to be prepared as well, to
*** adjust the sort names being renamed to the conventions discussed above.

*** As for any other module expression being defined, in addition to the
*** operator declaration for the constructor of the instantiation module
*** expression, equations completing the semantics of operators
*** \texttt{evalModExp}, \texttt{header2QidList}, and
*** \texttt{setUpModExpDeps} have to be given.

fmod FM-INST-EXPR-EVALUATION is
  pr FM-EVALUATION .
  pr FM-RENAMING-SET-APPL-ON-UNIT .
  inc MOD-EXPR .
  inc MOD-NAME .
  pr DATABASE .

*** We start by giving the new constructor for sort \texttt{ModuleExpression}.
*** Note that the modules \texttt{MOD-EXPR} and \texttt{MOD-NAME} have been
*** imported in \texttt{including} mode.

  vars QI QI' QI'' X Y W Z C F F' A A' L L' : Qid .
  var  QIL : QidList .
  vars M M' PU U U' U'' DM : Module .
  var  Th : Theory .
  vars ME ME' ME'' ME''' : ModuleExpression .
  var  H : Header .
  vars MN MN' : ModuleName .
  vars MNS MNS' MNS'' MNS3 MNS4 MNS5 : Set{ModuleName} .
  vars VE VE' VE'' VE3 VE4 : ViewExpression .
  vars VES VES' : Set{ViewExpression} .
  vars MIS MIS' : Set{ModuleInfo} .
  var  VIS : Set{ViewInfo} .
  vars DB DB' DB'' DB''' : Database .
  var  PD : ParameterDecl .
  vars PDL PDL' PDL'' PDL3 PDL4 PDL5 : ParameterDeclList .
  var  PDS : Set{ParameterDecl} .
  vars PL PL' PL'' PL3 : ParameterList .
  vars S S' P P' P'' : Sort .
  vars IL IL' IL'' IL3 : ImportList .
  vars SMS SMS' SMS'' SMS3 : SortMappingSet .
  vars OMS OMS' OMS'' OMS3 : OpMappingSet .
  vars TMS TMS' TMS'' TMS3 : StratMappingSet .
  var  V : Variable .
  var  Ct : Constant .
  var  SL : QidList .
  var  Ty : Type .
  var  TyL : TypeList .
  vars SS SS' SS'' : SortSet .
  var  K : Kind .
  vars T T' O : Term .
  var  DT : Default{Term} .
  var  TL : TermList .
  var  CDS : ClassDeclSet .
  var  ADS : AttrDeclSet .
  var  B : Bool .
  var  AtS : AttrSet .
  var  N : Nat .
  var  PV : PreView .
  var  VI : View .
  var  VDS : VariableSet .
  vars RS RS' RS'' SRS SRS' ORS ORS' : RenamingSet .

*** In the input given by the user, the operator \verb~_(_)~ is used both for
*** the instantiation of module expressions, and for expressions
*** parameterizing the module \texttt{META-LEVEL} with a list of module names.
*** The function \texttt{evalModExp} distinguishes these two cases, calling
*** the function \texttt{unitInst} in the former and the function
*** \texttt{prepMetalevel} in the latter.

  op unitInst : Header ParameterList ParameterDeclList Database -> Database .
  op prepMetalevel : ParameterList Database -> Database .

  eq evalModExp(ME{PL}, PDL, DB)
    = if unitInDb(ME{PL}, DB)
      then < DB ; ME{PL} >
      else if ME == 'META-LEVEL
           then < prepMetalevel(PL, DB) ; ME{PL} >
           else < unitInst(
                    modExp(evalModExp(ME, PDL, evalViewExpression(PL, PDL, DB))),
                    PL, PDL,
                    database(evalModExp(ME, PDL, evalViewExpression(PL, PDL, DB))))
                  ;
                  modExp(evalModExp(ME, PDL, evalViewExpression(PL, PDL, DB))){PL} >
           fi
      fi .

*** The function \texttt{prepMetalevel} creates a new module with the
*** module expression being evaluated as name, which imports the predefined
*** \texttt{META-LEVEL} module. For each module name \texttt{I} in the list
*** given as parameter of the expression, the declaration of a constant
*** \texttt{I} of sort \texttt{Module} and an equation identifying such
*** constant with the metarepresentation of the module with such name in the
*** database are added to the module being created.

  op prepMetalevelAux : ParameterList Module Database -> Database .

  eq prepMetalevel(PL, DB)
    = prepMetalevelAux(PL,
        addImports((including 'META-LEVEL .),
          setName(emptyFModule, 'META-LEVEL{PL})), DB) .

  eq prepMetalevelAux((QI), U, DB)
    = prepMetalevelAux(nil,
        addOps((op qid("META-" + string(QI)) : nil -> 'Module [none] .),
          addEqs((eq qid("META-" + string(QI) + ".Module")
                    = up(getFlatModule(QI, database(evalModExp(QI, DB))))
                    [none] .),
            U)),
        DB) .
  eq prepMetalevelAux((QI, PL), U, DB)
    = prepMetalevelAux(PL,
        addOps((op qid("META-" + string(QI)) : nil -> 'Module [none] .),
          addEqs((eq qid("META-" + string(QI) + ".Module")
                    = up(getFlatModule(QI, database(evalModExp(QI, DB))))
                    [none] .),
            U)),
        DB) .
  eq prepMetalevelAux(nil, U, DB) = evalModule(U, none, DB) .

*** The function \texttt{getClassNames} returns the set of the names of
*** the classes in a set of class declarations.

  op getClassNames : ClassDeclSet -> SortSet .

  eq getClassNames(((class S | ADS .) CDS))
    = (S ; getClassNames(CDS)) .
  eq getClassNames(none) = none .

*** The following `getTh' functions return the corresponding elements in the
*** theory part of the structure of the given unit. For example, the function
*** \texttt{getThSorts} returns the set of sorts declared in the ``loose
*** part'' of the structure of the unit in the database having the name
*** indicated as first argument.

  op getThSorts : ModuleExpression Database -> SortSet .
  op getThClasses : ModuleExpression Database -> SortSet .
  op getThSortsAux : ImportList Database -> SortSet .
  op getThClassesAux : ImportList Database -> SortSet .

  eq getThSorts(ME, DB)
    = if theory(getTopModule(ME, DB))
      then (getThSortsAux(getImports(getTopModule(ME, DB)), DB) ;
            getSorts(getTopModule(ME, DB)))
      else none
      fi .

  eq getThSortsAux(((including MN .) IL), DB)
    = (getThSorts(MN, DB) ; getThSortsAux(IL, DB)) .
  eq getThSortsAux(((extending MN .) IL), DB)
    = (getThSorts(MN, DB) ; getThSortsAux(IL, DB)) .
  eq getThSortsAux(((protecting MN .) IL), DB)
    = (getThSorts(MN, DB) ; getThSortsAux(IL, DB)) .
  eq getThSortsAux(nil, DB) = none .

  eq getThClasses(ME, DB)
    = if getTopModule(ME, DB) :: OTheory
         and-then not getTopModule(ME, DB) :: STheory
      then (getThClassesAux(getImports(getTopModule(ME, DB)), DB) ;
            getClassNames(getClasses(getTopModule(ME, DB))))
      else none
      fi .

  eq getThClassesAux(((including MN .) IL), DB)
    = (getThClasses(MN, DB) ; getThClassesAux(IL, DB)) .
  eq getThClassesAux(((extending MN .) IL), DB)
    = (getThClasses(MN, DB) ; getThClassesAux(IL, DB)) .
  eq getThClassesAux(((protecting MN .) IL), DB)
    = (getThClasses(MN, DB) ; getThClassesAux(IL, DB)) .
  eq getThClassesAux(nil, DB) = none .

*** The `get' functions return the corresponding elements in the structure of
*** the given unit. For example, \texttt{getSortSet} returns all the sorts
*** declared in the structure of the unit in the database having the name
*** given as first argument.

  op getSortSet : ModuleName Database -> SortSet .
  op getClassSet : ModuleName Database -> SortSet .

  op getSortSetAux : ImportList Database -> SortSet .
  op getClassSetAux : ImportList Database -> SortSet .

  eq getSortSet(MN, DB)
    = (getSortSetAux(getImports(getTopModule(MN, DB)), DB) ;
       getSorts(getTopModule(MN, DB))) .

  eq getSortSetAux(((including MN .) IL), DB)
    = (getSortSet(MN, DB) ; getSortSetAux(IL, DB)) .
  eq getSortSetAux(((extending MN .) IL), DB)
    = (getSortSet(MN, DB) ; getSortSetAux(IL, DB)) .
  eq getSortSetAux(((protecting MN .) IL), DB)
    = (getSortSet(MN, DB) ; getSortSetAux(IL, DB)) .
  eq getSortSetAux(nil, DB) = none .

  eq getClassSet(MN, DB)
    = (getClassSetAux(getImports(getTopModule(MN, DB)), DB) ;
       getClassNames(getClasses(getTopModule(MN, DB)))) .

  eq getClassSetAux(((including MN .) IL), DB)
    = (getClassSet(MN, DB) ; getClassSetAux(IL, DB)) .
  eq getClassSetAux(((extending MN .) IL), DB)
    = (getClassSet(MN, DB) ; getClassSetAux(IL, DB)) .
  eq getClassSetAux(((protecting MN .) IL), DB)
    = (getClassSet(MN, DB) ; getClassSetAux(IL, DB)) .
  eq getClassSetAux(nil, DB) = none .

*** As pointed out in Section~\ref{parameterized-modules}, in a parameterized
*** module all occurrences of sorts or classes coming from the parameter
*** theories have to be qualified. \texttt{createCopy} is the function used
*** for creating these renamed copies of the parameters. As also explained in
*** Section~\ref{parameterized-modules}, if a parameter theory is structured,
*** the renaming is carried out not only at the top level, but for the entire
*** ``theory part'' in the structure.

*** The function \texttt{createCopy} calls an auxiliary function,
*** \texttt{prepPar}, which recursively proceeds through all the subtheories
*** of the given theory. For each theory in the structure, the required set of
*** maps is generated and applied to such a theory using the
*** \texttt{applyMapsToModule} function discussed in
*** Section~\ref{applyMapsToModule}, which is then evaluated and entered into
*** the database. Note that the renamings to which a theory is subjected must
*** also be applied to the theories importing it. The new database and the
*** renaming maps applied to the theory will have to be returned by the
*** function.

*** The function \texttt{prepPar} makes a copy of the theory specified by the
*** name given as first argument and of all its subtheories (only theories, no
*** modules), and qualifies all the sorts appearing in it with the label given
*** in the declaration of the parameter, which is given as second argument.

  pr SET{Tuple{ViewExpression,ViewExpression}}
       * (op `(_`,_`) : ViewExpression ViewExpression
            -> Tuple{ViewExpression,ViewExpression} to <_;_>,
          op p1_ : Tuple{ViewExpression,ViewExpression} -> ViewExpression to 1st,
          op p2_ : Tuple{ViewExpression,ViewExpression} -> ViewExpression to 2nd,
          op empty : -> Set{Tuple{ViewExpression,ViewExpression}} to none,
          op _,_ : Set{Tuple{ViewExpression,ViewExpression}}
                   Set{Tuple{ViewExpression,ViewExpression}} ->
                   Set{Tuple{ViewExpression,ViewExpression}} to __) .

  vars VEPS VEPS' : Set{Tuple{ViewExpression,ViewExpression}} .

----  eq 1st(< VE ; VE' >) = VE .
----  eq 2nd(< VE ; VE' >) = VE' .

  op prepPar : Qid Qid ModuleExpression Database -> PrepParResult .
  op prepParImports : ImportList ImportList Qid Qid SortMappingSet OpMappingSet
        StratMappingSet Set{Tuple{ViewExpression,ViewExpression}} ParameterDeclList
        Database -> PrepParResult .

  pr 9TUPLE{SortMappingSet, OpMappingSet, StratMappingSet, Database, ViewExpression,
            ViewExpression, Set{Tuple{ViewExpression,ViewExpression}}, Bool,
            ImportList}
       * (sort Tuple{SortMappingSet, OpMappingSet, StratMappingSet, Database,
                     ViewExpression, ViewExpression,
                     Set{Tuple{ViewExpression,ViewExpression}}, Bool, ImportList}
                     to PrepParResult,
          op ((_,_,_,_,_,_,_,_,_)) to <_;_;_;_;_;_;_;_;_>,
          op p1_ to sortMappingSet,
          op p2_ to opMappingSet,
          op p3_ to stratMappingSet,
          op p4_ to database,
          op p5_ to sourceViewExpression,
          op p6_ to targetViewExpression,
          op p7_ to viewExpPairSet,
          op p8_ to theoryFlag,
          op p9_ to getImports) .
---(
  op <_;_;_;_;_;_;_;_> : SortMappingSet OpMappingSet Database ViewExpression ViewExpression Set{Tuple{ViewExpression,ViewExpression}} Bool ImportList -> PrepParResult .
  op sortMappingSet : PrepParResult -> SortMappingSet .
  op opMappingSet : PrepParResult -> OpMappingSet .
  op database : PrepParResult -> Database .
  op sourceViewExpression : PrepParResult -> ViewExpression .
  op targetViewExpression : PrepParResult -> ViewExpression .
  op viewExpPairSet : PrepParResult -> Set{Tuple{ViewExpression,ViewExpression}} .
  op theoryFlag : PrepParResult -> Bool .
  op getImports : PrepParResult -> ImportList .
  eq opMappingSet(< SMS ; OMS ; DB ; VE ; VE' ; VEPS ; B ; IL >) = OMS .
  eq sortMappingSet(< SMS ; OMS ; DB ; VE ; VE' ; VEPS ; B ; IL >) = SMS .
  eq database(< SMS ; OMS ; DB ; VE ; VE' ; VEPS ; B ; IL >) = DB .
  eq sourceViewExpression(< SMS ; OMS ; DB ; VE ; VE' ; VEPS ; B ; IL >) = VE .
  eq targetViewExpression(< SMS ; OMS ; DB ; VE ; VE' ; VEPS ; B ; IL >) = VE' .
  eq viewExpPairSet(< SMS ; OMS ; DB ; VE ; VE' ; VEPS ; B ; IL >) = VEPS .
  eq theoryFlag(< SMS ; OMS ; DB ; VE ; VE' ; VEPS ; B ; IL >) = B .
  eq getImports(< SMS ; OMS ; DB ; VE ; VE' ; VEPS ; B ; IL >) = IL .
---)

  ----op createCopy : ParameterDecl Database -> Database .
  op prepPar : Qid ModuleExpression Database  -> PrepParResult .
  op prepParImports : ImportList ImportList Qid SortMappingSet OpMappingSet
        StratMappingSet Set{Tuple{ViewExpression,ViewExpression}} ParameterDeclList
        Database -> PrepParResult .

  eq createCopy(X :: ME, DB)
    = if unitInDb(pd(X :: ME), DB)
      then DB
      else database(prepPar(X, ME, database(evalModExp(ME, DB))))
      fi .

  ceq prepPar(X, ME, DB)
    = < SMS' ;
        OMS ;
        TMS ;
        (if unitInDb(pd(X :: ME), DB)
         then DB
         else evalModule(
                setImports(
                  setName(
                    applyMapsToModule(maps2rens(SMS'), maps2rens(OMS), Th, getFlatModule(ME, DB)),
                    pd(X :: ME)),
                  IL),
                applyMapsToVars(maps2rens(SMS'), maps2rens(OMS), getVars(ME, DB)),
                DB')
         fi) ;
        mtViewExpression ; mtViewExpression ; none ; true ; nil >
    if Th := getTopModule(ME, DB)
       /\ < SMS ; OMS ; TMS ; DB' ; VE ; VE' ; VEPS ; B ; IL >
            := prepParImports(getImports(Th), nil, X,
                 none, none, none, none, X :: ME, DB)
       /\ SMS' := (SMS
                   sortMapsPar(X, getSorts(Th), none)
                   classMapsPar(X, classSet(getClasses(Th)), none)) .
  eq prepPar(X, ME, DB)
    = < none ; none ; none ; warning(DB, '\r 'Error: '\o 'Incorrect 'parameter '\n) ;
        mtViewExpression ; mtViewExpression ; none ; false ; nil >
      [owise] .

  ceq prepParImports(((including ME .) IL), IL', X, SMS, OMS, TMS, VEPS, PDL, DB)
    = if B
      then prepParImports(IL, (IL' (including pd(X :: ME') .)), X,
             (SMS SMS'), (OMS OMS'), (TMS TMS'), VEPS, PDL, DB')
      else prepParImports(IL, (IL' (including ME .)), X,
             SMS, OMS, TMS, VEPS, PDL, DB)
      fi
    if ME' := prepModExp(ME, VEPS)
    /\ < SMS' ; OMS' ; TMS' ; DB' ; VE ; VE' ; VEPS' ; B ; IL'' >
         := prepPar(X, ME', database(evalModExp(ME', PDL, DB))) .
  ceq prepParImports(((extending ME .) IL), IL', X, SMS, OMS, TMS, VEPS, PDL, DB)
    = if B
      then *** A theory shouldn't be imported in protecting mode
           prepParImports(IL, (IL' (extending pd(X :: ME') .)), X,
             (SMS SMS'), (OMS OMS'), (TMS TMS'), VEPS, PDL, DB')
      else prepParImports(IL, (IL' (extending ME .)), X,
             SMS, OMS, TMS, VEPS, PDL, DB)
      fi
    if ME' := prepModExp(ME, VEPS)
    /\ < SMS' ; OMS' ; TMS' ; DB' ; VE ; VE' ; VEPS' ; B ; IL'' >
         := prepPar(X, ME', database(evalModExp(ME', PDL, DB))) .
  ceq prepParImports(((protecting ME .) IL), IL', X, SMS, OMS, TMS, VEPS, PDL, DB)
    = if B
      then *** A theory shouldn't be imported in protecting mode
           prepParImports(IL, (IL' (protecting pd(X :: ME') .)), X,
              (SMS SMS'), (OMS OMS'), (TMS TMS'), VEPS, PDL, DB')
      else prepParImports(IL, (IL' (protecting ME .)), X,
              SMS, OMS, TMS, VEPS, PDL, DB)
      fi
    if ME' := prepModExp(ME, VEPS)
    /\ < SMS' ; OMS' ; TMS' ; DB' ; VE ; VE' ; VEPS' ; B ; IL'' >
         := prepPar(X, ME', database(evalModExp(ME', PDL, DB))) .
  ceq prepParImports(((including pd(X :: ME) .) IL), IL', Y,
        SMS, OMS, TMS, (< X ; Z > VEPS), PDL, DB)
    = prepParImports(IL, (IL' (including pd(Z :: ME') .)), Y,
        (SMS SMS'), (OMS OMS'), (TMS TMS'), (< X ; Z > VEPS), PDL, DB')
    if ME' := prepModExp(ME, VEPS)
    /\ < SMS' ; OMS' ; TMS' ; DB' ; VE ; VE' ; VEPS' ; B ; IL'' >
         := prepPar(X, ME', database(evalModExp(ME', PDL, DB))) .
  ceq prepParImports(((extending pd(X :: ME) .) IL), IL', Y,
        SMS, OMS, TMS, (< X ; Z > VEPS), PDL, DB)
    = prepParImports(IL, (IL' (extending pd(Z :: ME') .)), Y,
        (SMS SMS'), (OMS OMS'), (TMS TMS'), (< X ; Z > VEPS), PDL, DB')
    if ME' := prepModExp(ME, VEPS)
    /\ < SMS' ; OMS' ; TMS' ; DB' ; VE ; VE' ; VEPS' ; B ; IL'' >
         := prepPar(X, ME', database(evalModExp(ME', PDL, DB))) .
  ceq prepParImports(((protecting pd(X :: ME) .) IL), IL', Y,
        SMS, OMS, TMS, (< X ; Z > VEPS), PDL, DB)
    = prepParImports(IL, (IL' (protecting pd(Z :: ME') .)), Y,
        (SMS SMS'), (OMS OMS'), (TMS TMS'), (< X ; Z > VEPS), PDL, DB')
    if ME' := prepModExp(ME, VEPS)
    /\ < SMS' ; OMS' ; TMS' ; DB' ; VE ; VE' ; VEPS' ; B ; IL'' >
         := prepPar(X, ME', database(evalModExp(ME', PDL, DB))) .
  eq prepParImports(nil, IL, X, SMS, OMS, TMS, VEPS, PDL, DB)
    = < SMS ; OMS ; TMS ; DB ; mtViewExpression ; mtViewExpression ; none ;
        false ; IL > .

  ceq prepPar(X, Y, ME, DB)
    = (< SMS' ; OMS ; TMS ;
        (if unitInDb(pd(Y :: ME), DB)
         then DB
         else evalModule(
                setImports(
                  setName(
                    applyMapsToModule(maps2rens(SMS'), maps2rens(OMS), getTopModule(pd(X :: ME), DB), getFlatModule(pd(X :: ME), DB)),
                    pd(Y :: ME)),
                  IL),
                applyMapsToVars(maps2rens(SMS'), maps2rens(OMS), getVars(pd(X :: ME), DB)),
                DB')
         fi) ;
        X ; Y ; < X ; Y > ; true ; nil >)
    if Th := getTopModule(ME, DB)
    /\ (< SMS ; OMS ; TMS ; DB' ; VE ; VE' ; VEPS ; B ; IL >)
          := prepParImports(getImports(Th), nil, X, Y, none, none, none,
               < X ; Y >, X :: ME, DB)
    /\ SMS' := (SMS
                genMapsQualSorts(X, Y, getSorts(Th), none)
                genMapsQualClasses(X, Y, classSet(getClasses(Th)), none)) .

  eq prepParImports(((including ME .) IL), IL', X, Y, SMS, OMS, TMS, VEPS, PDL, DB)
    = prepParImports(IL, (IL' including ME .), X, Y, SMS, OMS, TMS, VEPS, PDL, DB) .
  eq prepParImports(((extending ME .) IL), IL', X, Y, SMS, OMS, TMS, VEPS, PDL, DB)
    = prepParImports(IL, (IL' extending ME .), X, Y, SMS, OMS, TMS, VEPS, PDL, DB) .
  eq prepParImports(((protecting ME .) IL), IL', X, Y, SMS, OMS, TMS, VEPS, PDL, DB)
    = prepParImports(IL, (IL' protecting ME .), X, Y, SMS, OMS, TMS, VEPS, PDL, DB) .
  ceq prepParImports(including pd(X :: ME) . IL, IL', Y, Z, SMS, OMS, TMS, VEPS, PDL, DB)
    = prepParImports(IL, IL' including pd(X :: ME') ., Y, Z,
        (SMS SMS'), (OMS OMS'), (TMS TMS'), VEPS, PDL, DB')
    if ME' := prepModExp(ME, VEPS)
    /\ < SMS' ; OMS' ; TMS' ; DB' ; VE ; VE' ; VEPS' ; B ; IL'' >
         := prepPar(Y, Z, ME', database(evalModExp(ME', PDL, DB))) .
  ceq prepParImports(extending pd(X :: ME) . IL, IL', Y, Z, SMS, OMS, TMS, VEPS, PDL, DB)
    = prepParImports(IL, IL' extending pd(X :: ME') ., Y, Z,
        (SMS SMS'), (OMS OMS'), (TMS TMS'), VEPS, PDL, DB')
    if ME' := prepModExp(ME, VEPS)
    /\ < SMS' ; OMS' ; TMS' ; DB' ; VE ; VE' ; VEPS' ; B ; IL'' >
         := prepPar(Y, Z, ME', database(evalModExp(ME', PDL, DB))) .
  ceq prepParImports(protecting pd(X :: ME) . IL, IL', Y, Z,
        SMS, OMS, TMS, VEPS, PDL, DB)
    = prepParImports(IL, IL' protecting pd(X :: ME') ., Y, Z,
        (SMS SMS'), (OMS OMS'), (TMS TMS'), VEPS, PDL, DB')
    if ME' := prepModExp(ME, VEPS)
    /\ < SMS' ; OMS' ; TMS' ; DB' ; VE ; VE' ; VEPS' ; B ; IL'' >
         := prepPar(Y, Z, ME', database(evalModExp(ME', PDL, DB))) .
  eq prepParImports(nil, IL, X, Y, SMS, OMS, TMS, VEPS, PDL, DB)
    = < SMS ; OMS ; TMS ; DB ; mtViewExpression ; mtViewExpression ; none ; false ; IL > .

  op sortMapsPar : Qid SortSet Set{Tuple{ViewExpression,ViewExpression}} -> SortMappingSet .
  op classMapsPar : Qid SortSet Set{Tuple{ViewExpression,ViewExpression}} -> SortMappingSet .

  op qualify : Qid Sort -> Sort .
  op qualify : Qid Sort Set{Tuple{ViewExpression,ViewExpression}} -> Sort .
  op qualify : Qid Sort ParameterList ParameterList Set{Tuple{ViewExpression,ViewExpression}} -> Sort .

  eq qualify(X, S) = qualify(X, getName(S), getPars(S), empty, none) .

  eq qualify(X, S, VEPS) = qualify(X, getName(S), getPars(S), empty, VEPS) .

  eq qualify(X, S, (P, PL), PL', < P ; P' > VEPS)
    = qualify(X, S, PL, PL' P', < P ; P' > VEPS) .
  eq qualify(X, S, (P, PL), PL', VEPS)
    = qualify(X, S, PL, PL' P, VEPS)
    [owise] .
  eq qualify(X, S, empty, PL, VEPS)
    = qid(string(X) + "$" + string(makeSort(S, PL))) .

  eq sortMapsPar(X, (S ; SS), VEPS)
    = (sort S to qualify(X, S, VEPS) . sortMapsPar(X, SS, VEPS)) .
  eq sortMapsPar(X, none, VEPS) = none .

  eq classMapsPar(X, (S ; SS), VEPS)
    = (class S to qualify(X, S, VEPS) . classMapsPar(X, SS, VEPS)) .
  eq classMapsPar(X, none, VEPS) = none .

*** When one of the labels of the interface of a module is being used in a
*** module expression to instantiate some formal parameter of a module, then,
*** in the evaluation of such module expression the qualification of all sorts
*** and class names coming from the theory part of the parameter theory have
*** to be changed according to such a label. In the evaluation of an
*** instantiation module expression this is done by generating the
*** corresponding renaming maps, which are then applied to the module being
*** instantiated. Given labels \texttt{L} and \texttt{L'}, for each sort or
*** class name \texttt{S} in the set given as argument, a map of the form
*** \verb~L$S to L'$S~ is generated.

  op genMapsQualSorts : Qid Qid SortSet Set{Tuple{ViewExpression,ViewExpression}} -> SortMappingSet .
  op genMapsQualClasses : Qid Qid SortSet Set{Tuple{ViewExpression,ViewExpression}} -> SortMappingSet .

  eq genMapsQualSorts(X, Y, (S ; SS), VEPS)
    = (sort qualify(X, S, VEPS) to qualify(Y, S, VEPS) .
       genMapsQualSorts(X, Y, SS, VEPS)) .
  eq genMapsQualSorts(X, Y, none, VEPS) = none .

  eq genMapsQualClasses(X, Y, (S ; SS), VEPS)
    = (class qualify(X, S, VEPS) to qualify(Y, S, VEPS) .
       genMapsQualClasses(X, Y, SS, VEPS)) .
  eq genMapsQualClasses(X, Y, none, VEPS) = none .

*** The function \texttt{prepare} takes the map set of a view and
*** prepares it to be used in an instantiation by transforming sort and class
*** names into their qualified form, if required (sorts and class names in a
*** view have to be qualified only if they were defined in a theory).

*** The \texttt{prepare} function takes six arguments: The sets of maps
*** to be prepared, the label with which the sorts to be renamed have to be
*** qualified, the set of sorts in the theory part of the source of the view,
*** and the set of sorts and class names in the theory part of the target of
*** the view.

*** Note that we assume that there is a sort map and a class map for each sort
*** and class in the theory part of the source of the view. Therefore, sorts
*** and class names appearing as sources of sort and class maps are
*** systematically qualified. The sorts or class names used in the targets of
*** the maps will be qualified only if they were declared in a theory. In maps
*** for operators in which the arity and coarity are specified, or for those
*** going to derived terms, the sorts appearing in the arity or coarity of an
*** operator and those used to qualify terms, or in sort tests in terms, must
*** also be qualified. However, in these cases the qualification cannot be
*** done on all sorts, but only on those defined in the theory parts. This is
*** the reason why the sets of sorts in the theory parts of the source and
*** target and the set of class names in the target of the view are given when
*** calling \texttt{prepare}.

  op prepare : SortMappingSet Qid SortSet SortSet SortSet -> SortMappingSet .
  op prepare : OpMappingSet Qid SortSet SortSet SortSet -> OpMappingSet .
  op prepare : StratMappingSet Qid SortSet SortSet SortSet -> StratMappingSet .

  op prepare : TypeList Qid SortSet -> TypeList .
  op prepTerm : TermList Qid SortSet -> TermList .

  eq prepare(sort S to S' . SMS, X, SS, SS', SS'')
    = (if S' in SS'
       then sort qualify(X, S) to qualify(X, S') .
       else sort qualify(X, S) to S' .
       fi
       prepare(SMS, X, SS, SS', SS'')) .
  eq prepare(class S to S' . SMS, X, SS, SS', SS'')
    = (if S' in SS''
       then (class qualify(X, S) to qualify(X, S') .)
       else (class qualify(X, S) to S' .)
       fi
       prepare(SMS, X, SS, SS', SS'')) .
  eq prepare((none).SortMappingSet, X, SS, SS', SS'') = none .

  eq prepare(op F to F' . OMS, X, SS, SS', SS'')
    = (op F to F' .
       prepare(OMS, X, SS, SS', SS'')) .
  eq prepare(op F : TyL -> Ty to F' . OMS, X, SS, SS', SS'')
    = (op F : prepare(TyL, X, SS) -> prepare(Ty, X, SS) to F' .
       prepare(OMS, X, SS, SS', SS'')) .
  eq prepare(op T to term T' . OMS, X, SS, SS', SS'')
    = (op prepTerm(T, X, SS) to term prepTerm(T', X, SS') .
       prepare(OMS, X, SS, SS', SS'')) .
  eq prepare(msg F to F' . OMS, X, SS, SS', SS'')
    = (msg F to F' .
       prepare(OMS, X, SS, SS', SS'')) .
  eq prepare(msg F : TyL -> Ty to F' . OMS, X, SS, SS', SS'')
    = (msg F : prepare(TyL, X, SS) -> prepare(Ty, X, SS) to F' .
       prepare(OMS, X, SS, SS', SS'')) .
  eq prepare(attr A . S to A' . OMS, X, SS, SS', SS'')
    = (attr A . qualify(X, S) to A' .
       prepare(OMS, X, SS, SS', SS'')) .
  eq prepare((none).OpMappingSet, X, SS, SS', SS'') = none .

  eq prepare(strat F to F' . TMS, X, SS, SS', SS'')
    = (strat F to F' .
       prepare(TMS, X, SS, SS', SS'')) .
  eq prepare(strat F : TyL @ Ty to F' . TMS, X, SS, SS', SS'')
    = (strat F : prepare(TyL, X, SS) @ prepare(Ty, X, SS) to F' .
       prepare(TMS, X, SS, SS', SS'')) .
  eq prepare((none).StratMappingSet, X, SS, SS', SS'') = none .

  eq prepare((S TyL), X, (S ; SS)) = (qualify(X, S) prepare(TyL, X, (S ; SS))) .
  eq prepare((K TyL), X, SS) = prepare((getSort(K) TyL), X, SS) .
  eq prepare((S TyL), X, SS) = (S prepare(TyL, X, SS)) [owise] .
  eq prepare(nil, X, SS) = nil .

  eq prepTerm(F[TL], X, SS) = F[prepTerm(TL, X, SS)] .
  eq prepTerm(V, X, SS)
    = if getType(V) in SS
      then qid(string(getName(V)) + ":" + string(qualify(X, getType(V))))
      else qid(string(getName(V)) + ":" + string(getType(V)))
      fi .
  eq prepTerm(Ct, X, SS)
    = if getType(Ct) in SS
      then qid(string(getName(Ct)) + "." + string(qualify(X, getType(Ct))))
      else qid(string(getName(Ct)) + "." + string(getType(Ct)))
      fi .
  ceq prepTerm((T, TL), X, SS)
    = (prepTerm(T, X, SS), prepTerm(TL, X, SS))
    if TL =/= empty .
  eq prepTerm(qidError(QIL), X, SS) = qidError(QIL) .

*** For each parameterized sort
*** $\texttt{S[L}_1\texttt{,}\ldots\texttt{,L}_n\texttt{]}$ in the
*** body of a parameterized module with
*** $\texttt{L}_1\ldots\texttt{L}_n$ the labels of the parameters in
*** the interface of the module, a map of the form 9
*** $\texttt{sort\ S[L}_1\texttt{,}\ldots\texttt{,L}_n\texttt{]\
***      to\ S[V}_1\texttt{,}\ldots\texttt{,V}_n\texttt{]}$
*** is generated, where $\texttt{V}_i$ is the name of the view associated to
*** the label $\texttt{L}_i$ in the set of pairs given as argument.

  op genMapsSorts : SortSet Set{Tuple{ViewExpression,ViewExpression}} -> SortMappingSet .
  op genMapsClasses : SortSet Set{Tuple{ViewExpression,ViewExpression}} -> SortMappingSet .

  op prepSort : Sort Set{Tuple{ViewExpression,ViewExpression}} -> Sort .
  op prepSort : Sort ParameterList ParameterList Set{Tuple{ViewExpression,ViewExpression}} -> Sort .

  eq genMapsSorts((S ; SS), VEPS)
    = (if prepSort(S, VEPS) == S
       then none
       else (sort S to prepSort(S, VEPS) .)
       fi)
      genMapsSorts(SS, VEPS) .
  eq genMapsSorts(none, VEPS) = none .

  eq genMapsClasses((S ; SS), VEPS)
    = (if prepSort(S, VEPS) == S
       then none
       else (class S to prepSort(S, VEPS) .)
       fi)
      genMapsClasses(SS, VEPS) .
  eq genMapsClasses(none, VEPS) = none .

  eq prepSort(S, VEPS) = prepSort(getName(S), empty, getPars(S), VEPS) .
  eq prepSort(Ty, VEPS) = Ty [owise] .

  eq prepSort(S, PL, P, < P ; VE > VEPS)
    = prepSort(S, (PL, VE), empty, < P ; VE > VEPS) .
  eq prepSort(S, PL, (P, PL'), < P ; VE > VEPS)
    = prepSort(S, (PL, VE), PL', < P ; VE > VEPS) .
  eq prepSort(S, PL, P, VEPS)
    = prepSort(S, (PL, prepSort(P, VEPS)), empty, VEPS)
    [owise] .
  eq prepSort(S, PL, (P, PL'), VEPS)
    = prepSort(S, (PL, prepSort(P, VEPS)), PL', VEPS)
    [owise] .
  eq prepSort(S, PL, empty, VEPS)
    = if getPars(S) == empty
      then makeSort(S, PL)
      else makeSort(prepSort(S, VEPS), PL)
      fi .

*** The function \texttt{prepImports} takes a list of importation
*** declarations and a set of pairs composed of a label and a view name, and
*** returns the list of importations resulting from changing in each of the
*** module expressions the occurrences of the labels of the interface of the
*** module being instantiated by the names of the views associated to them in
*** the list of pairs.

  op prepImports : ImportList Set{Tuple{ViewExpression,ViewExpression}} -> ImportList .

  op prepModExp :
       ModuleExpression Set{Tuple{ViewExpression,ViewExpression}} -> ModuleExpression .
  op prepModExp : ModuleExpression ViewExpression ViewExpression ViewExpression
       Set{Tuple{ViewExpression,ViewExpression}} -> ModuleExpression .
  op prepParameterDecl :
       ParameterDecl Set{Tuple{ViewExpression,ViewExpression}} -> ParameterDecl .
  op prepViewExpression : ViewExpression Set{Tuple{ViewExpression,ViewExpression}} -> ViewExpression .
  op prepViewExpression : ParameterList Set{Tuple{ViewExpression,ViewExpression}} -> ParameterList .

  eq prepImports(((including ME .) IL), VEPS)
    = (including prepModExp(ME, VEPS) .)
      prepImports(IL, VEPS) .
  eq prepImports(((including pd(PD) .) IL), VEPS)
    = (including pd(prepParameterDecl(PD, VEPS)) .)
      prepImports(IL, VEPS) .
  eq prepImports(((extending ME .) IL), VEPS)
    = (extending prepModExp(ME, VEPS) .)
      prepImports(IL, VEPS) .
  eq prepImports(((extending pd(PD) .) IL), VEPS)
    = (extending pd(prepParameterDecl(PD, VEPS)) .)
      prepImports(IL, VEPS) .
  eq prepImports(((protecting ME .) IL), VEPS)
    = (protecting prepModExp(ME, VEPS) .)
      prepImports(IL, VEPS) .
  eq prepImports(((protecting pd(PD) .) IL), VEPS)
    = (protecting pd(prepParameterDecl(PD, VEPS)) .)
      prepImports(IL, VEPS) .
  eq prepImports(nil, VEPS) = nil .

  eq prepModExp(QI, VEPS) = QI .
  eq prepModExp(ME{PL}, VEPS) = prepModExp(ME, empty, empty, PL, VEPS) .
  eq prepModExp(ME + ME', VEPS)
    = prepModExp(ME, VEPS) + prepModExp(ME', VEPS) .
  eq prepModExp(ME, VEPS) = ME [owise] .

  eq prepModExp(ME, PL, PL', (P, PL''), < P ; S > VEPS)
    = prepModExp(ME, (PL, S), PL', PL'', < P ; S > VEPS) .
  eq prepModExp(ME, PL, PL', (P, PL''), < P ; S{PL3} > VEPS)
    = prepModExp(ME, (PL, S{PL3}), PL', PL'', < P ; S{PL3} > VEPS) .
  ceq prepModExp(ME, PL, PL', (P, PL''), < P ; P' ;; VE > VEPS)
    = prepModExp(ME, (PL, P'), (PL', VE), PL'', < P ; P' ;; VE > VEPS)
    if VE =/= mtViewExpression .
  eq prepModExp(ME, PL, PL', (P, PL''), VEPS)
    = prepModExp(ME, (PL, P), PL', PL'', VEPS)
    [owise] .
  eq prepModExp(ME, PL, PL', (QI{PL''}, PL3), VEPS)
    = prepModExp(ME, (PL, prepViewExpression(QI{PL''}, VEPS)), PL', PL3, VEPS) .
  eq prepModExp(ME, PL, empty, empty, VEPS) = ME{PL} .
  eq prepModExp(ME, PL, PL', empty, VEPS) = ME{PL}{PL'} [owise] .

  eq prepParameterDecl(X :: ME, < Y ; Z > VEPS)
    = if X == Y
      then (Z :: ME)
      else prepParameterDecl(X :: ME, VEPS)
      fi .
  eq prepParameterDecl(X :: ME, none) = X :: ME .

  eq prepViewExpression(VE, < VE ; VE' > VEPS) = VE' .
  eq prepViewExpression(QI, VEPS) = QI [owise] .
  eq prepViewExpression(X{PL}, VEPS) = X{prepViewExpression(PL, VEPS)} [owise] .
  ceq prepViewExpression((VE, PL), VEPS)
    = prepViewExpression(VE, VEPS), prepViewExpression(PL, VEPS)
    if VE =/= nil /\ PL =/= nil [owise] .

*** The function \texttt{unitInst} calls the auxiliary function
*** \texttt{unitInstAux}, which proceeds recursively on each of the parameters
*** in the interface of the module being instantiated. For each view, a set of
*** maps to be applied to the module is generated, which are accumulated in
*** the third argument of the function.

*** In the base case, when there are no more parameters and no more views, the
*** maps for the parameterized sorts are also generated, and all maps are
*** then applied.

*** \texttt{unitInstAux} proceeds accumulating also the list of parameters
*** being modified, the list of importations, and a list of label-view
*** pairs (\texttt{QidTuple{ViewExpression,ViewExpression}}) associating each label in
*** the interface to the view used in the instantiation of the theory with
*** such label. This list of pairs is used to generate the set of maps of the
*** parameterized  sorts and to `prepare' the list of importations as
***  indicated above.

  pr 7TUPLE{SortMappingSet, OpMappingSet, StratMappingSet, ParameterDeclList,
       ImportList, Set{Tuple{ViewExpression,ViewExpression}}, Database}
       * (sort Tuple{SortMappingSet, OpMappingSet, StratMappingSet,
            ParameterDeclList, ImportList, Set{Tuple{ViewExpression,ViewExpression}},
            Database} to TreatParResult,
          op ((_,_,_,_,_,_,_)) to <_;_;_;_;_;_;_>,
          op p1_ to getSortMappings,
          op p2_ to getOpMappings,
          op p3_ to getStratMappings,
          op p4_ to getPars,
          op p5_ to getImports,
          op p6_ to viewExpPairSet,
          op p7_ to db) .

---(
  sort TreatParResult .

  op <_;_;_;_;_;_;_> : SortMappingSet OpMappingSet StratMappingSet ParameterDeclList
       ImportList Set{Tuple{ViewExpression,ViewExpression}} Database ->
       TreatParResult .
  op getSortMappings : TreatParResult -> SortMappingSet .
  op getOpMappings : TreatParResult -> OpMappingSet .
  op getStratMappings : TreatParResult -> StratMappingSet .
  op getPars : TreatParResult -> ParameterDeclList .
  op getImports : TreatParResult -> ImportList .
  op viewExpPairSet : TreatParResult -> Set{Tuple{ViewExpression,ViewExpression}} .
  op db : TreatParResult -> Database .

  eq getSortMappings(< SMS ; OMS ; TMS ; PDL ; IL ; VEPS ; DB >) = SMS .
  eq getOpMappings(< SMS ; OMS ; TMS ; PDL ; IL ; VEPS ; DB >) = OMS .
  eq getStratMappings(< SMS ; OMS ; TMS ; PDL ; IL ; VEPS ; DB >) = TMS .
  eq getPars(< SMS ; OMS ; TMS ; PDL ; IL ; VEPS ; DB >) = PDL .
  eq getImports(< SMS ; OMS ; TMS ; PDL ; IL ; VEPS ; DB >) = IL .
  eq viewExpPairSet(< SMS ; OMS ; TMS ; PDL ; IL ; VEPS ; DB >) = VEPS .
  eq db(< SMS ; OMS ; TMS ; PDL ; IL ; VEPS ; DB >) = DB .
---)

  op unitInstAux : Module Module VariableSet SortMappingSet OpMappingSet
        StratMappingSet ParameterDeclList ParameterDeclList ImportList
        ImportList ParameterList Set{Tuple{ViewExpression,ViewExpression}}
        ParameterDeclList Database -> Database .
  op treatPar : ParameterDecl ViewExpression
        Set{Tuple{ViewExpression,ViewExpression}} ParameterDeclList Database
        -> TreatParResult .
  op treatPar2 : ParameterDecl ViewExpression
        Set{Tuple{ViewExpression,ViewExpression}} ParameterDeclList Database
        -> TreatParResult .
  op treatParAux : Qid ModuleExpression ParameterDeclList ViewExpression Qid
        ViewExpression ViewExpression  ParameterDeclList  SortMappingSet
        OpMappingSet  ParameterDeclList ImportList
        Set{Tuple{ViewExpression,ViewExpression}}  Database -> TreatParResult .
  op treatParAux2 : Qid ModuleExpression ParameterDeclList ViewExpression Qid
        ViewExpression ViewExpression ParameterDeclList SortMappingSet OpMappingSet
        StratMappingSet ParameterDeclList ImportList
        Set{Tuple{ViewExpression,ViewExpression}} Database -> TreatParResult .

  eq unitInst(ME, PL, PDL, DB)
    = unitInstAux(setName(getTopModule(ME, DB), ME{PL}),
        signature(getFlatModule(ME, DB)), getVars(ME, DB), none, none, none,
        getPars(getTopModule(ME, DB)), nil,
        getImports(getTopModule(ME, DB)), nil, PL, none, PDL, DB) .

  ceq unitInstAux(U, M, VDS, SMS, OMS, TMS, (X :: ME, PDL), PDL', IL, IL'', (QI, PL), VEPS, PDL'', DB)
    = unitInstAux(U, M, VDS, (SMS SMS'), (OMS OMS'), (TMS TMS'),
        PDL, (PDL', PDL3), IL, (IL'' IL3), PL, (VEPS VEPS'), PDL'', DB')
    if < SMS' ; OMS' ; TMS' ; PDL3 ; IL3 ; VEPS' ; DB' >
         := treatPar(X :: ME, QI, VEPS, PDL'', DB) .
  ceq unitInstAux(U, M, VDS, SMS, OMS, TMS, (X :: ME, PDL), PDL', IL, IL'', (QI{PL}, PL'), VEPS, PDL'', DB)
    = unitInstAux(U, M, VDS, (SMS SMS'), (OMS OMS'), (TMS TMS'), PDL, (PDL', PDL3), IL, (IL'' IL3), PL', (VEPS VEPS'), PDL'', DB')
    if < SMS' ; OMS' ; TMS' ; PDL3 ; IL3 ; VEPS' ; DB' >
         := treatPar(X :: ME, QI{PL}, VEPS, PDL'', DB) .
  ceq unitInstAux(U, M, VDS, SMS, OMS, TMS, nil, PDL, IL, IL', empty, VEPS, PDL', DB)
    = evalModule(
        setImports(setPars(applyMapsToModuleAux(maps2rens(SMS'), maps2rens(OMS), maps2rens(TMS), U, M), PDL),
                   (prepImports(IL, VEPS) IL')),
        applyMapsToVars(maps2rens(SMS'), maps2rens(OMS), VDS),
        DB)
    if SMS' := (SMS
                genMapsSorts((getSorts(U) ; getSortSetAux(getImports(U), DB)), VEPS)
                genMapsClasses((getClassNames(getClasses(U)) ; getClassSetAux(getImports(U), DB)), VEPS)) .
  eq unitInstAux(unitError(QIL), UK:[Module], SDV:[VariableSet], SMS, OMS, TMS, PDL, PDL', IL, IL', PL, VEPS, PDL'', DB)
    = warning(DB, QIL) .
  eq unitInstAux(noModule, unitError(QIL), VDS, SMS, OMS, TMS, PDL, PDL', IL, IL', VE, VEPS, PDL'', DB)
    = warning(DB, QIL) .
  eq unitInstAux(U, M, VDS, SMS, OMS, TMS, (X :: ME, PDL), PDL', IL, IL', empty, VEPS, PDL'', DB)
    = warning(DB, '\r 'Error: '\o 'Incorrect 'module header2QidList(getHeader(U)) '. '\n) .
  eq unitInstAux(U, M, VDS, SMS, OMS, TMS, nil, PDL, IL, IL', (QI, VE, PL), VEPS, PDL', DB)
    = warning(DB, '\r 'Error: '\o 'Incorrect 'module header2QidList(getHeader(U)) '. '\n) .
  eq unitInstAux(U, M, VDS, SMS, OMS, TMS, PDL, PDL', IL, IL', PL, VEPS, PDL'', DB)
    = DB
    [owise] .

  eq treatParView(X :: ME, VE, ME', VEPS, PDL, DB)
    = if labelInModExp(X, ME')
      then treatPar(X :: ME, VE, VEPS, PDL, DB)
      else < none ;
             none ;
             none ;
             getPars(treatPar(X :: ME, VE, VEPS, PDL, DB)) ;
             getImports(treatPar(X :: ME, VE, VEPS, PDL, DB)) ;
             viewExpPairSet(treatPar(X :: ME, VE, VEPS, PDL, DB)) ;
             db(treatPar(X :: ME, VE, VEPS, PDL, DB)) >
      fi .

  op labelInModExp : Qid ModuleExpression -> Bool .
  op labelInViewExpression : Qid ViewExpression -> Bool .

  eq labelInModExp(X, QI) = X == QI .
  eq labelInModExp(X, ME{VE}) = labelInViewExpression(X, VE) .
  eq labelInModExp(X, TUPLE[N]) = false .
  eq labelInModExp(X, POWER[N]) = false .

  eq labelInViewExpression(X, QI) = X == QI .
  eq labelInViewExpression(X, ((VE, VE')))
    = labelInViewExpression(X, VE) or-else labelInViewExpression(X, VE') .
  eq labelInViewExpression(X, QI{VE}) = X == QI or-else labelInViewExpression(X, VE) .

  eq treatPar(X :: ME, VE, VEPS, PDL, DB)
    = if VE :: Qid and-then labelInParameterDeclList(VE, PDL)
      then < (genMapsQualSorts(X, VE, getThSorts(ME, DB), VEPS)
              genMapsQualClasses(X, VE, getThClasses(ME, DB), VEPS)) ;
             none ;
             none ;
             VE :: ME ;
             nil ;
             < X ; VE > ;
             createCopy((VE :: ME), DB) >
      else if viewInDb(VE, DB)
           then if theory(getTopModule(getTo(getView(VE, DB)), DB))
                then < prepare(
                         getSortMappings(getView(VE, DB)),
                         X,
                         getThSorts(ME, DB),
                         getThSorts(getTo(getView(VE, DB)), DB),
                         getThClasses(getTo(getView(VE, DB)), DB)) ;
                       prepare(
                         getOpMappings(getView(VE, DB)),
                         X,
                         getThSorts(ME, DB),
                         getThSorts(getTo(getView(VE, DB)), DB),
                         getThClasses(getTo(getView(VE, DB)), DB)) ;
                       none ; ---- do something with strat maps
                       X :: getTo(getView(VE, DB)) ;
                       nil ;
                       < X ; (VE ;; X) > ;
                       createCopy((X :: getTo(getView(VE, DB))), DB) >
                else < prepare(
                         getSortMappings(getView(VE, DB)),
                         X,
                         getThSorts(ME, DB), none, none) ;
                       prepare(
                         getOpMappings(getView(VE, DB)),
                         X,
                         getThSorts(ME, DB), none, none) ;
                       prepare(
                         getStratMappings(getView(VE, DB)),
                         X,
                         getThSorts(ME, DB), none, none) ;
                       getPars(getTopModule(getTo(getView(VE, DB)), DB)) ;
                       (protecting getTo(getView(VE, DB)) .) ;
                       < X ; VE > ;
                       DB >
                fi
           else < none ; none ; none ; nil ; nil ; none ;
                  warning(DB, '\r 'Error: '\o 'View VE 'not 'in 'database. '\n) >
           fi
      fi .

  op viewInstAux : View SortMappingSet OpMappingSet StratMappingSet ParameterDeclList
       ParameterDeclList ParameterList Set{Tuple{ViewExpression,ViewExpression}}
       ParameterDeclList Database -> Database .
  op treatParView : ParameterDecl ParameterList ModuleExpression
       Set{Tuple{ViewExpression,ViewExpression}} ParameterDeclList Database
       -> TreatParResult .
  op treatParAux : Qid ModuleExpression ParameterList Qid ViewExpression ViewExpression
       ParameterList SortMappingSet OpMappingSet StratMappingSet ParameterList ImportList
       Set{Tuple{ViewExpression,ViewExpression}} Database -> TreatParResult .

  eq viewInst(VE, PL, PDL, DB)
    = viewInstAux(setName(getView(VE, DB), VE{PL}),
        none, none, none, getPars(getView(VE, DB)), nil, PL, none, PDL, DB) .

  ceq viewInstAux(VI, SMS, OMS, TMS, (X :: ME, PDL), PDL', (QI, PL), VEPS, PDL'', DB)
    = viewInstAux(VI, (SMS SMS'), (OMS OMS'), (TMS TMS'), PDL, (PDL', PDL3), PL, (VEPS VEPS'), PDL'', DB')
    if < SMS' ; OMS' ; TMS' ; PDL3 ; IL ; VEPS' ; DB' >
         := treatParView(X :: ME, QI, getFrom(VI), VEPS, PDL'', DB) .
  ceq viewInstAux(VI, SMS, OMS, TMS, (X :: ME, PDL), PDL', (QI{PL}, PL'), VEPS, PDL'', DB)
    = viewInstAux(VI, SMS SMS', OMS OMS', TMS TMS', PDL, (PDL', PDL3), PL', VEPS VEPS', PDL'', DB')
    if < SMS' ; OMS' ; TMS' ; PDL3 ; IL ; VEPS' ; DB' > := treatParView(X :: ME, QI{PL}, getFrom(VI), VEPS, PDL'', DB) .
  ceq viewInstAux(VI, SMS, OMS, TMS, nil, PDL, empty, VEPS, PDL', DB)
    = insertView(
        setPars(
          setFrom(
            setTo(
              setSortMappings(
                setOpMappings(VI,
                  applyMapsToMaps(
                    maps2rens(genMapsSorts(getSortSet(getFrom(VI), DB'''), VEPS)
                              genMapsClasses(getClassSet(getFrom(VI), DB'''), VEPS)),
                    maps2rens(SMS
                              genMapsSorts(getSortSet(getTo(VI), DB'''), VEPS)
                              genMapsClasses(getClassSet(getTo(VI), DB'''), VEPS)),
                    getOpMappings(VI))),
                applyMapsToMaps(
                  maps2rens(genMapsSorts(getSortSet(getFrom(VI), DB'''), VEPS)
                            genMapsClasses(getClassSet(getFrom(VI), DB'''), VEPS)),
                  maps2rens(SMS
                            genMapsSorts(getSortSet(getTo(VI), DB'''), VEPS)
                            genMapsClasses(getClassSet(getTo(VI), DB'''), VEPS)),
                  getSortMappings(VI))),
              prepModExp(getTo(VI), VEPS)),
            prepModExp(getFrom(VI), VEPS)),
          PDL),
        DB''')
    if < DB'  ; ME'  >   := evalModExp(getFrom(VI), PDL', DB)
    /\ < DB'' ; ME'' >   := evalModExp(getTo(VI), (getPars(VI), PDL'), DB')
    /\ < DB''' ; ME''' > := evalModExp(prepModExp(getTo(VI), VEPS), (getPars(VI), PDL'), DB'') .
  eq viewInstAux(viewError(QIL), SMS, OMS, TMS, PDL0:[ParameterDeclList], PDL, PL, VEPS, PDL', DB)
    = warning(DB, QIL) .
  eq viewInstAux(VI, SMS, OMS, TMS, (X :: ME, PDL), PDL', empty, VEPS, PDL'', DB)
    = warning(DB, ('\r 'Error: '\o 'Incorrect 'view getName(VI) '. '\n)) .
  eq viewInstAux(VI, SMS, OMS, TMS, nil, PDL, (QI, PL), VEPS, PDL', DB)
    = warning(DB, ('\r 'Error: '\o 'Incorrect 'view getName(VI) '. '\n)) .
  eq viewInstAux(VI, SMS, OMS, TMS, (X :: ME, PDL), PDL', (QI{PL}, PL'), VEPS, PDL'', DB)
    = warning(DB, ('\r 'Error: '\o 'Wrong 'instantiation getName(VI) '. '\n)) .

  op applyMapsToMaps : RenamingSet RenamingSet SortMappingSet -> SortMappingSet .
  op applyMapsToMaps : RenamingSet RenamingSet OpMappingSet -> OpMappingSet .
  op applyMapsToTerm : RenamingSet TermList -> TermList .
  op applyMapsToVars : RenamingSet VariableSet -> VariableSet .

  eq applyMapsToMaps(SRS, SRS', sort S to S' . SMS)
    = (sort applyMapsToType(SRS, S) to applyMapsToType(SRS', S') .
       applyMapsToMaps(SRS, SRS', SMS)) .
  eq applyMapsToMaps(SRS, SRS', class S to S' . SMS)
    = (class applyMapsToType(SRS, S) to applyMapsToType(SRS',S') .
       applyMapsToMaps(SRS, SRS', SMS)) .
  eq applyMapsToMaps(SRS, SRS', SMS) = SMS [owise] .

  eq applyMapsToMaps(SRS, SRS', op_to`term_.(T, T') OMS)
    = (op_to`term_.(applyMapsToTerm(SRS, T), applyMapsToTerm(SRS', T'))
       applyMapsToMaps(SRS, SRS', OMS)) .
  eq applyMapsToMaps(SRS, SRS', op F : TyL -> Ty to F' . OMS)
    = (op F : applyMapsToTypeList(SRS, TyL) -> applyMapsToType(SRS, Ty) to F' .
       applyMapsToMaps(SRS, SRS', OMS)) .
  eq applyMapsToMaps(SRS, SRS', msg F : TyL -> S to F' . OMS)
    = (msg F : applyMapsToTypeList(SRS, TyL) -> applyMapsToType(SRS, S) to F' .
       applyMapsToMaps(SRS, SRS', OMS)) .
  eq applyMapsToMaps(SRS, SRS', attr A . S to A' . OMS)
    = (attr A . applyMapsToType(SRS, S) to A' .
       applyMapsToMaps(SRS, SRS', OMS)) .
  eq applyMapsToMaps(SRS, SRS', OMS) = OMS [owise] .

  eq applyMapsToVars(SRS, V ; VDS)
    = qid(string(getName(V)) + ":" + string(applyMapsToType(SRS, getType(V)))) ;
      applyMapsToVars(SRS, VDS).
  eq applyMapsToVars(SRS, none) = none .

  eq applyMapsToTerm(SRS, Ct)
    = qid(string(getName(Ct)) + "." + string(applyMapsToType(SRS, getType(Ct)))) .
  eq applyMapsToTerm(SRS, V)
    = qid(string(getName(V)) + "." + string(applyMapsToType(SRS, getType(V)))) .
  eq applyMapsToTerm(SRS, qidError(QIL)) = qidError(QIL) .
  ceq applyMapsToTerm(SRS, F[TL])
    = F[applyMapsToTerm(SRS, TL)]
    if (F =/= '<_:_|_>) and (F =/= '<_:_|`>) .
  eq applyMapsToTerm(SRS, '<_:_|_>[O, Ct, T])
    = '<_:_|_>[applyMapsToTerm(SRS, O),
               qid(string(applyMapsToClassName(SRS, getName(Ct)))
                   + "." + string(applyMapsToClassName(SRS, getType(Ct)))),
               applyMapsToTerm(SRS, T)] .
  ceq applyMapsToTerm(SRS, '<_:_|_>[O, C, T])
    = '<_:_|_>[applyMapsToTerm(SRS, O),
               applyMapsToClassName(SRS, C),
               applyMapsToTerm(SRS, T)]
    if not C :: Constant .
  eq applyMapsToTerm(SRS, '<_:_|`>[O, Ct])
    = '<_:_|_>[applyMapsToTerm(SRS, O),
               qid(string(applyMapsToClassName(SRS, getName(Ct)))
                   + "." + string(applyMapsToClassName(SRS, getType(Ct)))),
               'none.AttributeSet] .
  ceq applyMapsToTerm(SRS, '<_:_|`>[O, C])
    = '<_:_|_>[applyMapsToTerm(SRS, O),
               applyMapsToClassName(SRS, C),
               'none.AttributeSet]
    if not C :: Constant .

  ceq applyMapsToTerm(SRS, (T, TL))
    = (applyMapsToTerm(SRS, T), applyMapsToTerm(SRS, TL))
    if TL =/= empty .

*** As pointed out in Section~\ref{module-names}, for each new module
*** expression constructor being introduced, we need to add equations for the
*** operator \texttt{header2Qid}. Since the function to transform view
*** expressions into lists of quoted identifiers was already defined in
*** Section~\ref{VIEW-EXPR}, we just need to add the following equation.

  eq header2Qid((ME { PL }))
    = qidList2Qid(header2Qid(ME) '`{ parameterList2Qid(PL) '`}) .
  ceq header2QidList((ME { PL }))
    = (if QI == '\s then QIL else QIL QI fi
       '`{ parameterList2QidList(PL) '`} '\s)
    if QIL QI := header2QidList(ME) .

*** Given a module expression of the form \verb~ME{VE}~ such that
*** \texttt{ME} is in the database, we need to add \verb~ME{VE}~ to the set
*** of names of the modules depending on \texttt{ME} and on \texttt{VE}.
*** Since \texttt{VE} may be a composed view expression, we have to add the
*** name of the module  to each of the views in it. In this way, if \texttt{ME}
*** or any of the  views in \texttt{VE} is redefined or removed from the
*** database,  \verb~ME{VE}~ will be removed as well.

  eq setUpModExpDeps(ME{PL},
      db(< ME ; DT ; U ; U' ; M ; VDS ; MNS ; VES > MIS, MNS',
          VIS, VES', MNS'', MNS3, MNS4, QIL))
    = viewExpDeps(ME{PL}, PL,
        db(< ME ; DT ; U ; U' ; M ; VDS ; (MNS . ME{PL}) ; VES > MIS,
           MNS', VIS, VES', MNS'', MNS3, MNS4, QIL)) .
  eq setUpModExpDeps(ME{PL},
      db(< ME ; DM ; U ; U' ; M ; VDS ; MNS ; VES > MIS, MNS',
         VIS, VES', MNS'', MNS3, MNS4, QIL))
    = viewExpDeps(ME{PL}, PL,
        db(< ME ; DM ; U ; U' ; M ; VDS ; (MNS . ME{PL}) ; VES > MIS,
           MNS', VIS, VES', MNS'', MNS3, MNS4, QIL)) .
  eq setUpModExpDeps('META-LEVEL{PL}, DB)
    = setUpModExpDeps('META-LEVEL{PL}, PL, DB) .
  eq setUpModExpDeps('META-LEVEL{QI},
       db(< QI ; DT ; U ; U' ; M ; VDS ; MNS ; VES > MIS, MNS',
          VIS, VES', MNS'', MNS3, MNS4, QIL))
    = db(< QI ; DT ; U ; U' ; M ; VDS ; MNS . 'META-LEVEL{QI} ; VES >
          MIS, MNS', VIS, VES', MNS'', MNS3, MNS4, QIL) .
  eq setUpModExpDeps('META-LEVEL{QI},
       db(< QI ; DM ; U ; U' ; M ; VDS ; MNS ; VES > MIS, MNS',
          VIS, VES', MNS'', MNS3, MNS4, QIL))
    = db(< QI ; DM ; U ; U' ; M ; VDS ; MNS . 'META-LEVEL{QI} ; VES >
          MIS, MNS', VIS, VES', MNS'', MNS3, MNS4, QIL) .
  ceq setUpModExpDeps(ME{PL}, DB)
    = warning(DB, ('\r 'Error: '\o 'Module header2QidList(ME) 'not 'in 'database. '\n))
    if (ME =/= 'META-LEVEL) /\ (not unitInDb(ME, DB)) .

  eq setUpModExpDeps('META-LEVEL{PL}, (QI, PL'),
       db(< QI ; DT ; U ; U' ; M ; VDS ; MNS ; VES > MIS, MNS',
          VIS, VES', MNS'', MNS3, MNS4, QIL))
    = setUpModExpDeps('META-LEVEL{PL}, PL',
        db(< QI ; DT ; U ; U' ; M ; VDS ; MNS . 'META-LEVEL{PL} ; VES >
           MIS, MNS', VIS, VES', MNS'', MNS3, MNS4, QIL)) .
  eq setUpModExpDeps('META-LEVEL{PL}, (QI, PL'),
       db(< QI ; DM ; U ; U' ; M ; VDS ; MNS ; VES > MIS, MNS',
          VIS, VES', MNS'', MNS3, MNS4, QIL))
    = setUpModExpDeps('META-LEVEL{PL}, PL',
        db(< QI ; DM ; U ; U' ; M ; VDS ; MNS . 'META-LEVEL{PL} ; VES >
           MIS, MNS', VIS, VES', MNS'', MNS3, MNS4, QIL)) .
  eq setUpModExpDeps('META-LEVEL{PL}, nil, DB) = DB .

  op viewExpDeps : Header ViewExpression Database -> Database .

----  eq viewExpDeps(ME, VE,
----        db(MIS, MNS,
----           < VE ; DT ; VI ; MNS' ; VES > VIS, VES',
----           MNS'', MNS3, MNS4, QIL))
----    = db(MIS, MNS, < VE ; DT ; VI ; MNS' . ME ; VES > VIS, VES',
----         MNS'', MNS3, MNS4, QIL) .
  eq viewExpDeps(ME, (VE, PL),
        db(MIS, MNS,
           < VE ; DT ; VI ; MNS' ; VES > VIS, VES',
           MNS'', MNS3, MNS4, QIL))
    = viewExpDeps(ME, PL,
        db(MIS, MNS,
           < VE ; DT ; VI ; MNS' . ME ; VES > VIS, VES',
           MNS'', MNS3, MNS4, QIL)) .
----  eq viewExpDeps(ME, VE, DB) = DB [owise] .
  eq viewExpDeps(ME, (VE, PL), DB) = viewExpDeps(ME, PL, DB) [owise] .
  eq viewExpDeps(ME, empty, DB) = DB .

endfm

*******************************************************************************

***
*** 6.10 Renaming of Modules
***

*** In addition to the declaration of the constructor for renaming module
*** expressions, the following module \texttt{RENAMING-EXPR-EVALUATION}
*** introduces equations to treat this new case in the definition of functions
*** \texttt{evalModExp}, \texttt{header2QidList}, \texttt{prepHeader}, and
*** \texttt{setUpModuleDeps}.

*** A renaming expression is evaluated by applying the renaming maps, not only
*** to the top unit, but also to the part of the structure \emph{affected} by
*** the maps. The renaming process propagates downwards in the unit hierarchy
*** while the units in the structure are affected by the renamings. We say that
*** a unit is affected by a set of maps (checked by the \texttt{modAffd}
*** function) when any of the maps is applicable to any of the declarations in
*** the unit, or in any of its subunits. The application of a set of maps to a
*** single unit is accomplished by the \texttt{applyMapsToModule} function,
*** discussed in Section~\ref{applyMapsToModule}.

fmod FM-RENAMING-EXPR-EVALUATION is
  pr DATABASE .
  pr FM-RENAMING-SET-APPL-ON-UNIT .
  pr FM-EVALUATION .
  inc MOD-EXPR .
  pr MOD-EXPR-EVAL .
  pr FM-INST-EXPR-EVALUATION .
  pr FM-FMAP .

  vars ME ME' : ModuleExpression .
  var  MNS MNS' MNS'' MNS3 MNS4 : Set{ModuleName} .
  vars MIS MIS' : Set{ModuleInfo} .
  var  VIS : Set{ViewInfo} .
  vars M M' : Module .
  vars PU U U' DM : Module .
  vars DB DB' : Database .
  var  QIL : QidList .
  vars VES VES' : Set{ViewExpression} .
  var  PL : ParameterList .
  var  PDL : ParameterDeclList .
  vars PDS PDS' : Set{ParameterDecl} .
  var  I : Import .
  vars IL IL' : ImportList .
  var  R : Renaming .
  vars RS RS' RS'' RS3 SRS ORS TRS : RenamingSet .
  var  VEPS : Set{Tuple{ViewExpression,ViewExpression}} .
  vars X QI QI' QI'' F F' F'' L L' L'' A A' A'' : Qid .
  vars S S' S'' C C' C'' : Sort .
  var  K : Kind .
  vars SS : SortSet .
  vars TyL TyL' : TypeList .
  vars Ty Ty' : Type .
  vars T T' T'' T3 : Term .
  var  DT : Default{Term} .
  var  TL : TermList .
  var  OPD : OpDeclSet .
  var  OPDS : OpDeclSet .
  var  VDS : VariableSet .
  vars AtS AtS' : AttrSet .
  var  Rl : Rule .
  var  RlS : RuleSet .
  var  CD : ClassDecl .
  var  CDS : ClassDeclSet .
  var  ADS : AttrDeclSet .
  var  MD : MsgDecl .
  var  MDS : MsgDeclSet .
  var  N : Nat .
  var  NL : IntList .
  var  Hk : Hook .
  var  HkL : HookList .
  var  B : Bool .
  var  St : String .
  var  StratDcls : StratDeclSet .

*** The function \texttt{crtCopyRen} creates a copy of the part of the
*** structure of the specified module which is affected by the renaming,
*** applying to each of the generated modules in the new structure the subset
*** of maps affecting each one of them. The equation extending the
*** \texttt{evalModExp} function to the renaming module expression is then
*** reduced to a call to \texttt{crtCopyRen} with the appropriate
*** arguments.

  eq labelInModExp(X, ME * (RS)) = labelInModExp(X, ME) .

  op crtCopyRen : ModuleExpression RenamingSet Database -> Database .

  ceq evalModExp(ME * (RS), PDL, DB)
    = if unitInDb(ME' * (RS''), DB')
      then < DB' ; ME' * (RS'') >
      else < crtCopyRen(ME', RS', DB') ; ME' * (RS'') >
      fi
    if < DB' ; ME' > := evalModExp(ME, PDL, DB)
       /\ RS' := fixMaps(RS, ME', DB')
       /\ RS'' := canMaps(RS', getFlatModule(ME', DB')) .

  eq crtCopyRen(ME, none, DB) = DB .
  ceq crtCopyRen(ME, RS, DB)
    = if unitInDb(_*`(_`)(ME, RS'), DB)
      then DB
      else applyMapsRec(
             RS,
             getImports(getTopModule(ME, DB)),
             nil,
             setName(
               applyMapsToModuleAux(SRS, ORS, TRS,
                 getTopModule(ME, DB), getFlatModule(ME, DB)),
               _*`(_`)(ME, RS')),
             applyMapsToVars(SRS, ORS, getVars(ME, DB)),
             DB)
      fi
    if RS' := canMaps(RS, getFlatModule(ME, DB))
       /\ < SRS ; ORS ; TRS > := splitMaps(RS') .

  op canMaps : RenamingSet Module -> RenamingSet .
  eq canMaps(op F : TyL -> Ty to F' [AtS], M)
    = op F : canKinds(TyL, M) -> canKinds(Ty, M) to F' [AtS] .
  eq canMaps((op F : TyL -> Ty to F' [AtS], RS), M)
    = (op F : canKinds(TyL, M) -> canKinds(Ty, M) to F' [AtS],
       canMaps(RS, M)) .
  eq canMaps(msg F : TyL -> Ty to F', M)
    = msg F : canKinds(TyL, M) -> canKinds(Ty, M) to F' .
  eq canMaps((msg F : TyL -> Ty to F', RS), M)
    = (msg F : canKinds(TyL, M) -> canKinds(Ty, M) to F',
       canMaps(RS, M)) .
  eq canMaps(strat F : TyL @ Ty to F', M)
    = strat F : canKinds(TyL, M) @ canKinds(Ty, M) to F' .
  eq canMaps((strat F : TyL @ Ty to F', RS), M)
    = (strat F : canKinds(TyL, M) @ canKinds(Ty, M) to F',
       canMaps(RS, M)) .
  eq canMaps(R:Renaming, M) = R:Renaming [owise] .
  eq canMaps((R:Renaming, RS), M)
    = (R:Renaming, canMaps(RS, M))
    [owise] .
  eq canMaps(none, M) = none .

  op canKinds : TypeList Module -> [TypeList] .
  ---- eq canKinds(K:Kind TyL, M)
  ----   = kind(maximalSorts(M, K:Kind)) canKinds(TyL, M) .
  eq canKinds(nil, M) = nil .
  eq canKinds(cc(S ; SS) TyL, M)
    = kind(maximalSorts(M, getKind(M, S))) canKinds(TyL, M) .
  ----eq canKinds(TyL, M) = nil [owise] .

*** We proceed downwards while the set of maps affects the module, but we do so
*** restricting the set of maps to the subset affecting the module. Since
*** operator and message maps in which arity and coarity are specified must be
*** applied to the whole subsort-overloaded family of operators or messages, we
*** have to carry along the signature of the module at the top to make all the
*** calls to the engine. Note that we may have maps of operations or messages
*** with the domain given by sorts that are not in the submodules but which
*** have other sorts in the submodules in the same connected components.

  op applyMapsRec : RenamingSet ImportList ImportList Module VariableSet Database -> Database .

  eq applyMapsRec(RS, ((including ME .) IL), IL', U, VDS, DB)
   = applyMapsRec(
       RS, IL,
       including ME *( canMaps(fixMaps(RS, ME, DB),
                               getFlatModule(ME, DB)) ) . IL',
       U, VDS,
       crtCopyRen(ME, fixMaps(RS, ME, DB), DB)) .
  eq applyMapsRec(RS, ((extending ME .) IL), IL', U, VDS, DB)
   = applyMapsRec(
       RS, IL,
       extending ME *( canMaps(fixMaps(RS, ME, DB),
                               getFlatModule(ME, DB)) ) . IL',
       U, VDS,
       crtCopyRen(ME, fixMaps(RS, ME, DB), DB)) .
  eq applyMapsRec(RS, ((protecting ME .) IL), IL', U, VDS, DB)
   = applyMapsRec(
       RS, IL,
       protecting ME *( canMaps(fixMaps(RS, ME, DB),
                               getFlatModule(ME, DB)) ) . IL',
       U, VDS,
       crtCopyRen(ME, fixMaps(RS, ME, DB), DB)) .
  eq applyMapsRec(RS, (I IL), IL', U, VDS, DB)
    = applyMapsRec(RS, IL, (I IL'), U, VDS, DB)
    [owise] .
  eq applyMapsRec(RS, nil, IL, U, VDS, DB)
    = evalModule(setImports(U, IL), VDS, DB) .
  eq applyMapsRec(RS, IL, IL', unitError(QIL), VDS, DB)
    = warning(DB, QIL) .

  op fixMaps : [RenamingSet] ModuleExpression Database -> RenamingSet .
  op fixMaps2 : [RenamingSet] Module ClassDeclSet MsgDeclSet -> RenamingSet .

  ceq fixMaps(RS, ME, DB)
    = fixMaps2(RS, getFlatModule(ME, DB), CDS, MDS)
    if < CDS ; MDS > := getAllClassesAndMsgs(ME, DB) .

  eq fixMaps2(op F to F' [AtS], M, CDS, MDS)
    = opsAffd(getOps(M), op F to F' [AtS], M) .
  eq fixMaps2((op F to F' [AtS], RS), M, CDS, MDS)
    = (opsAffd(getOps(M), op F to F' [AtS], M),
       fixMaps2(RS, M, CDS, MDS)) .
  eq fixMaps2(op F : TyL -> Ty to F' [AtS], M, CDS, MDS)
    = opsAffd(getOps(M), op F : TyL -> Ty to F' [AtS], M) .
  eq fixMaps2((op F : TyL -> Ty to F' [AtS], RS), M, CDS, MDS)
    = (opsAffd(getOps(M), op F : TyL -> Ty to F' [AtS], M),
       fixMaps2(RS, M, CDS, MDS)) .

  eq fixMaps2(msg F to F', M, CDS, MDS)
    = msgsAffd(MDS, msg F to F', M) .
  eq fixMaps2((msg F to F', RS), M, CDS, MDS)
    = (msgsAffd(MDS, msg F to F', M), fixMaps2(RS, M, CDS, MDS)) .
  eq fixMaps2(msg F : TyL -> Ty to F', M, CDS, MDS)
    = msgsAffd(MDS, msg F : TyL -> Ty to F', M) .
  eq fixMaps2((msg F : TyL -> Ty to F', RS), M, CDS, MDS)
    = (msgsAffd(MDS, msg F : TyL -> Ty to F', M),
       fixMaps2(RS, M, CDS, MDS)) .

  eq fixMaps2(strat F to F', M, CDS, MDS)
   = stratsAffd(getStratDcls(M), strat F to F', M) .
  eq fixMaps2((strat F to F', RS), M, CDS, MDS)
   = stratsAffd(getStratDcls(M), strat F to F', M),
     fixMaps2(RS, M, CDS, MDS) .
  eq fixMaps2(strat F : TyL @ Ty to F', M, CDS, MDS)
   = stratsAffd(getStratDcls(M), strat F : TyL @ Ty to F', M) .
  eq fixMaps2((strat F : TyL @ Ty to F', RS), M, CDS, MDS)
   = stratsAffd(getStratDcls(M), strat F : TyL @ Ty to F', M),
     fixMaps2(RS, M, CDS, MDS) .

  eq fixMaps2(sort Ty to Ty', M, CDS, MDS)
    = if sortsAffd(getSorts(M), sort Ty to Ty')
      then (sort Ty to Ty')
      else none
      fi .
  eq fixMaps2(((sort Ty to Ty'), RS), M, CDS, MDS)
    = (if sortsAffd(getSorts(M), sort Ty to Ty')
       then (sort Ty to Ty')
       else none
       fi,
       fixMaps2(RS, M, CDS, MDS)) .
  eq fixMaps2(class Ty to Ty', M, CDS, MDS)
    = if classesAffd(CDS, class Ty to Ty')
      then (class Ty to Ty')
      else none
      fi .
  eq fixMaps2(((class Ty to Ty'), RS), M, CDS, MDS)
    = (if classesAffd(CDS, class Ty to Ty')
       then (class Ty to Ty')
       else none
       fi,
       fixMaps2(RS, M, CDS, MDS)) .
  eq fixMaps2(attr A . Ty to Ty', M, CDS, MDS)
    = if classesAffd(CDS, attr A . Ty to Ty')
      then (attr A . Ty to Ty')
      else none
      fi .
  eq fixMaps2(((class A . Ty to Ty'), RS), M, CDS, MDS)
    = (if classesAffd(CDS, attr A . Ty to Ty')
       then (attr A . Ty to Ty')
       else none
       fi,
       fixMaps2(RS, M, CDS, MDS)) .
  eq fixMaps2(R:Renaming, M, CDS, MDS) = R:Renaming [owise] .
  eq fixMaps2((R:Renaming, RS), M, CDS, MDS)
    = (R:Renaming, fixMaps2(RS, M, CDS, MDS))
    [owise] .
  eq fixMaps2(none, M, CDS, MDS) = none .

  sort Tuple{ClassDeclSet, MsgDeclSet} .
  op <_;_> : ClassDeclSet MsgDeclSet -> Tuple{ClassDeclSet, MsgDeclSet} .
  op getClasses : Tuple{ClassDeclSet, MsgDeclSet} -> ClassDeclSet .
  op getMsgs : Tuple{ClassDeclSet, MsgDeclSet} -> MsgDeclSet .
  eq getClasses(< CDS ; MDS >) = CDS .
  eq getMsgs(< CDS ; MDS >) = MDS .

  op getAllClassesAndMsgs :
       ModuleExpression Database -> Tuple{ClassDeclSet, MsgDeclSet} .
  op getAllClassesAndMsgs :
       ImportList Database -> Tuple{ClassDeclSet, MsgDeclSet} .

  eq getAllClassesAndMsgs(ME, DB)
    = if getTopModule(ME, DB) :: OModule
         and-then not getTopModule(ME, DB) :: SModule
      then < getClasses(
               getAllClassesAndMsgs(getImports(getTopModule(ME, DB)), DB))
             getClasses(getTopModule(ME, DB))
             ;
             getMsgs(
               getAllClassesAndMsgs(getImports(getTopModule(ME, DB)), DB))
             getMsgs(getTopModule(ME, DB)) >
      else < none ; none >
      fi .

  eq getAllClassesAndMsgs(I IL, DB)
    = < getClasses(getAllClassesAndMsgs(moduleName(I), DB))
        getClasses(getAllClassesAndMsgs(IL, DB))
        ;
        getMsgs(getAllClassesAndMsgs(moduleName(I), DB))
        getMsgs(getAllClassesAndMsgs(IL, DB)) > .
  eq getAllClassesAndMsgs((nil).ImportList, DB) = < none ; none > .

----  sorts NeSet<TypeList> Set<TypeList> .
----  subsort TypeList < NeSet<TypeList> < Set<TypeList> .
----  op noneTLS : -> Set<TypeList> [ctor] .
----  op _!_ : Set<TypeList> Set<TypeList> -> Set<TypeList>
----     [ctor assoc comm id: noneTLS] .
----  op _!_ : NeSet<TypeList> NeSet<TypeList> -> NeSet<TypeList>
----     [ctor assoc comm id: noneTLS] .

----  sort Set<Type> .
----  subsorts Type SortSet < Set<Type> .
----  op _o_ : Set<Type> Set<Type> -> Set<Type> [ctor assoc comm id: none] .
----
----  eq Ty o Ty = Ty .

  sort TypeSetList .
  subsort TypeSet < TypeSetList .
  op nilTSL : -> TypeSetList [ctor] .
  op _l_ : TypeSetList TypeSetList -> TypeSetList
     [ctor assoc id: nilTSL] .

  var  TS : TypeSet .
  var  TSL : TypeSetList .
  var  TLS : TypeListSet .
----  var  NTLS : NeTypeListSet .

----  eq TyL ! TyL = TyL .

  ----eq _!_(qidError(QIL), NTLS) = qidError(QIL) .

  op fixKinds : TypeList Module -> TypeListSet .
  op fixKinds : TypeList TypeSetList Module -> TypeListSet .
  op fixKindsAux : Type Module -> TypeSet .
  op fixKindsAux2 : SortSet Module -> TypeSet .
  op unfold : TypeSetList -> TypeListSet .
  op add : TypeSet TypeListSet -> TypeListSet .

  eq fixKinds(TyL, M) = fixKinds(TyL, nilTSL, M) .

  eq fixKinds(Ty TyL, TSL, M)
    = if fixKindsAux(Ty, M) == nil
      then none
      else fixKinds(TyL, TSL l fixKindsAux(Ty, M), M)
      fi .
  eq fixKinds(nil, TSL, M) = unfold(TSL) .

  eq fixKindsAux(S, M)
    = if S in getSorts(M)
      then cc(connectedSorts(M, S))
      else none
      fi .
  eq fixKindsAux(K, M) = fixKindsAux2(getSorts(K), M) .
  eq fixKindsAux(cc(SS), M) = fixKindsAux2(SS, M) .

  eq fixKindsAux2((S ; SS), M)
    = (if S in getSorts(M)
       then cc(connectedSorts(M, S))
       else none
       fi
       ;
       fixKindsAux2(SS, M)) .
  eq fixKindsAux2(none, M) = none .

  ceq unfold(TS l TSL) = add(TS, unfold(TSL)) if TS =/= none .
  eq unfold(nilTSL) = none .

  ceq add(Ty, TyL ; TLS) = add(Ty, TyL) ; add(Ty, TLS) if TLS =/= none .
  eq add(Ty ; Ty' ; TS, TLS) = add(Ty, TLS) ; add(Ty' ; TS, TLS) .
  eq add(none, TLS) = nilTSL .
  eq add(Ty, none) = Ty .
  eq add(Ty, TyL) = Ty TyL .

  op connectedSorts : Module Type -> SortSet .
  op connectedSorts : Module SortSet Type -> SortSet .
  eq connectedSorts(M, Ty) = connectedSorts(M, getSorts(M), Ty) .
  eq connectedSorts(M, S ; SS, Ty)
    = if sameKind(M, S, Ty)
      then S
      else none
      fi ; connectedSorts(M, SS, Ty) .
  eq connectedSorts(M, none, Ty) = none .

  op sortsAffd : SortSet Renaming -> Bool .
  op opsAffd : OpDeclSet Renaming Module -> RenamingSet .
  op opsAffdAux : OpDeclSet Qid TypeListSet Qid AttrSet Module -> RenamingSet .

  eq sortsAffd((S ; SS), (sort S to S')) = true .
  eq sortsAffd(SS, (sort S to S')) = false [owise] .

  eq opsAffd(op F : TyL -> Ty [AtS] . OPDS, op F to F' [AtS'], M)
    = op F to F' [AtS'] .
  eq opsAffd(OPDS, op F : TyL -> Ty to F' [AtS], M)
    = opsAffdAux(OPDS, F, fixKinds(TyL Ty, M), F', AtS, M) .
  eq opsAffd(OPDS, RS:[RenamingSet], M) = none [owise] .

  eq opsAffdAux(op F : TyL -> Ty [AtS] . OPDS,
       F, (TyL' Ty') ; TLS, F', AtS', M)
    = if sameKind(M, (TyL Ty), (TyL' Ty'))
      then (op F : TyL' -> Ty' to F' [AtS'],
            opsAffdAux(OPDS, F, TLS, F', AtS', M))
      else (opsAffdAux(OPDS, F, (TyL' Ty') ; TLS, F', AtS', M),
            opsAffdAux(op F : TyL -> Ty [AtS] . OPDS, F, TLS, F', AtS', M))
      fi .
  eq opsAffdAux(OPDS, F, TLS, F', AtS, M) = none [owise] .

  op stratsAffd : StratDeclSet Renaming Module -> RenamingSet .
  op stratsAffdAux : StratDeclSet Qid TypeListSet Qid Module -> RenamingSet .

  eq stratsAffd(strat F : TyL @ Ty [AtS] . StratDcls, strat F to F', M)
    = strat F to F' .
  eq stratsAffd(StratDcls, strat F : TyL @ Ty to F', M)
    = stratsAffdAux(StratDcls, F, fixKinds(TyL Ty, M), F', M) .
  eq stratsAffd(StratDcls, RS:[RenamingSet], M) = none [owise] .

  eq stratsAffdAux(strat F : TyL @ Ty [AtS] . StratDcls,
       F, (TyL' Ty') ; TLS, F', M)
    = if sameKind(M, (TyL Ty), (TyL' Ty'))
      then (strat F : TyL' @ Ty' to F',
            stratsAffdAux(StratDcls, F, TLS, F', M))
      else (stratsAffdAux(StratDcls, F, (TyL' Ty') ; TLS, F', M),
            stratsAffdAux(strat F : TyL @ Ty [AtS] . StratDcls, F, TLS, F', M))
      fi .
  eq stratsAffdAux(StratDcls, F, TLS, F', M) = none [owise] .

*** The predicate \texttt{modAffd} checks whether the module with the
*** name given as first argument in the database is affected by the set of maps
*** given as second argument. A module is affected by a map set if any of the
*** maps is applicable to the module or to any of its submodules.

  op modAffd : Header RenamingSet Module Database -> Bool .

  op modAffdAux : Module RenamingSet Module Database -> Bool .
  op rlsAffd : RuleSet RenamingSet -> Bool .
  op importsAffd : ImportList RenamingSet Module Database -> Bool .
  op classesAffd : ClassDeclSet RenamingSet -> Bool .
  op msgsAffd : MsgDeclSet RenamingSet Module -> RenamingSet .
  op msgsAffdAux : MsgDeclSet Qid TypeListSet Qid Module -> RenamingSet .

  eq modAffd(ME, RS, M, DB)
    = modAffdAux(getTopModule(ME, DB), RS, M, DB) .

  eq modAffdAux(U, RS, M, DB)
    = sortsAffd(getSorts(U), RS)
      or-else
      (opsAffd(getOps(U), RS, M) == none
       or-else
       ((not U :: FModule
         and-then
         (rlsAffd(getRls(U), RS)
          or-else
          (not U :: SModule
           and-then
           (classesAffd(getClasses(U), RS)
            or-else
            msgsAffd(getMsgs(U), RS, M) == none))))
        or-else
        importsAffd(getImports(U), RS, M, DB))) .

  eq importsAffd(((including ME .) IL), RS, M, DB)
    = modAffd(ME, RS, M, DB)
      or-else importsAffd(IL, RS, M, DB) .
  eq importsAffd(((extending ME .) IL), RS, M, DB)
    = modAffd(ME, RS, M, DB)
      or-else importsAffd(IL, RS, M, DB) .
  eq importsAffd(((protecting ME .) IL), RS, M, DB)
    = modAffd(ME, RS, M, DB)
      or-else importsAffd(IL, RS, M, DB) .
  eq importsAffd(nil, RS, M, DB) = false .

  eq rlsAffd(((rl T => T' [label(L) AtS] .) RlS), (label L' to L''))
    = (L == L') or-else rlsAffd(RlS, label L' to L'') .
  eq rlsAffd(((rl T => T' [label(L) AtS] .) RlS),
       ((label L' to L''), RS))
    = (L == L') or-else
      (rlsAffd((rl T => T' [label(L) AtS] .), RS) or-else
       rlsAffd(RlS, ((label L' to L''), RS))) .
  eq rlsAffd(((crl T => T' if T'' = T3 [label(L) AtS] .) RlS),
       (label L' to L''))
    = (L == L') or-else rlsAffd(RlS, (label L' to L'')) .
  eq rlsAffd(((crl T => T' if T'' = T3 [label(L) AtS] .) RlS),
       ((label L' to L''), RS))
    = (L == L')
      or-else
      (rlsAffd((crl T => T' if T'' = T3 [label(L) AtS] .), RS)
      or-else
      rlsAffd(RlS, ((label L' to L''), RS))) .
  eq rlsAffd(RlS, RS) = false [owise] .

  eq classesAffd(((class C | ADS .) CDS), (class C' to C''))
    = (C == C')
      or-else
      classesAffd(CDS, (class C' to C'')) .
  eq classesAffd(((class C | ADS .) CDS), ((class C' to C''), RS))
    = (C == C')
      or-else
      (classesAffd((class C | ADS .), RS)
      or-else
      classesAffd(CDS, ((class C' to C''), RS))) .
  eq classesAffd(((class C | ((attr A : S), ADS) .) CDS),
       (attr A' . C' to A''))
    = if C == C'
      then (A == A')
           or-else
           classesAffd(((class C | ADS .) CDS), (attr A' . C' to A''))
      else classesAffd(CDS, (attr A' . C' to A''))
      fi .
  eq classesAffd(((class C | ((attr A : S), ADS) .) CDS),
       ((attr A' . C' to A''), RS))
    = if C == C'
      then (A == A')
           or-else
           (classesAffd(((class C | ADS .) CDS),
              ((attr A' . C' to A''), RS))
           or-else
           classesAffd(CDS, RS))
      else classesAffd((class C | ((attr A : S), ADS) .), RS)
           or-else
           classesAffd(CDS, ((attr A' . C' to A''), RS))
      fi .
  eq classesAffd(CDS, RS) = false [owise] .

  eq msgsAffd(msg F : TyL -> Ty . MDS, msg F to F', M) = msg F to F' .
  eq msgsAffd(MDS, msg F : TyL -> Ty to F', M)
    = msgsAffdAux(MDS, F, fixKinds(TyL Ty, M), F', M) .
  eq msgsAffd(MDS, RS:[RenamingSet], M) = none [owise] .

  eq msgsAffdAux(msg F : TyL -> Ty . MDS, F, (TyL' Ty') ; TLS, F', M)
    = if sameKind(M, (TyL Ty), (TyL' Ty'))
      then (msg F : TyL' -> Ty' to F',
            msgsAffdAux(MDS, F, TLS, F', M))
      else (msgsAffdAux(MDS, F, (TyL' Ty') ; TLS, F', M),
            msgsAffdAux(msg F : TyL -> Ty . MDS, F, TLS, F', M))
      fi .
  eq msgsAffdAux(MDS, F, TLS, F', M) = none [owise] .

*** The function \texttt{mapsRestrict} returns the subset of the view
*** maps given as second argument that affect the given module.

  op mapsRestrict : Module RenamingSet Module Database -> RenamingSet .
  op mapsRestrict : Header RenamingSet Module Database -> RenamingSet .

  eq mapsRestrict(ME, RS, M, DB)
    = mapsRestrict(getTopModule(ME, DB), RS, M, DB) .

  eq mapsRestrict(U, R, M, DB)
    = if modAffdAux(U, R, M, DB)
      then R
      else none
      fi .
  eq mapsRestrict(U, (R, RS), M, DB)
    = if modAffdAux(U, R, M, DB)
      then (R, mapsRestrict(U, RS, M, DB))
      else mapsRestrict(U, RS, M, DB)
      fi .
  eq mapsRestrict(U, none, M, DB) = none .

*** The definition of the function \texttt{header2QidList} on the renaming
*** module expression has to take care of transforming into a quoted identifier
*** list the set of view maps given in the module expression.

  op maps2QidList : RenamingSet -> QidList .

  op attrSet2QidList : AttrSet -> QidList .
  op hookList2QidList : HookList -> QidList .
  op termList2QidList : TermList -> QidList .
  op intList2QidList : IntList -> QidList .
  op typeList2QidList : TypeList -> QidList .

  eq maps2QidList(((op F to F' [AtS]), RS))
    = if AtS == none
      then ('op F 'to F' '`, '\s maps2QidList(RS))
      else ('op F 'to F' '\s '`[ attrSet2QidList(AtS) '`] '`, '\s
            maps2QidList(RS))
      fi
    [owise] .
  eq maps2QidList((op F to F' [AtS]))
    = if AtS == none
      then ('op F 'to F')
      else ('op F 'to F' '\s '`[ attrSet2QidList(AtS) '`])
      fi .
  eq maps2QidList(((op F : TyL -> Ty to F' [AtS]), RS))
    = if AtS == none
      then ('op F ': typeList2QidList(TyL) '-> Ty 'to F' '`,
            '\s maps2QidList(RS))
      else ('op F ': typeList2QidList(TyL) '-> Ty 'to F'
            '`[ attrSet2QidList(AtS) '`] '`, '\s maps2QidList(RS))
      fi
    [owise] .
  eq maps2QidList((op F : TyL -> Ty to F' [AtS]))
    = if AtS == none
      then ('op F ': typeList2QidList(TyL) '-> Ty 'to F')
      else ('op F ': typeList2QidList(TyL) '-> Ty 'to F'
            '`[ attrSet2QidList(AtS) '`])
      fi .
  eq maps2QidList(((sort S to S'), RS))
    = ('sort S 'to S' '`, '\s maps2QidList(RS))
    [owise] .
  eq maps2QidList((sort S to S')) = ('sort S 'to S') .

  eq maps2QidList(((label L to L'), RS))
    = ('label L 'to L' '`, '\s maps2QidList(RS))
    [owise] .
  eq maps2QidList((label L to L')) = ('label L 'to L') .

  eq maps2QidList(((msg F to F'), RS))
    = ('msg F 'to F' '`, '\s maps2QidList(RS))
    [owise] .
  eq maps2QidList((msg F to F')) = ('msg F 'to F') .

  eq maps2QidList(((msg F : TyL  -> Ty to F'), RS))
    = ('msg F ': typeList2QidList(TyL) '-> Ty 'to F' '`, '\s
       maps2QidList(RS))
    [owise] .
  eq maps2QidList((msg F : TyL -> Ty to F'))
    = ('msg F ': typeList2QidList(TyL) '-> Ty 'to F') .

  eq maps2QidList(((strat F to F'), RS))
    = ('strat F 'to F' '`, '\s maps2QidList(RS))
    [owise] .
  eq maps2QidList((strat F to F')) = ('msg F 'to F') .

  eq maps2QidList(((strat F : TyL  @ Ty to F'), RS))
    = ('strat F ': typeList2QidList(TyL) '@ Ty 'to F' '`, '\s
       maps2QidList(RS))
    [owise] .
  eq maps2QidList((strat F : TyL @ Ty to F'))
    = ('strat F ': typeList2QidList(TyL) '@ Ty 'to F') .

  eq maps2QidList(((class S to S'), RS))
    = ('class S 'to S' '`, '\s maps2QidList(RS))
    [owise] .
  eq maps2QidList((class S to S')) = ('class S 'to S') .

  eq maps2QidList(((attr QI . S to QI'), RS))
    = ('attr S '. QI 'to QI' '`, '\s maps2QidList(RS))
    [owise] .
  eq maps2QidList((attr QI . S to QI')) = ('attr S '. QI 'to QI') .

  eq maps2QidList(none) = nil .

  eq attrSet2QidList(none) = nil .
  eq attrSet2QidList((assoc AtS)) = ('assoc attrSet2QidList(AtS)) .
  eq attrSet2QidList((comm AtS))  = ('comm attrSet2QidList(AtS)) .
  eq attrSet2QidList((idem AtS))  = ('idem attrSet2QidList(AtS)) .
  eq attrSet2QidList((iter AtS))  = ('iter attrSet2QidList(AtS)) .
  eq attrSet2QidList((id(T) AtS))
    = ('id: termList2QidList(T) attrSet2QidList(AtS)) .
  eq attrSet2QidList((right-id(T) AtS))
    = ('right-id: termList2QidList(T) attrSet2QidList(AtS)) .
  eq attrSet2QidList((left-id(T) AtS))
    = ('left-id: termList2QidList(T) attrSet2QidList(AtS)) .
  eq attrSet2QidList((poly(NL) AtS))
    = ('poly '`( intList2QidList(NL) '`) attrSet2QidList(AtS)) .
  eq attrSet2QidList((strat(NL) AtS))
    = ('strat '`( intList2QidList(NL) '`) attrSet2QidList(AtS)) .
  eq attrSet2QidList((memo AtS))  = ('memo attrSet2QidList(AtS)) .
  eq attrSet2QidList((prec(N) AtS))
    = ('prec intList2QidList(N) attrSet2QidList(AtS)) .
  eq attrSet2QidList((gather(QIL) AtS))
    = ('gather QIL attrSet2QidList(AtS)) .
  eq attrSet2QidList((format(QIL) AtS))
    = ('format QIL attrSet2QidList(AtS)) .
  eq attrSet2QidList((ctor AtS))  = ('ctor attrSet2QidList(AtS)) .
  eq attrSet2QidList((frozen(NL) AtS))
    = ('frozen '`( intList2QidList(NL) '`) attrSet2QidList(AtS)) .
  eq attrSet2QidList((config AtS))  = ('config attrSet2QidList(AtS)) .
  eq attrSet2QidList((object AtS))  = ('object attrSet2QidList(AtS)) .
  eq attrSet2QidList((msg AtS))  = ('msg attrSet2QidList(AtS)) .
  eq attrSet2QidList((special(HkL) AtS))
    = ('special '`( hookList2QidList(HkL) '`) attrSet2QidList(AtS)) .
  eq attrSet2QidList((none).AttrSet) = nil .
  eq attrSet2QidList((metadata(St) AtS)) = (('metadata qid("\"" + St + "\"")) attrSet2QidList(AtS)) .
  eq attrSet2QidList((nonexec AtS))  = ('nonexec attrSet2QidList(AtS)) .
  eq attrSet2QidList((variant AtS))  = ('variant attrSet2QidList(AtS)) .

  eq hookList2QidList((id-hook(QI, QIL) HkL))
    = ('id-hook QI '`, '`( QIL '`) hookList2QidList(HkL)) .
  eq hookList2QidList((op-hook(QI, QI', QIL, QI'') HkL))
    = ('op-hook QI '`( QI' ': QIL '-> QI'' '`) hookList2QidList(HkL)) .
  eq hookList2QidList((term-hook(QI, T) HkL))
    = ('term-hook '`( QI '`, termList2QidList(T) '`) hookList2QidList(HkL)) .

  eq termList2QidList(QI) = QI .
  eq termList2QidList(F[TL]) = (F '`( termList2QidList(TL) '`)) .
  ceq termList2QidList((T, TL))
    = (termList2QidList(T) '`, termList2QidList(TL))
    if TL =/= empty .

  eq intList2QidList((N NL)) = (qid(string(N, 10)) intList2QidList(NL)) .
  eq intList2QidList(nil) = nil .

  eq typeList2QidList(Ty TyL) = type2qid(Ty) typeList2QidList(TyL) .
  eq typeList2QidList(nil) = nil .

*** Let us now give the equations for \texttt{setUpModExpDeps} on the
*** renaming module expression.  Given a module expression of the form
*** \verb~ME *< RS >~ such that \texttt{ME} is in the database, we just need
*** to add \verb~ME *< RS >~ to the set of names of the modules depending on
*** \texttt{ME}. In this way, if \texttt{ME} is redefined or removed from the
*** database, \verb~ME *< RS >~ will be removed as well.

  eq setUpModExpDeps(ME * (RS),
       db(< ME ; DT ; U ; U' ; M ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = db(< ME ; DT ; U ; U' ; M ; VDS ; MNS . ME * (RS) ; VES > MIS,
         MNS', VIS, VES', MNS'', MNS3, MNS4, QIL) .
  eq setUpModExpDeps(ME * (RS),
       db(< ME ; DM ; U ; U' ; M ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = db(< ME ; DM ; U ; U' ; M ; VDS ; MNS . ME * (RS) ; VES > MIS,
         MNS', VIS, VES', MNS'', MNS3, MNS4, QIL) .
  ceq setUpModExpDeps(ME * (RS), DB)
    = warning(DB, '\r 'Error: '\o 'Module header2QidList(ME) 'not 'in 'database. '\n)
    if not unitInDb(ME, DB) .

*** The definition of the \texttt{prepHeader} function on a renaming module
*** expression must take into account the possibility of having parameterized
*** sorts or parameterized class names in the maps of a renaming module
*** expression.  The preparation of a renaming module expression must take
*** into account this fact and prepare accordingly all parameterized sorts and
*** classes appearing in it.

  op prepare : RenamingSet Set{Tuple{ViewExpression,ViewExpression}} -> RenamingSet .

  op prepare : TypeList Set{Tuple{ViewExpression,ViewExpression}} -> TypeList .

  eq prepModExp(ME * (RS), VEPS)
    = _*`(_`)(prepModExp(ME, VEPS), prepare(RS, VEPS)) .

*** For example, for sort maps the equation is as follows.

  eq prepare((sort S to S'), VEPS)
    = (sort prepSort(S, VEPS) to prepSort(S', VEPS)) .
  eq prepare(((sort S to S'), RS), VEPS)
    = ((sort prepSort(S, VEPS) to prepSort(S', VEPS)),
       prepare(RS, VEPS)) .


  eq prepare((class S to S'), VEPS)
    = (class prepSort(S, VEPS) to prepSort(S', VEPS)) .
  eq prepare(((class S to S'), RS), VEPS)
    = ((class prepSort(S, VEPS) to prepSort(S', VEPS)),
       prepare(RS, VEPS)) .
  eq prepare((attr QI . S to QI'), VEPS)
    = (attr QI . prepSort(S, VEPS) to QI') .
  eq prepare(((attr QI . S to QI'), RS), VEPS)
    = ((attr QI . prepSort(S, VEPS) to QI'), prepare(RS, VEPS)) .
  eq prepare((op F to F' [AtS]), VEPS) = (op F to F' [AtS]) .
  eq prepare(((op F to F' [AtS]), RS), VEPS)
    = ((op F to F' [AtS]), prepare(RS, VEPS)) .
  eq prepare((op F : TyL -> Ty to F' [AtS]), VEPS)
    = (op F : prepare(TyL, VEPS) -> prepSort(Ty, VEPS) to F' [AtS]) .
  eq prepare(((op F : TyL -> Ty to F' [AtS]), RS), VEPS)
    = (op F : prepare(TyL, VEPS) -> prepSort(Ty, VEPS) to F' [AtS],
       prepare(RS, VEPS)) .
  eq prepare((label L to L'), VEPS) = (label L to L') .
  eq prepare(((label L to L'), RS), VEPS)
    = ((label L to L'), prepare(RS, VEPS)) .
  eq prepare((msg F to F'), VEPS) = (msg F to F') .
  eq prepare(((msg F to F'), RS), VEPS)
    = ((msg F to F'), prepare(RS, VEPS)) .
  eq prepare((msg F : TyL -> Ty to F'), VEPS)
    = (msg F : prepare(TyL, VEPS) -> prepSort(Ty, VEPS) to F') .
  eq prepare(((msg F : TyL -> Ty to F'), RS), VEPS)
    = ((msg F : prepare(TyL, VEPS) -> prepSort(Ty, VEPS) to F'),
       prepare(RS, VEPS)) .
  eq prepare(strat F to F', VEPS) = (strat F to F') .
  eq prepare((strat F to F', RS), VEPS)
    = strat F to F', prepare(RS, VEPS) .
  eq prepare(strat F : TyL @ Ty to F', VEPS)
    = strat F : prepare(TyL, VEPS) @ prepSort(Ty, VEPS) to F' .
  eq prepare((strat F : TyL @ Ty to F', RS), VEPS)
    = strat F : prepare(TyL, VEPS) @ prepSort(Ty, VEPS) to F',
      prepare(RS, VEPS) .
  eq prepare((none).RenamingSet, VEPS) = none .

  eq prepare((Ty TyL), VEPS) = (prepSort(Ty, VEPS) prepare(TyL, VEPS)) .
  eq prepare(nil, VEPS) = nil .

  eq header2Qid(ME * (RS))
    = qid(string(header2Qid(ME))
          + " * (" + string(qidList2Qid(maps2QidList(RS))) + ")")
    [owise] .

  ceq header2QidList(ME * (RS))
    = (if QI == '\s then QIL QI else QIL QI '\s fi
       '* '\s '`( maps2QidList(RS) '`))
    if QIL QI := header2QidList(ME)
    [owise] .

endfm

*******************************************************************************

***
*** The Union Module Expression
***

*** The syntax used for the union of module expressions is

***   op _+_ : ModuleExpression ModuleExpression -> ModuleExpression
***       [assoc prec 42] .

*** Its evaluation consists in generating a unit importing the two module
*** expressions given as arguments~\cite{Winkler91,OBJ92}.

*** As we explained in Sections~\ref{instantiation} and~\ref{renaming} for the
*** cases of the instantiation and the renaming module expressions,
*** respectively, the declaration of any new kind of module expression must
*** come together with the definition of the functions \texttt{evalModExp},
*** \texttt{header2QidList}, and \texttt{setUpModExpDeps} on the new
*** module operator. As discussed in Sections~\ref{instantiation}
*** and~\ref{parsing-unit-declarations}, equations for the \texttt{prepHeader}
*** and \texttt{parseModExp} functions have to be given as well.

fmod UNION-EXPR is
  inc MOD-EXPR .
  pr FM-INST-EXPR-EVALUATION .
  pr FM-RENAMING-EXPR-EVALUATION .
  pr FM-EVALUATION .

  vars QI X : Qid .
  var  PDL : ParameterDeclList .
  vars DB DB' DB'' : Database .
  vars T T' : Term .
  vars DT DT' : Default{Term} .
  var  IL : ImportList .
  var  VEPS : Set{Tuple{ViewExpression,ViewExpression}} .
  vars ME ME' ME'' ME3 : ModuleExpression .
  vars PU PU' U U' U'' U3 DM DM' : Module .
  vars M M' M'' M3 : Module .
  vars MNS MNS' MNS'' MNS3 MNS4 MNS5 : Set{ModuleName} .
  vars VES VES' VES'' : Set{ViewExpression} .
  vars PDS PDS' PDS'' : Set{ParameterDecl} .
  vars MIS MIS' : Set{ModuleInfo} .
  var  VIS : Set{ViewInfo} .
  vars QIL QIL' : QidList .
  var  VDS VDS' : VariableSet .
  var  B : Bool .
  var  MAPS : RenamingSet .

*** As mentioned above, the evaluation of a union module expression consists
*** in the creation of a new unit, with such a module expression as name,
*** which imports the two module expressions being united. Note, however,
*** that the unit being created has to be of the right type. The new unit
*** will be generated having one type or another, depending on the types of
*** the arguments of the union module expression.

*** The function \texttt{rightEmptyModule} generates an empty unit of the
*** lowest of the sorts of its two arguments. In case of having a nonstructured
*** module as argument, the corresponding structured one is considered. If one
*** of the two module expressions corresponds to a theory, then a theory is
*** generated, and the lowest sort is taken between the sort of such a theory
*** and the \texttt{Module} sort immediately above the sort of the other unit;
*** that is, sorts \texttt{FModule}, \texttt{SModule}, or \texttt{OModule} are
*** considered to do the comparison.

  ceq evalModExp(ME + ME', PDL, DB)
    = if unitInDb(ME'', DB') or-else not summandsInDB(ME'', DB')
      then < DB' ; ME'' >
      else < evalModule(
               addImports(unfoldSummands(ME''),
                 setName(rightEmptyModule(ME'', DB'), ME'')),
               none,
               DB')
             ; ME'' >
      fi
    if < DB' ; ME'' > := evalModExp+(ME + ME', PDL, DB) .

  op summandsInDB : ModuleExpression Database -> Bool .
  eq summandsInDB(ME + ME', DB)
    = summandsInDB(ME, DB) and-then summandsInDB(ME', DB) .
  eq summandsInDB(ME, DB) = unitInDb(ME, DB) [owise] .

  op unfoldSummands : ModuleExpression -> ImportList .
  eq unfoldSummands(ME + ME') = unfoldSummands(ME) unfoldSummands(ME') .
  eq unfoldSummands(ME) = (including ME .) [owise] .

  op rightEmptyModule : ModuleExpression Database -> Module .
  eq rightEmptyModule(ME, DB) = emptyModule(kindOfModule(ME, DB)) .

  op evalModExp+ : ModuleExpression ParameterDeclList Database -> Tuple{Database, ModuleExpression} .
  eq evalModExp+(ME + ME', PDL, DB)
    = < database(evalModExp+(ME', PDL, database(evalModExp+(ME, PDL, DB))))
      ; modExp(evalModExp+(ME', PDL, database(evalModExp+(ME, PDL, DB))))
        + modExp(evalModExp+(ME, PDL, DB)) > .
  eq evalModExp+(ME, PDL, DB) = evalModExp(ME, PDL, DB) [owise] .

  op kindOfModule : ModuleExpression Database -> Qid .
  eq kindOfModule(ME + ME', DB) = greaterLowest(kindOfModule(ME, DB), kindOfModule(ME', DB)) .
  eq kindOfModule(ME, DB) = kindOfModule(getTopModule(ME, DB)) [owise] .

  op kindOfModule : Module -> Qid .
  eq kindOfModule(U:OModule)
    = if U:OModule :: FModule
      then 'fmod
      else if U:OModule :: SModule
           then 'mod
           else if U:OModule :: StratModule
                then 'smod
                else 'omod
                fi
           fi
      fi .
  eq kindOfModule(U:OTheory)
    = if U:OTheory :: FTheory
      then 'fmod
      else if U:OTheory :: STheory
           then 'mod
           else if U:OTheory :: StratTheory
                then 'smod
                else 'omod
                fi
           fi
      fi .
  eq kindOfModule(unitError(QIL)) = qidError(QIL) .

  op greaterLowest : Qid Qid ~> Qid [comm] .
  eq greaterLowest('fmod, 'fmod) = 'fmod .
  eq greaterLowest('fmod, 'fth) = 'fth .
  eq greaterLowest('fth, 'fth) = 'fth .
  eq greaterLowest('mod, 'fmod) = 'mod .
  eq greaterLowest('mod, 'mod) = 'mod .
  eq greaterLowest('mod, 'fth) = 'th .
  eq greaterLowest('fmod, 'th) = 'th .
  eq greaterLowest('mod, 'th) = 'th .
  eq greaterLowest('th, 'th) = 'th .
  eq greaterLowest('omod, 'fmod) = 'omod .
  eq greaterLowest('omod, 'mod) = 'omod .
  eq greaterLowest('omod, 'omod) = 'omod .
  eq greaterLowest('omod, 'fth) = 'oth .
  eq greaterLowest('omod, 'th) = 'oth .
  eq greaterLowest('omod, 'oth) = 'oth .
  eq greaterLowest('fmod, 'oth) = 'oth .
  eq greaterLowest('mod, 'oth) = 'oth .
  eq greaterLowest('oth, 'th) = 'oth .
  eq greaterLowest('oth, 'fth) = 'oth .
  eq greaterLowest('oth, 'oth) = 'oth .

  op emptyModule : Qid ~> Module .
  eq emptyModule('fmod) = emptyFModule .
  eq emptyModule('fth) = emptyFTheory .
  eq emptyModule('mod) = emptySModule .
  eq emptyModule('th) = emptySTheory .
  eq emptyModule('omod) = emptyOModule .
  eq emptyModule('oth) = emptyOTheory .

*** As pointed out in Section~\ref{module-names}, for each new module
*** expression operator being introduced, we need to add equations for the
*** \texttt{header2Qid} function. For the union module expression we only
*** need the following equation:

  eq header2Qid(ME + ME')
    = qidList2Qid(header2QidList(ME) '+ header2QidList(ME')) .
  eq header2Qid(_*`(_`)(ME + ME', MAPS))
    = qid("(" + string(header2Qid(ME + ME')) + ")"
          + " * (" + string(qidList2Qid(maps2QidList(MAPS))) + ")") .

  eq header2QidList(ME + ME')
    = (header2QidList(ME) '+ header2QidList(ME')) .
  ceq header2QidList(_*`(_`)(ME + ME', MAPS))
    = (if QI == '\s then '`( QIL '`) QI else '`( QIL QI '`) '\s fi
       '* '\s '`( maps2QidList(MAPS) '`))
    if QIL QI := header2QidList(ME + ME') .

*** Given a module
*** expression of the form \verb~ME + ME'~ such that \texttt{ME} and
*** \texttt{ME'} are in the database, we need to add \verb~ME + ME'~ to
*** the set of names of the modules depending on \texttt{ME} and \texttt{ME'}.
*** In this way, if \texttt{ME} or \texttt{ME'} are redefined or removed from
*** the database, \verb~ME + ME'~ will be removed as well.

  op setUpModExpDepsAux : ModuleExpression ModuleExpression Database -> Database .
  eq setUpModExpDeps(ME + ME', DB) = setUpModExpDepsAux(ME + ME', ME + ME', DB) .

  eq setUpModExpDepsAux(ME, ME' + ME'', DB)
   = setUpModExpDepsAux(ME, ME', setUpModExpDepsAux(ME, ME'', DB)) .
  eq setUpModExpDepsAux(ME, ME',
      db(< ME' ; DT ; U ; U' ; M ; VDS ; MNS ; VES > MIS, MNS'', VIS, VES'', MNS3, MNS4, MNS5, QIL))
   = db(< ME' ; DT ; U ; U' ; M ; VDS ; MNS . ME ; VES > MIS, MNS'', VIS, VES'', MNS3, MNS4, MNS5, QIL)
   [owise] .
  eq setUpModExpDepsAux(ME, ME',
      db(< ME' ; DM ; U ; U' ; M ; VDS ; MNS ; VES > MIS, MNS'', VIS, VES'', MNS3, MNS4, MNS5, QIL))
   = db(< ME' ; DM ; U ; U' ; M ; VDS ; MNS . ME ; VES > MIS, MNS'', VIS, VES'', MNS3, MNS4, MNS5, QIL)
   [owise] .

---(  eq setUpModExpDeps((ME + ME'),
      db((< ME ; DT ; U ; U' ; M ; VDS ; MNS ; VES >
          < ME' ; DT' ; U'' ; U3 ; M' ; VDS' ; MNS' ; VES' > MIS),
         MNS'', VIS, VES'', MNS3, MNS4, MNS5, QIL))
   = db((< ME ; DT ; U ; U' ; M ; VDS ; MNS . (ME + ME') ; VES >
         < ME' ; DT' ; U'' ; U3 ; M' ; VDS' ; MNS' . (ME + ME') ; VES' >
         MIS),
        MNS'', VIS, VES'', MNS3, MNS4, MNS5, QIL) .
  eq setUpModExpDeps((ME + ME'),
      db((< ME ; DT ; U ; U' ; M ; VDS ; MNS ; VES >
          < ME' ; DM ; U'' ; U3 ; M' ; VDS' ; MNS' ; VES' > MIS),
         MNS'', VIS, VES'', MNS3, MNS4, MNS5, QIL))
   = db((< ME ; DT ; U ; U' ; M ; VDS ; MNS . (ME + ME') ; VES >
         < ME' ; DM ; U'' ; U3 ; M' ; VDS' ; MNS' . (ME + ME') ; VES' >
         MIS),
        MNS'', VIS, VES'', MNS3, MNS4, MNS5, QIL) .
  eq setUpModExpDeps((ME + ME'),
      db((< ME ; DM ; U ; U' ; M ; VDS ; MNS ; VES >
          < ME' ; DT ; U'' ; U3 ; M' ; VDS' ; MNS' ; VES' > MIS),
         MNS'', VIS, VES'', MNS3, MNS4, MNS5, QIL))
   = db((< ME ; DM ; U ; U' ; M ; VDS ; MNS . (ME + ME') ; VES >
         < ME' ; DT ; U'' ; U3 ; M' ; VDS' ; MNS' . (ME + ME') ; VES' >
         MIS),
        MNS'', VIS, VES'', MNS3, MNS4, MNS5, QIL) .
  eq setUpModExpDeps((ME + ME'),
      db((< ME ; DM ; U ; U' ; M ; VDS ; MNS ; VES >
          < ME' ; DM' ; U'' ; U3 ; M' ; VDS' ; MNS' ; VES' > MIS),
         MNS'', VIS, VES'', MNS3, MNS4, MNS5, QIL))
   = db((< ME ; DM ; U ; U' ; M ; VDS ; MNS . (ME + ME') ; VES >
         < ME' ; DM' ; U'' ; U3 ; M' ; VDS' ; MNS' . (ME + ME') ; VES' >
         MIS),
        MNS'', VIS, VES'', MNS3, MNS4, MNS5, QIL) .
  ceq setUpModExpDeps((ME + ME'), DB)
    = warning(DB, ('\r 'Error: '\o 'Module header2QidList(ME) 'not 'in 'database. '\n))
    if not unitInDb(ME, DB) .
  ceq setUpModExpDeps((ME + ME'), DB)
    = warning(DB, ('\r 'Error: '\o 'Module header2QidList(ME') 'not 'in 'database. '\n))
    if not unitInDb(ME', DB) .
---)

*** The \texttt{prepHeader} function on a union module expression makes
*** recursive calls with each of the module expressions given as arguments.

  eq prepModExp(ME + ME', VEPS)
    = prepModExp(ME, VEPS) + prepModExp(ME', VEPS) .

*** Finally, the equation for the \texttt{parseModExp} function is as follows:

  eq labelInModExp(X, ME + ME')
    = labelInModExp(X, ME) or-else labelInModExp(X, ME') .
endfm

*******************************************************************************

***
*** The $n$-tuple Module Expression
***

*** The syntax used for the $n$-tuple module expression is as follows:

***   op TUPLE[_] : Token -> ModuleExpression .

*** Its evaluation consists in the generation of a parameterized functional
*** module with the number of \texttt{TRIV} parameters specified by the
*** argument. A sort for tuples of such size, and the corresponding constructor
*** and selector operators, are also defined. Note that the \texttt{TRIV}
*** theory is predefined in Full Maude (see Sections~\ref{main-module}
*** and~\ref{non-built-in-predefined}). For example, the module expression
*** \verb~TUPLE[3]~ produces the following module.

*** fmod TUPLE[3][C1 :: TRIV, C2 :: TRIV, C3 :: TRIV] is
***    sorts 3Tuple .
***    op (_,_,_) : Elt.C1 Elt.C2 Elt.C3 -> 3Tuple .
***    op p1_ : 3Tuple -> Elt.C1 .
***    op p2_ : 3Tuple -> Elt.C2 .
***    op p3_ : 3Tuple -> Elt.C3 .
***    var E1 : Elt.C1 .
***    var E2 : Elt.C2 .
***    var E3 : Elt.C3 .
***    eq p1(E1, E2, E3) = E1 .
***    eq p2(E1, E2, E3) = E2 .
***    eq p3(E1, E2, E3) = E3 .
*** endfm

*** Even though the $n$-tuple module expression is in principle of a completely
*** different nature, the way of handling it is the same as the way of handling
*** any other module expression. Its evaluation produces a new unit, a
*** parameterized functional module in this case, wtupleParList(N)ith the module expression as
*** name. New equations defining the semantics of functions
*** \texttt{evalModExp}, \texttt{header2QidList},
*** \texttt{setUpModExpDeps}, \texttt{prepHeader}, and
*** \texttt{parseModExp} are given for this module expression.


fmod N-TUPLE-EXPR is
  inc MOD-EXPR .
  pr FM-INST-EXPR-EVALUATION .
  pr FM-EVALUATION .

  vars N N' : NzNat .
  var  PDL : ParameterDeclList .
  var  DB : Database .
  var  T : Term .
  var  IL : ImportList .
  var  VEPS : Set{Tuple{ViewExpression,ViewExpression}} .
  var  X : Qid .
  var  S : Sort .

*** The equation for the \texttt{evalModExp} is reduced to the creation of a
*** module as indicated above. Some auxiliary functions are defined in order
*** to generate the different declarations in the module.

  op tupleParList : NzNat -> ParameterDeclList .
  op tupleImportList : NzNat -> ImportList .
  op createCopyPars : NzNat Database -> Database .
  op tupleOps : NzNat -> OpDeclSet .
  op tupleOpsCtor : NzNat -> OpDecl .
  op tupleOpsCtorName : NzNat -> String .
  op tupleOpsCtorArity : NzNat -> QidList .
  op tupleOpsSelectors : NzNat NzNat -> OpDeclSet .
  op tupleEqSet : NzNat -> EquationSet .
  op tupleEqSetAux : NzNat Term -> EquationSet .
  op tupleTermArgs : NzNat -> TermList .
  ops tupleSort tupleSortAux : NzNat -> Sort .

  eq evalModExp(TUPLE[N], PDL, DB)
    = if unitInDb(TUPLE[N], DB)
      then < DB ; TUPLE[N] >
      else < evalModule(
               fmod TUPLE[N]{tupleParList(N)} is
                 nil  ---- tupleImportList(N)
                 sorts tupleSort(N) .
                 none
                 tupleOps(N)
                 none
                 tupleEqSet(N)
               endfm,
               none,
               createCopyPars(N, DB)) ;
             TUPLE[N] >
      fi .

  eq createCopyPars(N, DB)
    = if N == 1
      then createCopy((qid("C" + string(N, 10)) :: 'TRIV), DB)
      else createCopyPars(_-_(N, 1),
             createCopy((qid("C" + string(N, 10)) :: 'TRIV), DB))
      fi .

  eq tupleParList(N)
    = if N == 1
      then (qid("C" + string(N, 10)) :: 'TRIV)
      else (tupleParList(_-_(N, 1)), (qid("C" + string(N, 10)) :: 'TRIV))
      fi .

  eq tupleImportList(N)
    = if N == 1
      then (including pd(qid("C" + string(N, 10)) :: 'TRIV) .)
      else (tupleImportList(_-_(N, 1))
            (including pd(qid("C" + string(N, 10)) :: 'TRIV) .))
      fi .

  eq tupleSort(N) = makeSort('Tuple, tupleSortAux(N)) .

  eq tupleSortAux(N)
    = if N == 1
      then qid("C" + string(N, 10))
      else (tupleSortAux(_-_(N, 1)), qid("C" + string(N, 10)))
      fi .

  eq tupleOps(N)
    = (tupleOpsCtor(N) tupleOpsSelectors(N, N)) .

  eq tupleOpsCtor(N)
    = (op qid("(" + tupleOpsCtorName(N) + ")") :
            tupleOpsCtorArity(N) -> tupleSort(N) [none] .) .

  eq tupleOpsCtorName(N)
    = if N == 1
      then "_"
      else "_," + tupleOpsCtorName(_-_(N, 1))
      fi .

  eq tupleOpsCtorArity(N)
    = if N == 1
      then qid("C" + string(N, 10) + "$Elt")
      else tupleOpsCtorArity(_-_(N, 1)) qid("C" + string(N, 10) + "$Elt")
      fi .

  eq tupleOpsSelectors(N, N')
    = if N == 1
      then (op qid("p" + string(N, 10) + "_") :
                 tupleSort(N') -> qid("C" + string(N, 10) + "$Elt") [none] .)
      else (tupleOpsSelectors(_-_(N, 1), N')
            (op qid("p" + string(N, 10) + "_") :
                  tupleSort(N') -> qid("C" + string(N, 10) + "$Elt") [none] .))
      fi .

  eq tupleEqSet(N)
    = tupleEqSetAux(N,
        (qid("(" + tupleOpsCtorName(N) + ")") [ tupleTermArgs(N) ])) .

  eq tupleTermArgs(N)
    = if N == 1
      then qid("V" + string(N, 10) + ":C" + string(N, 10) + "$Elt")
      else (tupleTermArgs(_-_(N, 1)),
            qid("V" + string(N, 10) + ":C" + string(N, 10) + "$Elt"))
      fi .

  eq tupleEqSetAux(N, T)
    = if N == 1
      then (eq qid("p" + string(N, 10) + "_")[T]
              = qid("V" + string(N, 10) + ":C" + string(N, 10) + "$Elt")
              [none] .)
      else (tupleEqSetAux(_-_(N, 1), T)
            (eq qid("p" + string(N, 10) + "_")[T]
               = qid("V" + string(N, 10) + ":C" + string(N, 10) + "$Elt")
               [none] .))
      fi .

*** The equations for the \texttt{header2QidList},
*** \texttt{parseModExp}, \texttt{prepHeader}, and
*** \texttt{setUpModExpDeps} functions on the $n$-tuple module
*** expression are as follows:

  eq header2Qid(TUPLE[N]) = qid("TUPLE[" + string(N, 10) + "]") .
  eq header2QidList(TUPLE[N]) = ('TUPLE '`[ qid(string(N, 10)) '`]) .

  eq prepModExp(TUPLE[N], VEPS) = TUPLE[N] .

  eq setUpModExpDeps(TUPLE[N], DB) = DB .

endfm

fmod N-POWER-EXPR is
  inc MOD-EXPR .
  pr FM-INST-EXPR-EVALUATION .
  pr FM-EVALUATION .

  vars N N' : NzNat .
  var  PDL : ParameterDeclList .
  var  DB : Database .
  var  T : Term .
  var  IL : ImportList .
  var  VEPS : Set{Tuple{ViewExpression,ViewExpression}} .
  var  X : Qid .
  var  S : Sort .

*** As for TUPLE, the equation for the \texttt{evalModExp} is reduced to the
*** creation of a new module. A module expression POWER[n]{Nat} produces a
*** module
***
*** fmod POWER[n]{X :: TRIV} is
***   inc TUPLE[n]{X, X, ..., X} .
*** endfm
***
*** which is then instantiated by the Nat view.

*** Some auxiliary functions are defined in order
*** to generate the different declarations in the module.

  op powImportList : NzNat -> ImportList .
  op powTupleImportation : NzNat -> ViewExpression .

  eq evalModExp(POWER[N], PDL, DB)
    = if unitInDb(POWER[N], DB)
      then < DB ; POWER[N] >
      else < evalModule(
               fmod POWER[N]{'X :: 'TRIV} is
                 powImportList(N)
                 sorts none .
                 none
                 none
                 none
                 none
               endfm,
               none,
               createCopy('X :: 'TRIV, DB)) ;
             POWER[N] >
      fi .

  eq powImportList(N)
    = (including TUPLE[N]{powTupleImportation(N)} .) .

  eq powTupleImportation(N)
    = if N == 1
      then 'X
      else ('X, powTupleImportation(sd(N, 1)))
      fi .

*** The equations for the \texttt{header2QidList},
*** \texttt{parseModExp}, \texttt{prepHeader}, and
*** \texttt{setUpModExpDeps} functions on the $n$-tuple module
*** expression are as follows:

  eq header2Qid(POWER[N]) = qid("POWER[" + string(N, 10) + "]") .
  eq header2QidList(POWER[N]) = ('POWER '`[ qid(string(N, 10)) '`]) .

  eq prepModExp(POWER[N], VEPS) = POWER[N] .

  eq setUpModExpDeps(POWER[N], DB) = DB .

endfm

*******************************************************************************

***
*** 8 Input/Output Processing
***

*** In this section we discuss how the preterm resulting from the call to the
*** function \texttt{metaParse} with the input and the top-level signature of
*** Full Maude is transformed into a term of sort \texttt{Module}, representing
*** a preunit or a term of sort \texttt{PreView}. In the case of commands,
*** they are evaluated giving the corresponding results in the appropriate
*** form.

***
*** 8.1 Input Parsing
***

*** Let us recall here the example presented in Section~\ref{bubbles}. Calling
*** \texttt{metaParse} with the module \texttt{NAT3} given there and the
*** signature of Full Maude presented in Section~\ref{sec:signature}, we
*** obtain the following term.

***    'fmod_is_endfm[
***       'token[{''NAT3}'Qid],
***       '__['sort_.['token[{''Nat3}'Qid]],
***           '__['op_:_->_.['token[{''s_}'Qid],
***                          'neTokenList[{''Nat3}'Qid],
***                          'token[{''Nat3}'Qid]],
***               '__['op_:`->_.['token[{''0}'Qid],
***                              'token[{''Nat3}'Qid]],
***                   'eq_=_.['bubble['__[{''s}'Qid, {''s}'Qid,
***                                       {''s}'Qid, {''0}'Qid]],
***                           'bubble[{''0}'Qid]]]]]]

*** Given each one of the subterms representing declarations in terms
*** representing modules as the previous one, the function \texttt{parseDecl}
*** generates the corresponding declaration, with no bubbles in it, and the
*** corresponding predeclaration, with the bubbles appearing in the term. For
*** example, for the term
***
***   'op_:_->_.['token[{''s_}'Qid],
***              'neTokenList[{''Nat3}'Qid],
***              'token[{''Nat3}'Qid]]
***
*** the following operator declaration is generated:
***
***   op 's_ : 'Nat3 -> 'Nat3 [none] .
***
*** Note that in this case, since the operator is declared without identity
*** element (the only place a bubble might appear), the declaration and the
*** predeclaration generated by \texttt{parseDecl} coincide.

*** In the following sections we shall see how this approach is followed for
*** declarations appearing in units and in views.

***
*** 8.1.1 Parsing of Module Declarations
***

*** The \texttt{parseDecl} function takes a term (which corresponds to a
*** declaration to be parsed), a preunit (to which the parsed declaration with
*** its bubbles in it will be added), and a unit (to which the parsed
*** declaration without bubbles will be added to build up the signature). For
*** example, a term corresponding to an unconditional equation, that is, a term
*** of the form \verb~'eq_=_.[T, T']~ will be added to the set of equations of
*** the preunit as \verb~eq T = T' .~, but nothing will be added to the unit.
*** Note that according to the signature used in the call to
*** \texttt{metaParse} (see Sections~\ref{sec:signature}
*** and~\ref{main-module}), \texttt{T} and \texttt{T'} are bubbles.
*** Declarations of sorts, subsort relations, operators, classes, subclass
*** relations, messages, and variables will be added to both of them. In the
*** case of operator declarations, identity element attributes, which in
*** general can be terms, are not included in the added declaration.

*** As in Core Maude, declarations in a module can be given in any order, and
*** therefore we follow a two-step approach consisting in first building the
*** signature to parse the bubbles, and then generating the unit without
*** bubbles in it. It could be different for other languages. For example, in
*** some languages we may be able to assume that each operator and sort has
*** been defined before being used, allowing then an incremental processing of
*** the input.

---- fmod MAYBE{X :: TRIV} is
----   sort Maybe{X} .
----   subsort X$Elt < Maybe{X} .
----   op maybe : -> Maybe{X} .
---- endfm

fmod UNIT-DECL-PARSING is
  pr DATABASE .
  pr MOVE-DOWN .
  pr FM-INST-EXPR-EVALUATION .
  pr FM-RENAMING-EXPR-EVALUATION .
  pr UNION-EXPR .
  pr N-TUPLE-EXPR .
  pr N-POWER-EXPR .
  pr DEFAULT-VALUE{Term} .
  pr META-FULL-MAUDE-SIGN .
  pr UNIT-BUBBLE-PARSING .

  vars PU U : Module .
  vars T T' T'' T''' T3 T4 : Term .
  vars QI QI' QI'' L F : Qid .
  vars QIL QIL' : QidList .
  vars S S' : Sort .
  vars SS SS' : TypeSet .
  vars TyL TyL' : TypeList .
  var  TSL : TypeSetList .
  var  AtS : AttrSet .
  vars TL TL' TL'' : TermList .
  var  Ct : Constant .
  var  VDS : VariableSet .
  vars Ty Tp : Type .
  var  N : Nat .
  var  DT : Default{Term} .

*** Similarly, auxiliary functions parsing other elements in units
*** are defined.

  op parsePreAttrs : Term Nat -> AttrSet .
  op parsePreHookList : Term -> HookList .
  op parseVars : QidList [Type] -> VariableSet .
  op parseSubsortRel : Term -> TypeListSet .
  op parseAttrDeclList : Term -> AttrDeclSet .

  eq parseSubsortRel('_<_[T, T'])
    = _l_(parseSortSet(T), parseSubsortRel(T')) .
  eq parseSubsortRel('__[T, T']) = parseSortSet('__[T, T']) .
  eq parseSubsortRel('sortToken[T]) = downQid(T) .
  eq parseSubsortRel('_`{_`}['sortToken[T], T'])
    = makeSort(downQid(T), parseParameterList(T')) .
  eq parseSubsortRel('_`{_`}['_`{_`}[T, T'], T''])
    = makeSort(parseSubsortRel('_`{_`}[T, T']), parseParameterList(T'')) .

  op unfoldOpDecl : QidList TypeList Sort AttrSet -> OpDeclSet .
  eq unfoldOpDecl((QI QIL), TyL, Ty, AtS)
    = ((op QI : TyL -> Ty [AtS] .) unfoldOpDecl(QIL, TyL, Ty, AtS)) .
  eq unfoldOpDecl(nil, TyL, Ty, AtS) = none .

  op unfoldMultipleMsgDecl : QidList TypeList Sort -> MsgDeclSet .
  eq unfoldMultipleMsgDecl((QI QIL), TyL, Ty)
    = ((msg QI : TyL -> Ty .) unfoldMultipleMsgDecl(QIL, TyL, Ty)) .
  eq unfoldMultipleMsgDecl(nil, TyL, Ty) = none .

  op unfoldSubsortRel : TypeSetList ~> SubsortDeclSet .
  eq unfoldSubsortRel(_l_((S ; SS), (S' ; SS'), TSL))
    = ((subsort S < S' .)
       unfoldSubsortRel(_l_(S, SS'))
       unfoldSubsortRel(_l_(SS, (S' ; SS')))
       unfoldSubsortRel(_l_((S' ; SS'), TSL))) .
  eq unfoldSubsortRel(_l_(SS, none)) = none .
  eq unfoldSubsortRel(_l_(none, SS)) = none .
  eq unfoldSubsortRel(SS) = none .
  eq unfoldSubsortRel(qidError(QIL)) = subsortDeclError(QIL) .

  op unfoldSubclassRel : TypeSetList ~> SubclassDeclSet .
  eq unfoldSubclassRel(_l_((S ; SS), (S' ; SS'), TSL))
    = ((subclass S < S' .)
       unfoldSubclassRel(_l_(S, SS'))
       unfoldSubclassRel(_l_(SS, (S' ; SS')))
       unfoldSubclassRel(_l_((S' ; SS'), TSL))) .
  eq unfoldSubclassRel(_l_(SS, none)) = none .
  eq unfoldSubclassRel(_l_(none, SS)) = none .
  eq unfoldSubclassRel(SS) = none .
  eq unfoldSubclassRel(qidError(QIL)) = subclassDeclError(QIL) .

  op unfoldStratDecl : QidList TypeList Sort AttrSet -> StratDeclSet .
  eq unfoldStratDecl((QI QIL), TyL, Ty, AtS)
    = ((strat QI : TyL @ Ty [AtS] .) unfoldStratDecl(QIL, TyL, Ty, AtS)) .
  eq unfoldStratDecl(nil, TyL, Ty, AtS) = none .

  eq parseVars((QI QIL), Tp)
    = (qid(string(QI) + ":" + string(Tp)) ; parseVars(QIL, Tp)) .
  eq parseVars(nil, Tp) = none .
  eq parseVars(QIL, qidError(QIL')) = variableSetError(QIL') .

  eq parsePreAttrs('__[T, T'], N)
    = (parsePreAttrs(T, N) parsePreAttrs(T', N)) .
  eq parsePreAttrs('assoc.@Attr@, N) = assoc .
  eq parsePreAttrs('associative.@Attr@, N) = assoc .
  eq parsePreAttrs('comm.@Attr@, N) = comm .
  eq parsePreAttrs('commutative.@Attr@, N) = comm .
  eq parsePreAttrs('idem.@Attr@, N) = idem .
  eq parsePreAttrs('idempotent.@Attr@, N) = idem .
  eq parsePreAttrs('id:_[T], N) = id(T) .
  eq parsePreAttrs('identity:_[T], N) = id(T) .
  eq parsePreAttrs('left`id:_[T], N) = left-id(T) .
  eq parsePreAttrs('left`identity:_[T], N) = left-id(T) .
  eq parsePreAttrs('right`id:_[T], N) = right-id(T) .
  eq parsePreAttrs('right`identity:_[T], N) = right-id(T) .
  eq parsePreAttrs('poly`(_`)[T], N) = poly(parseInt(T)) .
  eq parsePreAttrs('strat`(_`)[T], N) = strat(parseInt(T)) .
  eq parsePreAttrs('strategy`(_`)[T], N) = strat(parseInt(T)) .
  eq parsePreAttrs('frozen.@Attr@, N)
    = if N == 0
      then none
      else frozen(from 1 to N list)
      fi .
  eq parsePreAttrs('frozen`(_`)[T], N) = frozen(parseInt(T)) .
  eq parsePreAttrs('memo.@Attr@, N) = memo .
  eq parsePreAttrs('memoization.@Attr@, N) = memo .
  eq parsePreAttrs('ctor.@Attr@, N) = ctor .
  eq parsePreAttrs('constructor.@Attr@, N) = ctor .
  eq parsePreAttrs('prec_['token[T]], N) = prec(parseNat(T)) .
  eq parsePreAttrs('gather`(_`)['neTokenList[T]], N) = gather(downQidList(T)) .
  eq parsePreAttrs('special`(_`)[T], N) = special(parsePreHookList(T)) .
  eq parsePreAttrs('format`(_`)['neTokenList[T]], N) = format(downQidList(T)) .
  eq parsePreAttrs('iter.@Attr@, N) = iter .
  eq parsePreAttrs('ditto.@Attr@, N) = ditto .
  eq parsePreAttrs('config.@Attr@, N) = config .
  eq parsePreAttrs('object.@Attr@, N) = object .
  eq parsePreAttrs('msg.@Attr@, N) = msg .
  eq parsePreAttrs('message.@Attr@, N) = msg .
  eq parsePreAttrs('metadata_['token[T]], N) = metadata(downString(downQid(T))) .
  eq parsePreAttrs('nonexec.@Attr@, N) = nonexec .
  eq parsePreAttrs('variant.@Attr@, N) = variant .

  eq parsePreHookList('__[T, TL]) = parsePreHookList(T) parsePreHookList(TL) .
  eq parsePreHookList('id-hook_['token[T]]) = id-hook(downQid(T), nil) .
  eq parsePreHookList('id-hook_`(_`)['token[T], 'neTokenList[T']])
    = id-hook(downQid(T), downQidList(T')) .
  eq parsePreHookList(
       'op-hook_`(_:_->_`)[
          'token[T], 'token[T'], 'neTokenList[T''], 'token[T3]])
    = op-hook(downQid(T), downQid(T'), downTypes(T''), downQid(T3)) .
  eq parsePreHookList('op-hook_`(_:`->_`)['token[T], 'token[T'], 'token[T'']])
    = op-hook(downQid(T), downQid(T'), nil, downQid(T'')) .
  eq parsePreHookList(
       'op-hook_`(_:_~>_`)[
          'token[T], 'token[T'], 'neTokenList[T''], 'token[T3]])
    = op-hook(downQid(T), downQid(T'), downTypes(T''), downQid(T3)) .
  eq parsePreHookList('op-hook_`(_:`~>_`)['token[T], 'token[T'], 'token[T'']])
    = op-hook(downQid(T), downQid(T'), nil, downQid(T'')) .
  eq parsePreHookList('term-hook_`(_`)['token[T], T'])
    = term-hook(downQid(T), T') .

  eq parseAttrDeclList('_`,_[T, T'])
    = (parseAttrDeclList(T), parseAttrDeclList(T')) .
  eq parseAttrDeclList('_:_['token[T], T'])
    = (attr downQid(T) : parseType(T')) .

*** Given a term representing a declaration or a predeclaration, the function
*** \texttt{parseDecl} must generate and update both the unit and the preunit
*** that it takes as arguments. Note that in the case of rules, for example,
*** only a prerule is generated.

*** Since the preunit and the unit may be modified, they have to be returned as
*** a pair, which will be used to extract the corresponding arguments for the
*** following calls. Note that the \texttt{parseDecl} functions are in fact
*** partial functions. Each parsing function assumes that it is possible to
*** parse the given term.

  sort ParseDeclResult .
  op <_;_;_> : Module Module VariableSet -> ParseDeclResult .
  op preModule : ParseDeclResult -> Module .
  op unit : ParseDeclResult -> Module .
  op vars : ParseDeclResult -> VariableSet .

  eq preModule(< PU ; U ; VDS >) = PU .
  eq preModule(< unitError(QIL) ; V:[Module] ; V:[VariableSet] >) = unitError(QIL) .
  eq preModule(< V:[Module] ; unitError(QIL) ; V:[VariableSet] >) = unitError(QIL) .
  eq preModule(< V:[Module] ; V':[Module] ; variableSetError(QIL) >) = unitError(QIL) .
  eq unit(< PU ; U ; VDS >) = U .
  eq unit(< unitError(QIL) ; V':[Module] ; V:[VariableSet] >) = unitError(QIL) .
  eq unit(< V:[Module] ; unitError(QIL) ; V:[VariableSet] >) = unitError(QIL) .
  eq unit(< V:[Module] ; V':[Module] ; variableSetError(QIL) >) = unitError(QIL) .
  eq vars(< PU ; U ; VDS >) = VDS .
  eq vars(< unitError(QIL) ; V:[Module] ; V:[VariableSet] >) = variableSetError(QIL) .
  eq vars(< V:[Module] ; unitError(QIL) ; V:[VariableSet] >) = variableSetError(QIL) .
  eq vars(< V:[Module] ; V':[Module] ; variableSetError(QIL) >) = variableSetError(QIL) .

  op parseDecl : Term Module Module VariableSet -> ParseDeclResult .

*** changed 03/27/02
*** In the case of importation declarations, since internally only the
*** \texttt{including} mode is handled, all importations are generated in
*** this mode, independently of the keyword used in the input.

  eq parseDecl('inc_.[T], PU, U, VDS)
    = parseDecl('including_.[T], PU, U, VDS) .
  eq parseDecl('ex_.[T], PU, U, VDS)
    = parseDecl('extending_.[T], PU, U, VDS) .
  eq parseDecl('pr_.[T], PU, U, VDS)
    = parseDecl('protecting_.[T], PU, U, VDS) .
  eq parseDecl('including_.[T], PU, U, VDS)
    = < addImports((including parseModExp(T) .), PU) ; U ; VDS > .
  eq parseDecl('extending_.[T], PU, U, VDS)
    = < addImports((extending parseModExp(T) .), PU) ; U ; VDS > .
  eq parseDecl('protecting_.[T], PU, U, VDS)
    = < addImports((protecting parseModExp(T) .), PU) ; U ; VDS > .

  eq parseDecl('sort_.[T], PU, U, VDS) = parseDecl('sorts_.[T], PU, U, VDS) .
  eq parseDecl('sorts_.[T], PU, U, VDS)
    = < addSorts(parseSortSet(T), PU) ; addSorts(parseSortSet(T), U) ; VDS > .

  eq parseDecl('subsort_.[T], PU, U, VDS)
    = parseDecl('subsorts_.[T], PU, U, VDS) .
  eq parseDecl('subsorts_.[T], PU, U, VDS)
    = < addSubsorts(unfoldSubsortRel(parseSubsortRel(T)), PU) ;
        addSubsorts(unfoldSubsortRel(parseSubsortRel(T)), U) ; VDS > .

*** As pointed out in Section~\ref{SyntacticalRequirementsAndCaveats}, the
*** name of operators in operator declaration has to be given as a single
*** token identifier (see Section~\ref{order-sorted}). We assume that when
*** declaring a multitoken operator, its name is given as a single quoted
*** identifier in which each token is preceded by a backquote. Thus, the name
*** of an operator \verb~_(_)~, for example, is given as \verb~_`(_`)~.

  eq parseDecl('op_:`->_.['token[T], T'], PU, U, VDS)
    = < addOps((op downQid(T) : nil -> parseType(T') [none] .), PU) ;
        addOps((op downQid(T) : nil -> parseType(T') [none] .), U) ;
        VDS > .
  eq parseDecl('op_:`->_`[_`].['token[T], T', T''], PU, U, VDS)
    = < addOps(
          (op downQid(T) : nil -> parseType(T') [parsePreAttrs(T'', 0)] .),
          PU) ;
        addOps(
          (op downQid(T) : nil -> parseType(T') [parseAttrs(T'')] .),
          U) ;
        VDS > .
  eq parseDecl('op_:_->_.['token[T], T', T''], PU, U, VDS)
    = < addOps(
          (op downQid(T) : parseTypeList(T') -> parseType(T'') [none] .),
          PU) ;
        addOps(
          (op downQid(T) : parseTypeList(T') -> parseType(T'') [none] .),
          U) ;
        VDS > .
  eq parseDecl('op_:_->_`[_`].['token[T], T', T'', T3], PU, U, VDS)
    = < addOps(
          (op downQid(T) : parseTypeList(T') -> parseType(T'')
               [parsePreAttrs(T3, size(parseTypeList(T')))] .), PU) ;
        addOps(
          (op downQid(T) : parseTypeList(T') -> parseType(T'')
               [parseAttrs(T3)] .), U) ;
        VDS > .

  ceq parseDecl('op_:`->_.[F[TL], T], PU, U, VDS)
    = < PU ; U ; VDS >
    if F =/= 'token .
  ceq parseDecl('op_:`->_`[_`].[F[TL], T, T'], PU, U, VDS)
    = < PU ; U ; VDS >
    if F =/= 'token .
  ceq parseDecl('op_:_->_.[F[TL], T, T'], PU, U, VDS)
    = < PU ; U ; VDS >
    if F =/= 'token .
  ceq parseDecl('op_:_->_`[_`].[F[TL], T, T', T''], PU, U, VDS)
    = < PU ; U ; VDS >
    if F =/= 'token .

  eq parseDecl('ops_:`->_.['neTokenList[T], T'], PU, U, VDS)
    = < addOps(
          unfoldOpDecl(downTypes(T), nil, parseType(T'), none), PU) ;
        addOps(
          unfoldOpDecl(downTypes(T), nil, parseType(T'), none), U) ;
        VDS > .
  eq parseDecl('ops_:`->_`[_`].['neTokenList[T], T', T''], PU, U, VDS)
    = < addOps(
          unfoldOpDecl(downTypes(T), nil, parseType(T'),
            parsePreAttrs(T'', 0)),
          PU) ;
        addOps(
          unfoldOpDecl(downTypes(T), nil, parseType(T'),
            parseAttrs(T'')),
          U) ;
        VDS > .
  eq parseDecl('ops_:_->_.['neTokenList[T], T', T''], PU, U, VDS)
    = < addOps(
          unfoldOpDecl(downTypes(T), parseTypeList(T'),
            parseType(T''), none),
          PU) ;
        addOps(
          unfoldOpDecl(downTypes(T), parseTypeList(T'),
            parseType(T''), none),
          U) ;
        VDS > .
  eq parseDecl('ops_:_->_`[_`].['neTokenList[T], T', T'', T3], PU, U, VDS)
    = < addOps(
          unfoldOpDecl(downTypes(T), parseTypeList(T'), parseType(T''),
            parsePreAttrs(T3, size(parseTypeList(T')))), PU) ;
        addOps(
          unfoldOpDecl(downTypes(T),
            parseTypeList(T'), parseType(T''), parseAttrs(T3)), U) ;
        VDS > .

  eq parseDecl('op_:`~>_.['token[T], T'], PU, U, VDS)
    = < addOps((op downQid(T) : nil -> kind(parseType(T')) [none] .), PU) ;
        addOps((op downQid(T) : nil -> kind(parseType(T')) [none] .), U) ;
        VDS > .
  eq parseDecl('op_:`~>_`[_`].['token[T], T', T''], PU, U, VDS)
    = < addOps((op downQid(T) : nil -> kind(parseType(T'))
                    [parsePreAttrs(T'', 0)] .), PU) ;
        addOps((op downQid(T) : nil -> kind(parseType(T'))
                    [parseAttrs(T'')] .), U) ;
        VDS > .
  eq parseDecl('op_:_~>_.['token[T], T', T''], PU, U, VDS)
    = < addOps((op downQid(T) : kind(parseTypeList(T')) -> kind(parseType(T''))
                    [none] .), PU) ;
        addOps((op downQid(T) : kind(parseTypeList(T')) -> kind(parseType(T''))
                    [none] .), U) ;
        VDS > .
  eq parseDecl('op_:_~>_`[_`].['token[T], T', T'', T3], PU, U, VDS)
    = < addOps((op downQid(T) : kind(parseTypeList(T')) -> kind(parseType(T''))
                   [parsePreAttrs(T3, size(parseTypeList(T')))] .), PU) ;
        addOps((op downQid(T) : kind(parseTypeList(T')) -> kind(parseType(T''))
                   [parseAttrs(T3)] .), U) ;
        VDS > .

  ceq parseDecl('op_:`~>_.[F[TL], T], PU, U, VDS)
    = < PU ; U ; VDS >
    if F =/= 'token .
  ceq parseDecl('op_:`~>_`[_`].[F[TL], T, T'], PU, U, VDS)
    = < PU ; U ; VDS >
    if F =/= 'token .
  ceq parseDecl('op_:_~>_.[F[TL], T, T'], PU, U, VDS)
    = < PU ; U ; VDS >
    if F =/= 'token .
  ceq parseDecl('op_:_~>_`[_`].[F[TL], T, T', T''], PU, U, VDS)
    = < PU ; U ; VDS >
    if F =/= 'token .

  eq parseDecl('ops_:`~>_.['neTokenList[T], T'], PU, U, VDS)
    = < addOps(
          unfoldOpDecl(downTypes(T), nil, kind(parseType(T')), none),
          PU) ;
        addOps(
          unfoldOpDecl(downTypes(T), nil, kind(parseType(T')), none),
          U) ;
        VDS > .
  eq parseDecl('ops_:`~>_`[_`].['neTokenList[T], T', T''], PU, U, VDS)
    = < addOps(
          unfoldOpDecl(downTypes(T), nil, kind(parseType(T')),
            parsePreAttrs(T'', 0)),
          PU) ;
        addOps(
          unfoldOpDecl(downTypes(T), nil, kind(parseType(T')),
            parseAttrs(T'')), U) ;
        VDS > .
  eq parseDecl('ops_:_~>_.['neTokenList[T], T', T''], PU, U, VDS)
    = < addOps(
          unfoldOpDecl(downTypes(T), parseTypeList(T'),
            kind(parseType(T'')), none),
          PU) ;
        addOps(
          unfoldOpDecl(downTypes(T), parseTypeList(T'),
            kind(parseType(T'')), none),
          U) ;
        VDS > .
  eq parseDecl('ops_:_~>_`[_`].['neTokenList[T], T', T'', T3], PU,
       U, VDS)
    = < addOps(
          unfoldOpDecl(downTypes(T), parseTypeList(T'), parseType(T''),
            parsePreAttrs(T3, size(parseTypeList(T')))),
          PU) ;
        addOps(
          unfoldOpDecl(downTypes(T),
            parseTypeList(T'), parseType(T''), parseAttrs(T3)), U) ;
        VDS > .

  eq parseDecl('var_:_.['neTokenList[T], T'], PU, U, VDS)
    = parseDecl('vars_:_.['neTokenList[T], T'], PU, U, VDS) .
  eq parseDecl('vars_:_.['neTokenList[T], T'], PU, U, VDS)
    = < PU ; U ; (VDS ; parseVars(downQidList(T), parseType(T'))) > .

  eq parseDecl('mb_:_.['rbubble[T], 'rbubble[T']], PU, U, VDS)
    = < addMbs((mb T : getSort(breakMb(T', VDS)) [getAttrSet(breakMb(T', VDS))] .), PU) ; U ; VDS > .
  eq parseDecl('cmb_:_if_.['rbubble[T], T', 'rbubble[T'']], PU, U, VDS)
    = < addMbs(
          (cmb T : parseType(T')
             if term(pullStmtAttrOut(T'', VDS)) = 'true.Bool
             [attrSet(pullStmtAttrOut(T'', VDS))] .), PU) ; U ; VDS > .

  op breakMb : Term VariableSet -> [Tuple{Sort,AttrSet}] .
  op breakMbAux : TermList AttrSet VariableSet -> [Tuple{Sort,AttrSet}] .

  pr (2TUPLE * (op `(_`,_`) to <_`,_>, op p1_ to getSort, op p2_ to getAttrSet)) {Sort,AttrSet} .

  eq breakMb('__[TL, QI], VDS)
    = if QI == ''`].Qid
      then breakMbAux(TL, none, VDS)
      else < parseType(getTerm(metaParse(GRAMMAR, none, downQidList('__[TL, QI]), '@Sort@))), none >
      fi .
----  eq breakMb('sortToken[T], VDS) = < parseType('sortToken[T]), none > [owise] .
----  eq breakMb('_`{_`}[T, T'], VDS) = < parseType('_`{_`}[T, T']), none > [owise] .
  eq breakMb(QI, VDS) = < downQid(QI), none > [owise] .

  eq breakMbAux((TL, ''`[.Qid), AtS, VDS)
    = < parseType(getTerm(metaParse(GRAMMAR, VDS, downQidList('__[TL]), '@Sort@))), AtS > .
  eq breakMbAux((TL, QI, ''nonexec.Qid), AtS, VDS)
    = breakMbAux((TL, QI), AtS nonexec, VDS) .
  eq breakMbAux((TL, QI, ''variant.Qid), AtS, VDS)
    = breakMbAux((TL, QI), AtS variant, VDS) .
  eq breakMbAux((TL, QI, ''owise.Qid), AtS, VDS)
    = breakMbAux((TL, QI), AtS owise, VDS) .
  eq breakMbAux((TL, QI, ''otherwise.Qid), AtS, VDS)
    = breakMbAux((TL, QI), AtS owise, VDS) .
  eq breakMbAux((TL, QI, ''label.Qid, QI'), AtS, VDS)
    = if downQid(QI') :: Qid
      then breakMbAux((TL, QI), AtS label(downQid(QI')), VDS)
      else < qidError('Error: 'Invalid 'label), none >
      fi .
  eq breakMbAux((TL, QI, ''metadata.Qid, QI'), AtS, VDS)
    = if downString(downQid(QI')) :: String
      then breakMbAux((TL, QI), AtS metadata(downString(downQid(QI'))), VDS)
      else < qidError('Error: 'Invalid 'metadata), none >
      fi .
  ceq breakMbAux((TL, QI, ''`[.Qid, TL', ''print.Qid, TL''), AtS, VDS)
    = breakMbAux((TL, QI, ''`[.Qid, TL'), AtS print(printArg(TL'', VDS)), VDS)
    if printArg(TL'', VDS) : QidList .
  eq breakMbAux(TL, AtS, VDS) = < qidError('Error: 'Invalid 'sort), none > [owise] .

  op breakTermSort : Term ~> ResultPair .
  eq breakTermSort('_:_[T, T']) = {T, parseType(T')} .

  eq parseDecl('eq_=_.[T, T'], PU, U, VDS)
    = < addEqs((eq T = T' [none] .), PU) ; U ; VDS > .
  eq parseDecl('ceq_=_if_.[T, T', T''], PU, U, VDS)
    = < addEqs((ceq T = T' if T'' = 'true.Bool [none] .), PU) ; U ; VDS > .
  eq parseDecl('cq_=_if_.[T, T', T''], PU, U, VDS)
    = < addEqs((ceq T = T' if T'' = 'true.Bool [none] .), PU) ; U ; VDS > .

  eq parseDecl('rl_=>_.[T, T'], PU, U, VDS)
    = < addRls((rl T => T' [none] .), PU) ; U ; VDS > .
  eq parseDecl('crl_=>_if_.[T, T', T''], PU, U, VDS)
    = < addRls((crl T => T' if T'' = 'true.Bool [none] .), PU) ; U ; VDS > .

  eq parseDecl('class_|`.[T], PU, U, VDS)
    = parseDecl('class_.[T], PU, U, VDS) .
  eq parseDecl('class_.[T], PU, U, VDS)
    = < addClasses((class parseType(T) | none .), PU) ;
        addClasses((class parseType(T) | none .), U) ; VDS > .
  eq parseDecl('class_|_.[T, T'], PU, U, VDS)
    = < addClasses((class parseType(T) | parseAttrDeclList(T') .), PU) ;
        addClasses((class parseType(T) | parseAttrDeclList(T') .), U) ; VDS > .

  eq parseDecl('subclass_.[T], PU, U, VDS)
    = < addSubclasses(unfoldSubclassRel(parseSubsortRel(T)), PU) ;
        addSubclasses(unfoldSubclassRel(parseSubsortRel(T)), U) ; VDS > .
  eq parseDecl('subclasses_.[T], PU, U, VDS)
    = < addSubclasses(unfoldSubclassRel(parseSubsortRel(T)), PU) ;
        addSubclasses(unfoldSubclassRel(parseSubsortRel(T)), U) ; VDS > .

  eq parseDecl('msg_:_->_.['token[T], T', T''], PU, U, VDS)
    = < addMsgs((msg downQid(T) : parseTypeList(T') -> parseType(T'') .), PU)
        ;
        addMsgs((msg downQid(T) : parseTypeList(T') -> parseType(T'') .), U)
        ;
        VDS > .
  eq parseDecl('msg_:`->_.['token[T], T'], PU, U, VDS)
    = < addMsgs((msg downQid(T) : nil -> parseType(T') .), PU) ;
        addMsgs((msg downQid(T) : nil -> parseType(T') .), U) ; VDS > .
  eq parseDecl('msgs_:_->_.['neTokenList[T], T', T''], PU, U, VDS)
    = < addMsgs(unfoldMultipleMsgDecl(downQidList(T), parseTypeList(T'), parseType(T'')), PU) ;
        addMsgs(unfoldMultipleMsgDecl(downQidList(T), parseTypeList(T'), parseType(T'')), U) ;
        VDS > .
  eq parseDecl('msgs_:`->_.['neTokenList[T], T'], PU, U, VDS)
    = < addMsgs(unfoldMultipleMsgDecl(downQidList(T), nil, parseType(T')), PU) ;
        addMsgs(unfoldMultipleMsgDecl(downQidList(T), nil, parseType(T')), U) ; VDS > .

  eq parseDecl('strat_@_.['token[T], T'], PU, U, VDS)
    = < addStratDcls(strat downQid(T) : nil @ parseType(T') [none] ., PU) ;
        U ; ---- addOps(op downQid(T) : nil -> '@CallStrategy@ [none] ., U) ;
        VDS > .
  eq parseDecl('strat_:`@_`[_`].['token[T], T', T''], PU, U, VDS)
    = < addStratDcls(strat downQid(T) : nil @ parseType(T') [parseAttrs(T'')] ., PU) ;
        U ; ---- addOps(op downQid(T) : nil -> '@CallStrategy@ [parsePreAttrs(T'', 0)] ., U) ;
        VDS > .
  eq parseDecl('strat_:_@_.['token[T], T', T''], PU, U, VDS)
    = < addStratDcls(strat downQid(T) : parseTypeList(T') @ parseType(T'') [none] ., PU) ;
        U ; ---- addOps(op downQid(T) : parseTypeList(T') -> '@CallStrategy@ [none] ., U) ;
        VDS > .
  eq parseDecl('strat_:_@_`[_`].['token[T], T', T'', T3], PU, U, VDS)
    = < addStratDcls(strat downQid(T) : parseTypeList(T') @ parseType(T'') [parseAttrs(T3)] ., PU) ;
        U ; ---- addOps(op downQid(T) : parseTypeList(T') -> '@CallStrategy@ [parsePreAttrs(T3, size(parseTypeList(T')))] ., U) ;
        VDS > .
  ceq parseDecl('strat_:`@_.[F[TL], T], PU, U, VDS)
    = < PU ; U ; VDS >
    if F =/= 'token .
  ceq parseDecl('strat_:`@_`[_`].[F[TL], T, T'], PU, U, VDS)
    = < PU ; U ; VDS >
    if F =/= 'token .
  ceq parseDecl('strat_:_@_.[F[TL], T, T'], PU, U, VDS)
    = < PU ; U ; VDS >
    if F =/= 'token .
  ceq parseDecl('op_:_@_`[_`].[F[TL], T, T', T''], PU, U, VDS)
    = < PU ; U ; VDS >
    if F =/= 'token .

  eq parseDecl('strats_@_.['neTokenList[T], T'], PU, U, VDS)
    = < addStratDcls(unfoldStratDecl(downTypes(T), nil, parseType(T'), none), PU) ;
        U ; ---- addOps(unfoldOpDecl(downTypes(T), nil, '@CallStrategy@, none), U) ;
        VDS > .
  eq parseDecl('strats_@_`[_`].['neTokenList[T], T', T''], PU, U, VDS)
    = < addStratDcls(unfoldStratDecl(downTypes(T), nil, parseType(T'), parseAttrs(T'')), PU) ;
        U ; ---- addOps(unfoldOpDecl(downTypes(T), nil, '@CallStrategy@, parsePreAttrs(T'', 0)), U) ;
        VDS > .
  eq parseDecl('strats_:_@_.['neTokenList[T], T', T''], PU, U, VDS)
    = < addStratDcls(unfoldStratDecl(downTypes(T), parseTypeList(T'), parseType(T''), none), PU) ;
        U ; ---- addOps(unfoldOpDecl(downTypes(T), parseTypeList(T'), '@CallStrategy@, none), U) ;
        VDS > .
  eq parseDecl('strats_:_@_`[_`].['neTokenList[T], T', T'', T3], PU, U, VDS)
    = < addStratDcls(unfoldStratDecl(downTypes(T), parseTypeList(T'), parseType(T''), parseAttrs(T3)), PU) ;
        U ; ---- addOps(
            ----   unfoldOpDecl(downTypes(T), parseTypeList(T'), '@CallStrategy@, parsePreAttrs(T3, size(parseTypeList(T')))), U) ;
        VDS > .

  eq parseDecl('sd_:=_.[T, T'], PU, U, VDS)
    = < addStratDefs(sd T := T' [none] ., PU) ; U ; VDS > .
  eq parseDecl('csd_:=_if_.[T, T', T''], PU, U, VDS)
    = < addStratDefs(csd T := T' if T'' = 'true.Bool [none] ., PU) ; U ; VDS > .
endfm

*******************************************************************************

***
*** 8.1.2 Parsing of View Declarations
***

*** A similar approach is followed for the parsing of declarations in views.

fmod VIEW-DECL-PARSING is
  pr PRE-VIEW .
  pr VIEW .
  pr FM-UNIT .
  pr UNIT-DECL-PARSING .

  vars T T' : Term .
  var  OPDS : OpDeclSet .
  var  MDS : MsgDeclSet .
  var  M : Module .
  vars F F' : Qid .
  vars S S' : Sort .
  vars Ty Ty' : Type .
  vars TyL TyL' : TypeList .
  vars T'' T3 : Term .
  var  PV : PreView .
  var  OPD : OpDecl .
  var  OPDS' : OpDeclSet .
  var  AtS : AttrSet .
  var  MD : MsgDecl .
  var  MDS' : MsgDeclSet .
  var  VDS : OpDeclSet .
  vars StratDcls StratDcls' : StratDeclSet .
  var  StratDcl : StratDecl .

*** Operator and message name maps of the form \verb~F to F'~ are substituted
*** by an equivalent set of maps of the form \verb~F : TyL -> S to F'~. One
*** of these maps is added for each family of subsort-overloaded operators in
*** the source theory of the view.

*** The following functions \texttt{genOpMaps} and \texttt{genMsgMaps}
*** take, respectively, an operator and a message map of the form
*** \verb~F to F'~, a set of operator or message declarations, and a term of
*** sort \texttt{Module}, and return, respectively, a set of operator maps and
*** a set of message maps, with each of the members of those sTS having the
*** general form \verb~F : TyL -> S to F'~. One of these maps is generated
*** for each family of subsort-overloaded operators or messages with name
*** \texttt{F} in the module given as argument.

  op genOpMaps : OpMapping OpDeclSet Module -> OpMappingSet .
  op genMsgMaps : OpMapping MsgDeclSet Module -> OpMappingSet .
  op genStratMaps : StratMapping StratDeclSet Module -> StratMappingSet .

  op genOpMapsAux : OpDeclSet Qid -> OpMappingSet .
  op genMsgMapsAux : MsgDeclSet Qid -> OpMappingSet .
  op genStratMapsAux : StratDeclSet Qid -> StratMappingSet .

  op getOpDeclSet : Qid Module -> OpDeclSet .
  op getOpDeclSetAux : Qid OpDeclSet -> OpDeclSet .
  *** getOpDeclSet(F, U) returns the set of declarations of operators with
  *** name F in the unit U
  op getMsgDeclSet : Qid Module -> MsgDeclSet .
  op getMsgDeclSetAux : Qid MsgDeclSet -> MsgDeclSet .
  *** getMsgDeclSet(F, U) returns the set of declarations of messages with
  *** name F in the unit U
  op getStratDeclSet : Qid Module -> StratDeclSet .
  op getStratDeclSetAux : Qid StratDeclSet -> StratDeclSet .
  *** getMsgDeclSet(F, U) returns the set of declarations of messages with
  *** name F in the unit U
  op gTSubsortOverloadedFamilies : OpDeclSet OpDeclSet Module -> OpDeclSet .
  op gTSubsortOverloadedFamilies : MsgDeclSet MsgDeclSet Module -> MsgDeclSet .
  op gTSubsortOverloadedFamilies : StratDeclSet StratDeclSet Module -> StratDeclSet .
  *** gTSubsortOverloadedFamilies returns a declaration of operator or
  *** message for each family of subsort-overloaded operators or messages.
  op selectOpDeclSet : Qid OpDeclSet -> OpDeclSet .
  op selectMsgDeclSet : Qid MsgDeclSet -> MsgDeclSet .
  op selectStratDeclSet : Qid StratDeclSet -> StratDeclSet .
  *** selectOpDeclSet and selectMsgDeclSet returns, respectively, the subset
  *** of those declarations  of ops and msgs which name coincides with the
  *** qid given ar argument.
  op opFamilyIn : OpDecl OpDeclSet Module -> Bool .
  op msgFamilyIn : MsgDecl MsgDeclSet Module -> Bool .
  op stratFamilyIn : StratDecl StratDeclSet Module -> Bool .
  *** Check whether the family of the subsort-overloaded operator given as
  *** argument has already a  representative in the set of declarations given.

  eq genOpMaps(op F to F' ., OPDS, M)
    = genOpMapsAux(
         gTSubsortOverloadedFamilies(selectOpDeclSet(F, OPDS), none, M),
         F') .
  eq genMsgMaps(msg F to F' ., MDS, M)
    = genMsgMapsAux(
         gTSubsortOverloadedFamilies(selectMsgDeclSet(F, MDS), none, M),
         F') .
  eq genStratMaps(strat F to F' ., StratDcls, M)
    = genStratMapsAux(
        gTSubsortOverloadedFamilies(selectStratDeclSet(F, StratDcls), none, M),
        F') .

  eq selectOpDeclSet(F, ((op F' : TyL -> Ty [AtS] .) OPDS))
    = ((if F == F'
        then (op F' : TyL -> Ty [AtS] .)
        else none
        fi)
       selectOpDeclSet(F, OPDS)) .
  eq selectOpDeclSet(F, none) = none .

  eq selectMsgDeclSet(F, ((msg F' : TyL -> Ty .) MDS))
    = ((if F == F'
        then (msg F' : TyL -> Ty .)
        else none
        fi)
       selectMsgDeclSet(F, MDS)) .
  eq selectMsgDeclSet(F, none) = none .

  eq selectStratDeclSet(F, ((strat F' : TyL @ Ty [AtS] .) StratDcls))
    = ((if F == F'
        then (strat F' : TyL @ Ty [AtS] .)
        else none
        fi)
       selectStratDeclSet(F, StratDcls)) .
  eq selectStratDeclSet(F, none) = none .

  eq genOpMapsAux(op F : TyL -> Ty [AtS] . OPDS, F')
    = (op F : TyL -> Ty to F' . genOpMapsAux(OPDS, F')) .
  eq genOpMapsAux(none, F') = none .

  eq genMsgMapsAux(((msg F : TyL -> Ty .) MDS), F')
    = (msg F : TyL -> Ty to F' . genMsgMapsAux(MDS, F')) .
  eq genMsgMapsAux(none, F') = none .

  eq genStratMapsAux(strat F : TyL @ Ty [AtS] . StratDcls, F')
    = (strat F : TyL @ Ty to F' . genStratMapsAux(StratDcls, F')) .
  eq genStratMapsAux(none, F') = none .

  eq gTSubsortOverloadedFamilies((OPD OPDS), OPDS', M)
    = if opFamilyIn(OPD, OPDS', M)
      then gTSubsortOverloadedFamilies(OPDS, OPDS', M)
      else gTSubsortOverloadedFamilies(OPDS, (OPD OPDS'), M)
      fi .
  eq gTSubsortOverloadedFamilies(none, OPDS, M) = OPDS .

  eq gTSubsortOverloadedFamilies((MD MDS), MDS', M)
    = if msgFamilyIn(MD, MDS', M)
      then gTSubsortOverloadedFamilies(MDS, MDS', M)
      else gTSubsortOverloadedFamilies(MDS, (MD MDS'), M)
      fi .
  eq gTSubsortOverloadedFamilies(none, MDS, M) = MDS .

  eq gTSubsortOverloadedFamilies((StratDcl StratDcls), StratDcls', M)
    = if stratFamilyIn(StratDcl, StratDcls', M)
      then gTSubsortOverloadedFamilies(StratDcls, StratDcls', M)
      else gTSubsortOverloadedFamilies(StratDcls, (StratDcl StratDcls'), M)
      fi .
  eq gTSubsortOverloadedFamilies(none, StratDcls, M) = StratDcls .

  eq opFamilyIn(
       (op F : TyL -> Ty [AtS] .), ((op F' : TyL' -> Ty' [AtS] .) OPDS), M)
    = ((F == F') and-then sameKind(M, TyL, TyL')) or-else
      opFamilyIn((op F : TyL -> Ty [AtS] .), OPDS, M) .
  eq opFamilyIn((op F : TyL -> Ty [AtS] .), none, M) = false .

  eq msgFamilyIn((msg F : TyL -> Ty .), ((msg F' : TyL' -> Ty' .) MDS), M)
    = ((F == F') and-then sameKind(M, TyL, TyL'))
      or-else
      msgFamilyIn((msg F : TyL -> Ty .), MDS, M) .
  eq msgFamilyIn((msg F : TyL -> Ty .), none, M) = false .

  eq stratFamilyIn(
       (strat F : TyL @ Ty [AtS] .), ((strat F' : TyL' @ Ty' [AtS] .) StratDcls), M)
    = ((F == F') and-then sameKind(M, TyL, TyL')) or-else
      stratFamilyIn((strat F : TyL @ Ty [AtS] .), StratDcls, M) .
  eq stratFamilyIn((strat F : TyL @ Ty [AtS] .), none, M) = false .

*** In the case of views, the \texttt{parseDecl} function takes the term
*** representing the corresponding declaration and a preview in which the
*** declarations are introduced. Note that in the case of views, the approach
*** followed in the evaluation is somewhat different. The only predeclarations
*** in a preview correspond to the term premaps of sort \texttt{PreTermMap},
*** for which, in addition to solving the bubbles in them, we have to convert
*** them into term maps of sort \texttt{TermMap} associating to them the set
*** of declarations of variables in the view which are used in them (see
*** Section~\ref{view-processing}).

*** The function \texttt{parseDecl} for declarations in views takes then the
*** term representing such declaration and a preview in which the result of
*** adding the declaration will be returned. To be able to generate the sTS
*** of equivalent operator and message maps as indicated above, the function
*** takes also as parameters the sTS of declarations of operators and messages
*** in the theory part of the source theory of the view in question, and the
*** signature of such theory to make the necessary sort comparisons.

  op parseDecl : Term PreView OpDeclSet MsgDeclSet StratDeclSet Module -> PreView .

  eq parseDecl('sort_to_.[T, T'], PV, OPDS, MDS, StratDcls, M)
    = addMaps(sort parseType(T) to parseType(T') ., PV) .

  eq parseDecl('class_to_.[T, T'], PV, OPDS, MDS, StratDcls, M)
    = addMaps(class parseType(T) to parseType(T') ., PV) .

  eq parseDecl('vars_:_.['neTokenList[T], T'], PV, OPDS, MDS, StratDcls, M)
    = addVars(parseVars(downQidList(T), parseType(T')), PV).
  eq parseDecl('var_:_.['neTokenList[T], T'], PV, OPDS, MDS, StratDcls, M)
    = addVars(parseVars(downQidList(T), parseType(T')), PV).

  eq parseDecl('op_to`term_.[T, T'], PV, OPDS, MDS, StratDcls, M)
    = addMaps(op_to`term_.(T, T'), PV) .

  eq parseDecl('op_to_.['token[T], 'token[T']], PV, OPDS, MDS, StratDcls, M)
    = addMaps(genOpMaps(op downQid(T) to downQid(T') ., OPDS, M), PV) .
  eq parseDecl('op_:_->_to_.['token[T], T', T'', 'token[T3]], PV, OPDS, MDS, StratDcls, M)
    = addMaps(op downQid(T) : parseTypeList(T') -> parseType(T'') to downQid(T3) ., PV) .
----  eq parseDecl('op_:`->_to_.['token[T], T', 'token[T'']], PV, OPDS, MDS, StratDcls, M)
----    = addMaps(op downQid(T) : nil -> parseType(T') to downQid(T'') ., PV) .

  eq parseDecl('msg_to_.['token[T], 'token[T']], PV, OPDS, MDS, StratDcls, M)
    = addMaps(genMsgMaps(msg downQid(T) to downQid(T') ., MDS, M), PV) .
  eq parseDecl('msg_:_->_to_.['token[T], T', T'', 'token[T3]], PV, OPDS, MDS, StratDcls, M)
    = addMaps(msg downQid(T) : parseTypeList(T') -> parseType(T'') to downQid(T3) ., PV) .
----  eq parseDecl('msg_:`->_to_.['token[T], T', 'token[T'']], PV, OPDS, MDS, StratDcls, M)
----    = addMaps(msg downQid(T) : nil -> parseType(T') to downQid(T'') ., PV) .

  eq parseDecl('attr_._to_.[T', 'token[T], 'token[T'']], PV, OPDS, MDS, StratDcls, M)
    = addMaps(attr downQid(T) . parseType(T') to downQid(T'') ., PV) .

  eq parseDecl('strat_to`expr_.[T, T'], PV, OPDS, MDS, StratDcls, M)
    = addMaps(strat_to`expr_.(T, T'), PV) .

  eq parseDecl('strat_to_.['token[T], 'token[T']], PV, OPDS, MDS, StratDcls, M)
    = addMaps(genStratMaps(strat downQid(T) to downQid(T') ., StratDcls, M), PV) .
  eq parseDecl('strat_:_@_to_.['token[T], T', T'', 'token[T3]], PV, OPDS, MDS, StratDcls, M)
    = addMaps(strat downQid(T) : parseTypeList(T') @ parseType(T'') to downQid(T3) ., PV) .

  eq parseDecl(T, PV, OPDS, MDS, StratDcls, M) = PV [owise] .
endfm

*******************************************************************************

***
*** 8.2 Meta Pretty Printing
***

*** To be able to show to the user the modules, theories, views, and terms
*** resulting from the different commands, the built-in function
*** \texttt{meta-pretty-print} is extended in the modules in this section to
*** deal with units and views.

***
*** 8.2.1 Meta Pretty Printing of Declarations
***

*** The predefined function \texttt{meta-pretty-print} is extended in the
*** following module \texttt{DECL-META-PRETTY-PRINT} to handle any declaration
*** that can appear in a unit. Note that the following
*** \texttt{meta-pretty-print} functions, as the built-in one, return a list
*** terms---such as equations, rules,* operator declarations with an identity
*** attribute, etc.---they have been defined with a term of operator
*** declarations with an identity attribute, etc.---they have been defined
*** with a term of sort \texttt{Module} as argument. In the other cases the
*** module is not necessary.

fmod DECL-META-PRETTY-PRINT is
  pr FM-EXT-DECL .
  pr FM-O-O-DECL .
  pr FM-UNIT .
  pr CONVERSION .
  pr FM-INT-LIST .
  ----MI pr FM-VIEW-EXPR-TO-QID .
  pr META-LEVEL .

  op metaPrettyPrintStrategy : Module Strategy ~> QidList .
  op metaPrettyPrintStrategy : Module Strategy PrintOptionSet ~> QidList .
  eq metaPrettyPrintStrategy(M:Module, Strat:Strategy)
   = metaPrettyPrintStrategy(M:Module, Strat:Strategy, mixfix flat format number rat) .
  eq metaPrettyPrintStrategy(M:Module, Strat:Strategy, POs:PrintOptionSet)
   = metaPrettyPrintStrategy(M:Module, none, Strat:Strategy, POs:PrintOptionSet) .

  eq metaPrettyPrint(
       smod ME is IL sorts SS . SSDS OPDS MAS EqS RlS StratDcls StratDefs endsm,
       T,
       POs:PrintOptionSet)
   = metaPrettyPrint(
       mod ME is IL sorts SS . SSDS OPDS MAS EqS RlS endm,
       T,
       POs:PrintOptionSet) .

  op eMetaPrettyPrint : Sort -> QidList .
  op eMetaPrettyPrint : SortSet -> QidList .
  op eMetaPrettyPrint : TypeList -> QidList .
  op eMetaPrettyPrint : SubsortDeclSet -> QidList .
  op eMetaPrettyPrint : ClassDeclSet -> QidList .
  op eMetaPrettyPrint : SubclassDeclSet -> QidList .
  op eMetaPrettyPrint : Module OpDeclSet -> QidList .
  op eMetaPrettyPrintVars : VariableSet -> QidList .
  op eMetaPrettyPrint : MsgDeclSet -> QidList .
  op eMetaPrettyPrint : Module MembAxSet -> QidList .
  op eMetaPrettyPrint : Module EquationSet -> QidList .
  op eMetaPrettyPrint : Module RuleSet -> QidList .
  op eMetaPrettyPrint : Module StratDeclSet -> QidList .
  op eMetaPrettyPrint : Module StratDefSet -> QidList .
  op eMetaPrettyPrint : Module Condition -> QidList .
  op eMetaPrettyPrint : Module Term -> QidList .

  ---- error handling

  eq eMetaPrettyPrint(U, T) = metaPrettyPrint(U, T) .
  eq eMetaPrettyPrint(U, qidError(QIL)) = QIL .
  eq eMetaPrettyPrint(qidError(QIL)) = QIL .

  op eMetaPrettyPrint : Module AttrSet -> QidList .
  op eMetaPrettyPrint : IntList -> QidList .
  op eMetaPrettyPrint : AttrDeclSet -> QidList .
  op eMetaPrettyPrint : Module HookList -> QidList .

  vars QI QI' QI'' F V L : Qid .
  var  QIL : QidList .
  var  St : String .
  var  M : Module .
  var  U : Module .
  vars VE VE' : ViewExpression .
  vars SS : SortSet .
  vars S S' : Sort .
  var  TyL : TypeList .
  var  Ty : Type .
  var  SSDS : SubsortDeclSet .
  var  OPDS : OpDeclSet .
  var  AtS : AttrSet .
  var  MAS : MembAxSet .
  var  EqS : EquationSet .
  var  RlS : RuleSet .
  var  Hk : Hook .
  var  HkL : HookList .
  var  I : Int .
  var  NL : IntList .
  vars T T' T'' T3 : Term .
  var  CDS : ClassDeclSet .
  var  SCDS : SubclassDeclSet .
  var  MDS : MsgDeclSet .
  var  ADS : AttrDeclSet .
  var  Cond : Condition .
  var  K : Kind .
  var  StratDcls : StratDeclSet .
  var  StratDefs : StratDefSet .
  var  CS : CallStrategy .
  var  Strat : Strategy .
  var  TL : TermList .
  var  ME : ModuleExpression .
  var  IL : ImportList .
  var  VDS : VariableSet .

  --- eq eMetaPrettyPrint(Ty) = Ty .

  eq eMetaPrettyPrint(S)
    = if getPars(S) == empty
      then S
      else getName(S) '`{ parameterList2QidList(getPars(S)) '`}
      fi .
  eq eMetaPrettyPrint(K) = '`[ eMetaPrettyPrint(getSort(K)) '`] .

  eq eMetaPrettyPrint((S ; SS))
    = (eMetaPrettyPrint(S) eMetaPrettyPrint(SS))
    [owise] .
  eq eMetaPrettyPrint((none).SortSet) = nil .

  eq eMetaPrettyPrint(Ty TyL)
    = eMetaPrettyPrint(Ty) eMetaPrettyPrint(TyL)
    [owise] .
  eq eMetaPrettyPrint((nil).TypeList) = nil .

  eq eMetaPrettyPrint(((subsort S < S' .) SSDS))
    = ('\s '\s '\b
       'subsort '\o eMetaPrettyPrint(S) '\b
           '< '\o eMetaPrettyPrint(S') '\b '. '\o '\n
       eMetaPrettyPrint(SSDS)) .
  eq eMetaPrettyPrint((none).SubsortDeclSet) = nil .

  eq eMetaPrettyPrint(M, ((op F : TyL -> Ty [none] .) OPDS))
    = ('\s '\s
       '\b 'op '\o F '\b ': '\o eMetaPrettyPrint(TyL)
       '\b '-> '\o eMetaPrettyPrint(Ty) '\b '. '\o '\n
       eMetaPrettyPrint(M, OPDS)) .
  eq eMetaPrettyPrint(M, ((op F : TyL -> Ty [AtS] .) OPDS))
    = ('\s '\s
       '\b 'op '\o F '\b ': '\o eMetaPrettyPrint(TyL)
       '\b '-> '\o eMetaPrettyPrint(Ty) '\n
       '\s '\s '\s '\s '\b '`[ '\o eMetaPrettyPrint(M, AtS) '\b '`] '\s '. '\o '\n
       eMetaPrettyPrint(M, OPDS))
    [owise] .
  eq eMetaPrettyPrint(M, (none).OpDeclSet)  = nil .

  eq eMetaPrettyPrintVars(V ; VDS)
    = ('\s '\s '\b 'var '\o getName(V) '\b ': '\o eMetaPrettyPrint(getType(V)) '\b '. '\o '\n
       eMetaPrettyPrintVars(VDS)) .
  eq eMetaPrettyPrintVars((none).VariableSet)  = nil .

  eq eMetaPrettyPrint(M, (mb T : S [none] .) MAS)
    = ('\s '\s '\b 'mb '\o eMetaPrettyPrint(M, T) '\b ': '\o eMetaPrettyPrint(S) '\b '. '\o '\n
       eMetaPrettyPrint(M, MAS)) .
  eq eMetaPrettyPrint(M, (mb T : S [AtS] .) MAS)
    = ('\s '\s '\b 'mb '\o eMetaPrettyPrint(M, T)
                   '\b ': '\o eMetaPrettyPrint(S)
               '\s '\b '`[ '\o eMetaPrettyPrint(M, AtS) '\b '`] '\s '. '\o '\n
       eMetaPrettyPrint(M, MAS))
    [owise] .
  eq eMetaPrettyPrint(M, (cmb T : S if Cond [none] .) MAS)
    = ('\s '\s '\b 'cmb '\o eMetaPrettyPrint(M, T)
                   '\b ': '\o eMetaPrettyPrint(S) '\n
       '\s '\s '\s '\s '\b 'if '\o eMetaPrettyPrint(M, Cond) '\b '. '\o '\n
       eMetaPrettyPrint(M, MAS)) .
  eq eMetaPrettyPrint(M, (cmb T : S if Cond [AtS] .) MAS)
    = ('\s '\s '\b 'cmb '\o eMetaPrettyPrint(M, T)
                   '\b ': '\o eMetaPrettyPrint(S) '\n
       '\s '\s '\s '\s '\b 'if '\o eMetaPrettyPrint(M, Cond)
           '\s '\b '`[ '\o eMetaPrettyPrint(M, AtS) '\b '`] '\s '. '\o '\n
       eMetaPrettyPrint(M, MAS))
    [owise] .
  eq eMetaPrettyPrint(M, (none).MembAxSet) = nil .

  eq eMetaPrettyPrint(M, ((eq T = T' [none] .) EqS))
    = ('\s '\s '\b 'eq '\s '\o eMetaPrettyPrint(M, T) '\n
       '\s '\s '\s '\s '\b '= '\s '\o eMetaPrettyPrint(M, T') '\b '\s '. '\n
       '\o
       eMetaPrettyPrint(M, EqS)) .
  eq eMetaPrettyPrint(M, ((eq T = T' [AtS] .) EqS))
    = ('\s '\s '\b 'eq '\s '\o eMetaPrettyPrint(M, T) '\n
       '\s '\s '\s '\s '\b '= '\s '\o eMetaPrettyPrint(M, T')
           '\s '\b '`[ '\o eMetaPrettyPrint(M, AtS) '\b '`] '\s '. '\o '\n
       eMetaPrettyPrint(M, EqS))
    [owise] .
  eq eMetaPrettyPrint(M, ((ceq T = T' if Cond [none] .) EqS))
    = ('\s '\s '\b 'ceq '\s '\o eMetaPrettyPrint(M, T) '\n
       '\s '\s '\s '\s '\b '= '\s '\o eMetaPrettyPrint(M, T') '\n
       '\s '\s '\s '\s '\b 'if '\o '\s eMetaPrettyPrint(M, Cond) '\b '\s '. '\o '\n
       eMetaPrettyPrint(M, EqS)) .
  eq eMetaPrettyPrint(M, ((ceq T = T' if Cond [AtS] .) EqS))
    = ('\s '\s '\b 'ceq '\s '\o eMetaPrettyPrint(M, T) '\n
       '\s '\s '\s '\s '\b '= '\s '\o eMetaPrettyPrint(M, T') '\n
       '\s '\s '\s '\s '\b 'if '\o '\s eMetaPrettyPrint(M, Cond)
           '\s '\b '`[ '\o eMetaPrettyPrint(M, AtS) '\b '`] '\s '. '\o '\n
       eMetaPrettyPrint(M, EqS))
    [owise] .
  eq eMetaPrettyPrint(M, (none).EquationSet) = nil .

  eq eMetaPrettyPrint(M, ((rl T => T' [none] .) RlS))
    = ('\s '\s '\b 'rl '\s '\o eMetaPrettyPrint(M, T) '\n
       '\s '\s '\s '\s '\b '=> '\o '\s eMetaPrettyPrint(M, T') '\b '\s '. '\n '\o
       eMetaPrettyPrint(M, RlS)) .
  eq eMetaPrettyPrint(M, ((rl T => T' [AtS] .) RlS))
    = ('\s '\s '\b 'rl '\s '\o eMetaPrettyPrint(M, T) '\n
       '\s '\s '\s '\s '\b '=> '\o '\s eMetaPrettyPrint(M, T')
           '\s '\b '`[ '\o eMetaPrettyPrint(M, AtS) '\b '`] '\s '. '\o '\n
       eMetaPrettyPrint(M, RlS))
    [owise] .
  eq eMetaPrettyPrint(M, ((crl T => T' if Cond [none] .) RlS))
    = ('\s '\s '\b 'crl '\s '\o eMetaPrettyPrint(M, T) '\n
       '\s '\s '\s '\s '\b '=> '\o '\s eMetaPrettyPrint(M, T') '\n
       '\s '\s '\s '\s '\b 'if '\o '\s eMetaPrettyPrint(M, Cond) '\b '\s '. '\o '\n
       eMetaPrettyPrint(M, RlS)) .
  eq eMetaPrettyPrint(M, ((crl T => T' if Cond [AtS] .) RlS))
    = ('\s '\s '\b 'crl '\s '\o eMetaPrettyPrint(M, T) '\n
       '\s '\s '\s '\s '\b '=> '\o '\s eMetaPrettyPrint(M, T') '\n
       '\s '\s '\s '\s '\b 'if '\o '\s eMetaPrettyPrint(M, Cond)
           '\s '\b '`[ '\o eMetaPrettyPrint(M, AtS) '\b '`] '\s '. '\o '\n
       eMetaPrettyPrint(M, RlS))
    [owise] .
  eq eMetaPrettyPrint(M, (none).RuleSet) = nil .

  eq eMetaPrettyPrint(M, ((strat F : TyL @ Ty [none] .) StratDcls))
    = ('\s '\s
       '\b 'strat '\o F '\b ': '\o eMetaPrettyPrint(TyL)
       '\b '@ '\o eMetaPrettyPrint(Ty) '\b '. '\o '\n
       eMetaPrettyPrint(M, StratDcls)) .
  eq eMetaPrettyPrint(M, ((strat F : TyL @ Ty [AtS] .) StratDcls))
    = ('\s '\s
       '\b 'strat '\o F '\b ': '\o eMetaPrettyPrint(TyL)
       '\b '@ '\o eMetaPrettyPrint(Ty) '\n
       '\s '\s '\s '\s '\b '`[ '\o eMetaPrettyPrint(M, AtS) '\b '`] '\s '. '\o '\n
       eMetaPrettyPrint(M, StratDcls))
    [owise] .
  eq eMetaPrettyPrint(M, (none).StratDeclSet)  = nil .

  eq eMetaPrettyPrint(M, ((sd CS := Strat [none] .) StratDefs))
    = ('\s '\s '\b 'sd '\s '\o metaPrettyPrintStrategy(M, CS) '\n
       '\s '\s '\s '\s '\b ':= '\o '\s metaPrettyPrintStrategy(M, Strat) '\b '\s '. '\n '\o
       eMetaPrettyPrint(M, StratDefs)) .
  eq eMetaPrettyPrint(M, ((sd CS := Strat [AtS] .) StratDefs))
    = ('\s '\s '\b 'sd '\s '\o eMetaPrettyPrint(M, CS) '\n
       '\s '\s '\s '\s '\b ':= '\o '\s metaPrettyPrintStrategy(M, Strat)
           '\s '\b '`[ '\o eMetaPrettyPrint(M, AtS) '\b '`] '\s '. '\o '\n
       eMetaPrettyPrint(M, StratDefs))
    [owise] .
  eq eMetaPrettyPrint(M, ((csd CS := Strat if Cond [none] .) StratDefs))
    = ('\s '\s '\b 'csd '\s '\o eMetaPrettyPrint(M, CS) '\n
       '\s '\s '\s '\s '\b ':= '\o '\s metaPrettyPrintStrategy(M, Strat) '\n
       '\s '\s '\s '\s '\b 'if '\o '\s eMetaPrettyPrint(M, Cond) '\b '\s '. '\o '\n
       eMetaPrettyPrint(M, StratDefs)) .
  eq eMetaPrettyPrint(M, ((csd CS := Strat if Cond [AtS] .) StratDefs))
    = ('\s '\s '\b 'csd '\s '\o eMetaPrettyPrint(M, CS) '\n
       '\s '\s '\s '\s '\b ':= '\o '\s metaPrettyPrintStrategy(M, Strat) '\n
       '\s '\s '\s '\s '\b 'if '\o '\s eMetaPrettyPrint(M, Cond)
           '\s '\b '`[ '\o eMetaPrettyPrint(M, AtS) '\b '`] '\s '. '\o '\n
       eMetaPrettyPrint(M, StratDefs))
    [owise] .
  eq eMetaPrettyPrint(M, (none).StratDefSet) = nil .

  op eMetaPrettyPrint : Module CallStrategy -> QidList .
  eq eMetaPrettyPrint(M, F[[TL]]) = F '`[ '`[ eMetaPrettyPrint(M, TL) '`] '`] .

  op eMetaPrettyPrint : Module TermList -> QidList .
  eq eMetaPrettyPrint(M, (T, TL)) = metaPrettyPrint(M, T) '`, eMetaPrettyPrint(M, TL) .
  eq eMetaPrettyPrint(M, (empty).TermList) = nil .

  eq eMetaPrettyPrint(M, T = T' /\ Cond)
    = (eMetaPrettyPrint(M, T) '\b '= '\o eMetaPrettyPrint(M, T') '\b
      '/\ '\o eMetaPrettyPrint(M, Cond))
    [owise] .
  eq eMetaPrettyPrint(M, T : S /\ Cond)
    = (eMetaPrettyPrint(M, T) '\b ': '\o eMetaPrettyPrint(S) '\b
      '/\ '\o eMetaPrettyPrint(M, Cond))
    [owise] .
  eq eMetaPrettyPrint(M, T := T' /\ Cond)
    = (eMetaPrettyPrint(M, T) '\b ':= '\o eMetaPrettyPrint(M, T') '\b
      '/\ '\o eMetaPrettyPrint(M, Cond))
    [owise] .
  eq eMetaPrettyPrint(M, T => T' /\ Cond)
    = (eMetaPrettyPrint(M, T) '\b '=> '\o eMetaPrettyPrint(M, T') '\b
      '/\ '\o eMetaPrettyPrint(M, Cond))
    [owise] .
  eq eMetaPrettyPrint(M, T = T')
    = (eMetaPrettyPrint(M, T) '\b '= '\o eMetaPrettyPrint(M, T')) .
  eq eMetaPrettyPrint(M, T : S)
    = (eMetaPrettyPrint(M, T) '\b ': '\o eMetaPrettyPrint(S)) .
  eq eMetaPrettyPrint(M, T := T')
    = (eMetaPrettyPrint(M, T) '\b ':= '\o eMetaPrettyPrint(M, T')) .
  eq eMetaPrettyPrint(M, T => T')
    = (eMetaPrettyPrint(M, T) '\b '=> '\o eMetaPrettyPrint(M, T')) .
  eq eMetaPrettyPrint(M, (nil).EqCondition) = nil .

  eq eMetaPrettyPrint(M, (assoc AtS))
    = ('\b 'assoc '\o eMetaPrettyPrint(M, AtS)) .
  eq eMetaPrettyPrint(M, (comm AtS))
    = ('\b 'comm '\o eMetaPrettyPrint(M, AtS)) .
  eq eMetaPrettyPrint(M, (memo AtS))
    = ('\b 'memo '\o eMetaPrettyPrint(M, AtS)) .
  eq eMetaPrettyPrint(M, (idem AtS))
    = ('\b 'idem '\o eMetaPrettyPrint(M, AtS)) .
  eq eMetaPrettyPrint(M, (id(T) AtS))
    = ('\b 'id: '\o eMetaPrettyPrint(M, T) eMetaPrettyPrint(M, AtS)) .
  eq eMetaPrettyPrint(M, (right-id(T) AtS))
    = ('\b 'right 'id: '\o eMetaPrettyPrint(M, T) eMetaPrettyPrint(M, AtS)) .
  eq eMetaPrettyPrint(M, (left-id(T) AtS))
    = ('\b 'left 'id: '\o eMetaPrettyPrint(M, T) eMetaPrettyPrint(M, AtS)) .
  eq eMetaPrettyPrint(M, (poly(NL) AtS))
    = ('\b 'poly '`( '\o eMetaPrettyPrint(NL) '\b '`)
       '\o eMetaPrettyPrint(M, AtS)) .
  eq eMetaPrettyPrint(M, (strat(NL) AtS))
    = ('\b 'strat '`( '\o eMetaPrettyPrint(NL) '\b '`)
       '\o eMetaPrettyPrint(M, AtS)) .
  eq eMetaPrettyPrint(M, (memo AtS))
    = ('\b 'memo '\o eMetaPrettyPrint(M, AtS)) .
  eq eMetaPrettyPrint(M, (prec(I) AtS))
    = ('\b 'prec '\o eMetaPrettyPrint(I) eMetaPrettyPrint(M, AtS)) .
  eq eMetaPrettyPrint(M, (gather(QIL) AtS))
    = ('\b 'gather '\o '`( QIL '`) eMetaPrettyPrint(M, AtS)) .
  eq eMetaPrettyPrint(M, (format(QIL) AtS))
    = ('\b 'format '\o '`( QIL '`) eMetaPrettyPrint(M, AtS)) .
  eq eMetaPrettyPrint(M, (ctor AtS))
    = ('\b 'ctor '\o eMetaPrettyPrint(M, AtS)) .
  eq eMetaPrettyPrint(M, (frozen(NL) AtS))
    = ('\b 'frozen '`( '\o eMetaPrettyPrint(NL) '\b '`)
       '\o eMetaPrettyPrint(M, AtS)) .
  eq eMetaPrettyPrint(M, (iter AtS))
    = ('\b 'iter '\o eMetaPrettyPrint(M, AtS)) .
  eq eMetaPrettyPrint(M, (special(HkL) AtS))
    = ('\b 'special '`( '\o eMetaPrettyPrint(M, HkL) '\b '`)
       '\o eMetaPrettyPrint(M, AtS)) .
  eq eMetaPrettyPrint(M, (config AtS))
    = ('\b 'config '\o eMetaPrettyPrint(M, AtS)) .
  eq eMetaPrettyPrint(M, (object AtS))
    = ('\b 'object '\o eMetaPrettyPrint(M, AtS)) .
  eq eMetaPrettyPrint(M, (msg AtS))
    = ('\b 'msg '\o eMetaPrettyPrint(M, AtS)) .

  eq eMetaPrettyPrint(M, (label(QI) AtS))
    = ('\b 'label '\o QI '\b '\o eMetaPrettyPrint(M, AtS)) .
  eq eMetaPrettyPrint(M, (metadata(St) AtS))
    = ('\b 'metadata '\o qid("\"" + St + "\"") '\b
       '\o eMetaPrettyPrint(M, AtS)) .
  eq eMetaPrettyPrint(M, (nonexec AtS))
    = ('\b 'nonexec '\o eMetaPrettyPrint(M, AtS)) .
  eq eMetaPrettyPrint(M, (variant AtS))
    = ('\b 'variant '\o eMetaPrettyPrint(M, AtS)) .
  eq eMetaPrettyPrint(M, (owise AtS))
    = ('\b 'owise '\o eMetaPrettyPrint(M, AtS)) .
  eq eMetaPrettyPrint(M, (print(QIL) AtS))
    = ('\b 'print QIL '\o eMetaPrettyPrint(M, AtS)) .

  eq eMetaPrettyPrint(M, (none).AttrSet) = nil .

  ceq eMetaPrettyPrint(M, (Hk HkL))
    = (eMetaPrettyPrint(M, Hk) eMetaPrettyPrint(M, HkL))
    if HkL =/= nil .
  eq eMetaPrettyPrint(M, id-hook(QI, nil)) = ('\b 'id-hook '\o QI) .
  eq eMetaPrettyPrint(M, id-hook(QI, QIL))
    = ('\b 'id-hook '\o QI '\b '`( '\o QIL '\b '`) '\o )
    [owise] .
  eq eMetaPrettyPrint(M, op-hook(QI, QI', nil, QI''))
    = ('\b 'op-hook '\o QI '\b '`( '\o QI' ': '~> QI'' '\b '`) '\o) .
  eq eMetaPrettyPrint(M, op-hook(QI, QI', QIL, QI''))
    = ('\b 'op-hook '\o QI '\b '`( '\o QI' ': QIL '~> QI'' '\b '`) '\o)
    [owise] .
  eq eMetaPrettyPrint(M, term-hook(QI, T))
    = ('\b 'term-hook '\o QI '\b '`( '\o eMetaPrettyPrint(M, T) '\b '`) '\o) .

  eq eMetaPrettyPrint((I NL)) = (qid(string(I, 10)) eMetaPrettyPrint(NL)) .
  eq eMetaPrettyPrint((nil).NatList) = nil .

  eq eMetaPrettyPrint((class S | ADS .) CDS)
    = ((if ADS == none
        then ('\s '\s '\b 'class '\o eMetaPrettyPrint(S) '\b '. '\o '\n)
        else ('\s '\s '\b 'class '\o eMetaPrettyPrint(S) '\b '| '\o eMetaPrettyPrint(ADS) '\b '. '\o '\n)
        fi)
       eMetaPrettyPrint(CDS)) .
  eq eMetaPrettyPrint((none).ClassDeclSet) = nil .

  eq eMetaPrettyPrint((subclass S < S' .) SCDS)
    = ('\s '\s '\b 'subclass '\o eMetaPrettyPrint(S) '\b
           '< '\o eMetaPrettyPrint(S') '\b '. '\o '\n
       eMetaPrettyPrint(SCDS)) .
  eq eMetaPrettyPrint((none).SubclassDeclSet) = nil .

  eq eMetaPrettyPrint((msg F : TyL -> Ty .) MDS)
    = ('\s '\s '\b 'msg '\o F '\b ': '\o eMetaPrettyPrint(TyL) '\b '-> '\o eMetaPrettyPrint(Ty) '\b '. '\o '\n
       eMetaPrettyPrint(MDS)) .
  eq eMetaPrettyPrint((none).MsgDeclSet) = nil .

  eq eMetaPrettyPrint(((attr F : S), ADS))
    = (F '\b ': '\o eMetaPrettyPrint(S) '\b '`, '\o '\s eMetaPrettyPrint(ADS))
    [owise] .
  eq eMetaPrettyPrint((attr F : S)) = (F '\b ': '\o eMetaPrettyPrint(S)) .
  eq eMetaPrettyPrint((none).AttrDeclSet) = nil .

endfm

*******************************************************************************

***
*** 8.2.2 Meta Pretty Printing of Modules
***

*** In the following module, the \texttt{meta-pretty-print} function is
*** defined on sort \texttt{Module}.

fmod UNIT-META-PRETTY-PRINT is
  pr FM-UNIT .
  pr FM-RENAMING-EXPR-EVALUATION .
  pr DECL-META-PRETTY-PRINT .

  op eMetaPrettyPrint : Module Module -> QidList .

  op eMetaPrettyPrint : Module Module -> QidList .
  op eMetaPrettyPrint : Header -> QidList .
  op eMetaPrettyPrint : ParameterDeclList -> QidList .
  op eMetaPrettyPrint : ImportList -> QidList .

  var  M : Module .
  vars QI F F' L L' : Qid .
  var  QIL : QidList .
  var  ME : ModuleExpression .
  vars S S' : Sort .
  var  Ty : Type .
  var  TyL : TypeList .
  var  SS : SortSet .
  var  PD : ParameterDecl .
  var  PDL : ParameterDeclList .
  vars IL IL' : ImportList .
  var  SSDS : SubsortDeclSet .
  var  OPDS : OpDeclSet .
  var  MAS : MembAxSet .
  var  EqS : EquationSet .
  var  RlS : RuleSet .
  var  CDS : ClassDeclSet .
  var  SCDS : SubclassDeclSet .
  var  MDS : MsgDeclSet .
  var  U : Module .
  var  AtS : AttrSet .
  var  MN : ModuleName .
  var  StratDcls : StratDeclSet .
  var  StratDefs : StratDefSet .

  ceq eMetaPrettyPrint(ME)
    = if QI == '`) or QI == '`] or QI == '`}
      then QIL QI '\s
      else QIL QI
      fi
    if QIL QI := header2QidList(ME) .

  eq eMetaPrettyPrint(W:[Module], unitError(QIL)) = QIL .
  eq eMetaPrettyPrint(unitError(QIL), noModule) = QIL .
  eq eMetaPrettyPrint(noModule, noModule) = nil .
  eq eMetaPrettyPrint(M, mod ME is IL sorts SS . SSDS OPDS MAS EqS RlS endm)
    = ('\b
       'mod '\o eMetaPrettyPrint(ME) '\b 'is '\o '\n
          eMetaPrettyPrint(IL)
          (if SS == none
           then nil
           else ('\s '\s '\b 'sorts '\o eMetaPrettyPrint(SS) '\b '. '\o '\n)
           fi)
          eMetaPrettyPrint(SSDS)
          eMetaPrettyPrint(M, OPDS)
          eMetaPrettyPrint(M, MAS)
          eMetaPrettyPrint(M, EqS)
          eMetaPrettyPrint(M, RlS)
       '\b 'endm '\o '\n) .
  eq eMetaPrettyPrint(M, mod ME{PDL} is IL sorts SS . SSDS OPDS MAS EqS RlS endm)
    = ('\b
       'mod '\o eMetaPrettyPrint(ME) (if PDL == nil
                                      then nil
                                      else '`{ eMetaPrettyPrint(PDL) '`} '\s
                                      fi) '\b 'is '\o '\n
          eMetaPrettyPrint(IL)
          (if SS == none
           then nil
           else ('\s '\s '\b 'sorts '\o eMetaPrettyPrint(SS) '\b '. '\o '\n)
           fi)
          eMetaPrettyPrint(SSDS)
          eMetaPrettyPrint(M, OPDS)
          eMetaPrettyPrint(M, MAS)
          eMetaPrettyPrint(M, EqS)
          eMetaPrettyPrint(M, RlS)
       '\b 'endm '\o '\n) .
  eq eMetaPrettyPrint(M, th MN is IL sorts SS . SSDS OPDS MAS EqS RlS endth)
    = ('\b
       'th '\o eMetaPrettyPrint(MN) '\b 'is '\o '\n
          eMetaPrettyPrint(IL)
          (if SS == none
           then nil
           else ('\s '\s '\b 'sorts '\o eMetaPrettyPrint(SS) '\b '. '\o '\n)
           fi)
          eMetaPrettyPrint(SSDS)
          eMetaPrettyPrint(M, OPDS)
          eMetaPrettyPrint(M, MAS)
          eMetaPrettyPrint(M, EqS)
          eMetaPrettyPrint(M, RlS)
       '\b 'endth '\o '\n) .
  eq eMetaPrettyPrint(M, fmod ME is IL sorts SS . SSDS OPDS MAS EqS endfm)
    = ('\b
       'fmod '\o eMetaPrettyPrint(ME) '\b 'is '\o '\n
           eMetaPrettyPrint(IL)
           (if SS == none
            then nil
            else ('\s '\s '\b 'sorts '\o eMetaPrettyPrint(SS) '\b '. '\o '\n)
            fi)
           eMetaPrettyPrint(SSDS)
           eMetaPrettyPrint(M, OPDS)
           eMetaPrettyPrint(M, MAS)
           eMetaPrettyPrint(M, EqS)
       '\b 'endfm '\o '\n) .
  eq eMetaPrettyPrint(M, fmod ME{PDL} is IL sorts SS . SSDS OPDS MAS EqS endfm)
    = ('\b
       'fmod '\o eMetaPrettyPrint(ME) (if PDL == nil
                                       then nil
                                       else '`{ eMetaPrettyPrint(PDL) '`} '\s
                                       fi) '\b 'is '\o '\n
           eMetaPrettyPrint(IL)
           (if SS == none
            then nil
            else ('\s '\s '\b 'sorts '\o eMetaPrettyPrint(SS) '\b '. '\o '\n)
            fi)
           eMetaPrettyPrint(SSDS)
           eMetaPrettyPrint(M, OPDS)
           eMetaPrettyPrint(M, MAS)
           eMetaPrettyPrint(M, EqS)
       '\b 'endfm '\o '\n) .
  eq eMetaPrettyPrint(M, fth MN is IL sorts SS . SSDS OPDS MAS EqS endfth)
    = ('\b
       'fth '\o eMetaPrettyPrint(MN) '\b 'is '\o '\n
          eMetaPrettyPrint(IL)
          (if SS == none
           then nil
           else ('\s '\s '\b 'sorts '\o eMetaPrettyPrint(SS) '\b '. '\o '\n)
           fi)
          eMetaPrettyPrint(SSDS)
          eMetaPrettyPrint(M, OPDS)
          eMetaPrettyPrint(M, MAS)
          eMetaPrettyPrint(M, EqS)
       '\b 'endfth '\o '\n) .
  eq eMetaPrettyPrint(M,
       omod ME is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom)
    = ('\b
       'omod '\o eMetaPrettyPrint(ME) '\b 'is '\o '\n
          eMetaPrettyPrint(IL)
          (if SS == none
           then nil
           else ('\s '\s '\b 'sorts '\o eMetaPrettyPrint(SS) '\b '. '\o '\n )
           fi)
          eMetaPrettyPrint(SSDS) eMetaPrettyPrint(CDS)
          eMetaPrettyPrint(SCDS) eMetaPrettyPrint(M, OPDS)
          eMetaPrettyPrint(MDS) eMetaPrettyPrint(M, MAS)
          eMetaPrettyPrint(M, EqS) eMetaPrettyPrint(M, RlS)
       '\b 'endom '\o '\n) .
  eq eMetaPrettyPrint(M, omod ME{PDL} is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom)
    = ('\b
       'omod '\o eMetaPrettyPrint(ME) (if PDL == nil
                                       then nil
                                       else ('`{ eMetaPrettyPrint(PDL) '`} '\s)
                                       fi) '\b 'is '\o '\n
          eMetaPrettyPrint(IL)
          (if SS == none
           then nil
           else ('\s '\s '\b 'sorts '\o eMetaPrettyPrint(SS) '\b '. '\o '\n )
           fi)
          eMetaPrettyPrint(SSDS) eMetaPrettyPrint(CDS)
          eMetaPrettyPrint(SCDS) eMetaPrettyPrint(M, OPDS)
          eMetaPrettyPrint(MDS) eMetaPrettyPrint(M, MAS)
          eMetaPrettyPrint(M, EqS) eMetaPrettyPrint(M, RlS)
       '\b 'endom '\o '\n) .
  eq eMetaPrettyPrint(M, oth MN is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth)
    = ('\b
       'oth '\o eMetaPrettyPrint(MN) '\b 'is '\o '\n
          eMetaPrettyPrint(IL)
          (if SS == none
           then nil
           else ('\s '\s '\b 'sorts '\o eMetaPrettyPrint(SS) '\b '. '\o '\n )
           fi)
          eMetaPrettyPrint(SSDS) eMetaPrettyPrint(CDS)
          eMetaPrettyPrint(SCDS) eMetaPrettyPrint(M, OPDS)
          eMetaPrettyPrint(MDS) eMetaPrettyPrint(M, MAS)
          eMetaPrettyPrint(M, EqS) eMetaPrettyPrint(M, RlS) '\n '\b
       'endoth '\o '\n) .
  eq eMetaPrettyPrint(M, smod ME is IL sorts SS . SSDS OPDS MAS EqS RlS StratDcls StratDefs endsm)
    = ('\b
       'smod '\o eMetaPrettyPrint(ME) '\b 'is '\o '\n
          eMetaPrettyPrint(IL)
          (if SS == none
           then nil
           else ('\s '\s '\b 'sorts '\o eMetaPrettyPrint(SS) '\b '. '\o '\n)
           fi)
          eMetaPrettyPrint(SSDS)
          eMetaPrettyPrint(M, OPDS)
          eMetaPrettyPrint(M, MAS)
          eMetaPrettyPrint(M, EqS)
          eMetaPrettyPrint(M, RlS)
          eMetaPrettyPrint(M, StratDcls)
          eMetaPrettyPrint(M, StratDefs)
       '\b 'endsm '\o '\n) .
 eq eMetaPrettyPrint(M, smod ME{PDL} is IL sorts SS . SSDS OPDS MAS EqS RlS StratDcls StratDefs endsm)
   = ('\b
      'smod '\o eMetaPrettyPrint(ME) (if PDL == nil
                                     then nil
                                     else '`{ eMetaPrettyPrint(PDL) '`} '\s
                                     fi) '\b 'is '\o '\n
         eMetaPrettyPrint(IL)
         (if SS == none
          then nil
          else ('\s '\s '\b 'sorts '\o eMetaPrettyPrint(SS) '\b '. '\o '\n)
          fi)
         eMetaPrettyPrint(SSDS)
         eMetaPrettyPrint(M, OPDS)
         eMetaPrettyPrint(M, MAS)
         eMetaPrettyPrint(M, EqS)
         eMetaPrettyPrint(M, RlS)
         eMetaPrettyPrint(M, StratDcls)
         eMetaPrettyPrint(M, StratDefs)
      '\b 'endsm '\o '\n) .
 eq eMetaPrettyPrint(M, sth MN is IL sorts SS . SSDS OPDS MAS EqS RlS StratDcls StratDefs endsth)
   = ('\b
      'sth '\o eMetaPrettyPrint(MN) '\b 'is '\o '\n
         eMetaPrettyPrint(IL)
         (if SS == none
          then nil
          else ('\s '\s '\b 'sorts '\o eMetaPrettyPrint(SS) '\b '. '\o '\n)
          fi)
         eMetaPrettyPrint(SSDS)
         eMetaPrettyPrint(M, OPDS)
         eMetaPrettyPrint(M, MAS)
         eMetaPrettyPrint(M, EqS)
         eMetaPrettyPrint(M, RlS)
         eMetaPrettyPrint(M, StratDcls)
         eMetaPrettyPrint(M, StratDefs)
      '\b 'endsth '\o '\n) .

  eq eMetaPrettyPrint((including ME .) IL)
    = ('\s '\s '\b 'including '\o eMetaPrettyPrint(ME) '\b '. '\o '\n
       eMetaPrettyPrint(IL)) .
  eq eMetaPrettyPrint((extending ME .) IL)
    = ('\s '\s '\b 'extending '\o eMetaPrettyPrint(ME) '\b '. '\o '\n
       eMetaPrettyPrint(IL)) .
  eq eMetaPrettyPrint((protecting ME .) IL)
    = ('\s '\s '\b 'protecting '\o eMetaPrettyPrint(ME) '\b '. '\o '\n
       eMetaPrettyPrint(IL)) .
  eq eMetaPrettyPrint((protecting pd(QI :: ME) .) IL)
    = eMetaPrettyPrint(IL) .
  eq eMetaPrettyPrint((nil).ImportList) = nil .

  eq eMetaPrettyPrint((QI :: ME, PDL))
    = (QI '::  eMetaPrettyPrint(ME) '`, eMetaPrettyPrint(PDL))
    [owise] .
  eq eMetaPrettyPrint((QI :: ME)) = (QI '::  eMetaPrettyPrint(ME)) .
  eq eMetaPrettyPrint((nil).ParameterDeclList) = (nil).QidList .

  op eMetaPrettyPrint : ModuleExpression -> QidList .
  eq eMetaPrettyPrint(QI + ME:ModuleExpression)
    = QI '+ eMetaPrettyPrint(ME:ModuleExpression) .
  eq eMetaPrettyPrint(QI * (RnS:RenamingSet))
    = QI '* '\s '`( renamingSet2QidList(RnS:RenamingSet) '`) .
  eq eMetaPrettyPrint(pd(PD)) = eMetaPrettyPrint(PD) .

  op renamingSet2QidList : RenamingSet -> QidList .
  eq renamingSet2QidList(((op F to F' [AtS]), RS:RenamingSet))
    = if AtS == none
      then ('op F 'to F' '`, '\s renamingSet2QidList(RS:RenamingSet))
      else ('op F 'to F' '\s '`[ attrSet2QidList(AtS) '`] '`, '\s
            renamingSet2QidList(RS:RenamingSet))
      fi
    [owise] .
  eq renamingSet2QidList((op F to F' [AtS]))
    = if AtS == none
      then ('op F 'to F')
      else ('op F 'to F' '\s '`[ attrSet2QidList(AtS) '`])
      fi .
  eq renamingSet2QidList(((op F : TyL -> Ty to F' [AtS]), RS:RenamingSet))
    = if AtS == none
      then ('op F ': typeList2QidList(TyL) '-> Ty 'to F' '`,
            '\s renamingSet2QidList(RS:RenamingSet))
      else ('op F ': typeList2QidList(TyL) '-> Ty 'to F'
            '`[ attrSet2QidList(AtS) '`] '`,
            '\s renamingSet2QidList(RS:RenamingSet))
      fi
    [owise] .
  eq renamingSet2QidList((op F : TyL -> Ty to F' [AtS]))
    = if AtS == none
      then ('op F ': typeList2QidList(TyL) '-> Ty 'to F')
      else ('op F ': typeList2QidList(TyL) '-> Ty 'to F'
            '`[ attrSet2QidList(AtS) '`])
      fi .
  eq renamingSet2QidList(((sort S to S'), RS:RenamingSet))
    = ('sort S 'to S' '`, '\s
       renamingSet2QidList(RS:RenamingSet))
    [owise] .
  eq renamingSet2QidList((sort S to S')) = ('sort S 'to S') .

  eq renamingSet2QidList(((label L to L'), RS:RenamingSet))
    = ('label L 'to L' '`, '\s renamingSet2QidList(RS:RenamingSet))
    [owise] .
  eq renamingSet2QidList((label L to L')) = ('label L 'to L') .
endfm

*******************************************************************************

*** The function \texttt{meta-pretty-print} on units is defined recursively,
*** calling the \texttt{meta-pretty-print} functions for the different
*** declarations in the unit defined in module \texttt{DECL-META-PRETTY-PRINT}.

***
*** 8.2.3 Meta Pretty Printing of Maps and Views
***

*** We define in the following module the function \texttt{meta-pretty-print}
*** on maps.

fmod MAP-SET-META-PRETTY-PRINT is
  pr DECL-META-PRETTY-PRINT .
  pr FM-FMAP .
  pr FM-UNIT .

  op eMetaPrettyPrint : RenamingSet -> QidList .

  var  MAP : Renaming .
  var  MAPS : RenamingSet .
  vars QI QI' F F' L L' : Qid .
  var  AtS : AttrSet .
  vars S S' : Sort .
  var  Ty : Type .
  var  TyL : TypeList .

  eq eMetaPrettyPrint((MAP, MAPS))
    = (eMetaPrettyPrint(MAP) '`, '\s '\s eMetaPrettyPrint(MAPS))
    [owise] .
  eq eMetaPrettyPrint((none).RenamingSet) = nil .

  eq eMetaPrettyPrint(op F to F' [AtS])
    = if AtS == none
      then ('\b 'op '\o F '\b 'to '\o F')
      else ('\b 'op F '\b 'to '\o F' '\b
            '`[ '\o eMetaPrettyPrint(noModule, AtS) '\b '`] '\o)
           *** In a map there should not be attributes requiring a module
      fi .
  eq eMetaPrettyPrint(op F : TyL -> Ty to F' [AtS])
    = if AtS == none
      then ('\b 'op '\o F '\b ':
            '\o eMetaPrettyPrint(TyL) '\b '-> '\o eMetaPrettyPrint(Ty)
            '\b 'to '\o F')
      else ('\b 'op '\o F '\b ':
            '\o eMetaPrettyPrint(TyL) '\b '-> '\o eMetaPrettyPrint(Ty)
            '\b 'to '\o F'
            '\b '`[ '\o eMetaPrettyPrint(noModule, AtS) '\b '`] '\o)
           *** In a map there should not be attributes requiring a module
      fi .
  eq eMetaPrettyPrint(sort S to S')
    = ('\b 'sort '\o eMetaPrettyPrint(S) '\b 'to '\o eMetaPrettyPrint(S')) .
  eq eMetaPrettyPrint(label L to L') = ('\b 'label '\o L '\b 'to '\o L') .
  eq eMetaPrettyPrint(class S to S')
    = ('\b 'class '\o eMetaPrettyPrint(S) '\b 'to '\o eMetaPrettyPrint(S')) .
  eq eMetaPrettyPrint(attr QI . S to QI')
    = ('\b 'attr '\o eMetaPrettyPrint(S) '\b '. '\o QI '\b 'to '\o QI') .
  eq eMetaPrettyPrint(msg F to F') = ('\b 'msg '\o F '\b 'to '\o F') .
  eq eMetaPrettyPrint(msg F : TyL -> Ty to F')
    = ('\b 'msg '\o F '\b ':
       '\o eMetaPrettyPrint(TyL) '\b '-> '\o eMetaPrettyPrint(Ty)
       '\b 'to '\o F') .

endfm

*******************************************************************************

*** Finally, in the \texttt{VIEW-META-PRETTY-PRINT} module, the
*** \texttt{meta-pretty-print} function is defined on views.


fmod VIEW-META-PRETTY-PRINT is
  pr DATABASE .
  pr MAP-SET-META-PRETTY-PRINT .
  pr FM-RENAMING-SET-APPL-ON-UNIT .
  pr UNIT-META-PRETTY-PRINT .

  op eMetaPrettyPrint : Database View -> QidList .
  op eMetaPrettyPrint : ViewExpression -> QidList .
  op eMetaPrettyPrint : ModuleExpression ModuleExpression Database SortMappingSet
       SortMappingSet OpMappingSet -> QidList .
  op eMetaPrettyPrint : ModuleExpression ModuleExpression Database OpMappingSet
       SortMappingSet OpMappingSet -> QidList .
  op eMetaPrettyPrint : ModuleExpression ModuleExpression Database StratMappingSet
       SortMappingSet OpMappingSet -> QidList .
  op eMetaPrettyPrint1 : ModuleExpression ModuleExpression Database SortMapping
       SortMappingSet OpMappingSet -> QidList .
  op eMetaPrettyPrint1 : ModuleExpression ModuleExpression Database OpMapping
       SortMappingSet OpMappingSet -> QidList .
  op eMetaPrettyPrint1 : ModuleExpression ModuleExpression Database StratMapping
       SortMappingSet OpMappingSet -> QidList .

  vars QI QI' F F' : Qid .
  vars S S' : Sort .
  var  TyL : TypeList .
  var  Ty : Type .
  var  QIL : QidList .
  var  DB : Database .
  vars ME ME' : ModuleExpression .
  var  SM : SortMapping .
  var  OM : OpMapping .
  var  TM : StratMapping .
  vars SMS SMS' : SortMappingSet .
  vars OMS OMS' : OpMappingSet .
  vars TMS TMS' : StratMappingSet .
  vars T T' : Term .
  var  PDL : ParameterDeclList .
  vars VE VE' : ViewExpression .
  var  DT : Default{Term} .
  var  CS : CallStrategy .
  var  Strat : Strategy .

  ceq eMetaPrettyPrint(DB, view VE from ME to ME' is SMS OMS TMS endv)
    = ('\b 'view '\o
                 QIL QI
                 if QI == '`) then '\s else nil fi
              '\b 'from '\o eMetaPrettyPrint(ME)
              '\b 'to '\o eMetaPrettyPrint(ME') '\b 'is '\o '\n
       if SMS =/= none then '\s '\s eMetaPrettyPrint(ME, ME', DB, SMS, SMS, OMS) else nil fi
       if OMS =/= none then '\s '\s eMetaPrettyPrint(ME, ME', DB, OMS, SMS, OMS) else nil fi
       if TMS =/= none then '\s '\s eMetaPrettyPrint(ME, ME', DB, TMS, SMS, OMS) else nil fi
       '\b 'endv '\o '\n)
    if QIL QI := eMetaPrettyPrint(VE) .
  ceq eMetaPrettyPrint(DB, view VE{PDL} from ME to ME' is SMS OMS TMS endv)
    = ('\b 'view '\o
                 QIL QI
                 (if PDL == nil
                  then if QI == '`) then '\s else nil fi
                  else '`{ eMetaPrettyPrint(PDL) '`} '\s
                  fi)
              '\b 'from '\o eMetaPrettyPrint(ME)
              '\b 'to '\o eMetaPrettyPrint(ME') '\b 'is '\o '\n
       if OMS =/= none then eMetaPrettyPrint(ME, ME', DB, SMS, SMS, OMS) else nil fi
       if OMS =/= none then eMetaPrettyPrint(ME, ME', DB, OMS, SMS, OMS) else nil fi
       if TMS =/= none then eMetaPrettyPrint(ME, ME', DB, TMS, SMS, OMS) else nil fi
       '\b 'endv '\o '\n )
    if QIL QI := eMetaPrettyPrint(VE) .
  eq eMetaPrettyPrint(DB, viewError(QIL)) = QIL .

  ceq eMetaPrettyPrint(QI) = QI if not QI :: Type .
  ceq eMetaPrettyPrint(((VE, VE')))
    = eMetaPrettyPrint(VE) '`, '\s eMetaPrettyPrint(VE')
    if VE =/= nil /\ VE' =/= nil .
  eq eMetaPrettyPrint(QI{VE}) = QI '`{ eMetaPrettyPrint(VE) '`} '\s .

  eq eMetaPrettyPrint(ME, ME', DB, SM SMS, SMS', OMS')
    = ('\s '\s eMetaPrettyPrint1(ME, ME', DB, SM, SMS', OMS') '\n
       eMetaPrettyPrint(ME, ME', DB, SMS, SMS', OMS')) .
  eq eMetaPrettyPrint(ME, ME', DB, OM OMS, SMS', OMS')
    = ('\s '\s eMetaPrettyPrint1(ME, ME', DB, OM, SMS', OMS') '\n
       eMetaPrettyPrint(ME, ME', DB, OMS, SMS', OMS')) .
  eq eMetaPrettyPrint(ME, ME', DB, TM TMS, SMS', OMS')
    = ('\s '\s eMetaPrettyPrint1(ME, ME', DB, TM, SMS', OMS') '\n
       eMetaPrettyPrint(ME, ME', DB, TMS, SMS', OMS')) .
  eq eMetaPrettyPrint(ME, ME', DB, (none).SortMappingSet, SMS, OMS) = nil .
  eq eMetaPrettyPrint(ME, ME', DB, (none).OpMappingSet, SMS, OMS) = nil .
  eq eMetaPrettyPrint(ME, ME', DB, (none).StratMappingSet, SMS, OMS) = nil .

  eq eMetaPrettyPrint1(ME, ME', DB, op_to`term_.(T, T'), SMS, OMS)
    = ('\b 'op '\o eMetaPrettyPrint(getFlatModule(ME, DB), T) '\b 'to
               'term '\o eMetaPrettyPrint(getFlatModule(ME', DB), T') '\b '. '\o) .
----  eq eMetaPrettyPrint1(ME, ME', DB, op_to`term_.(T, T'), SMS, OMS)
----    = ('op eMetaPrettyPrint(T) '\b 'to 'term '\o eMetaPrettyPrint(T') '. '\n) .
  eq eMetaPrettyPrint1(ME, ME', DB, op F to F' ., SMS, OMS)
    = ('\b 'op '\o F '\b 'to '\o F' '\b '. '\o) .
  eq eMetaPrettyPrint1(ME, ME', DB, op F : TyL -> Ty to F' ., SMS, OMS)
    = ('\b 'op '\o F '\b ':
       '\o eMetaPrettyPrint(TyL) '\b '-> '\o eMetaPrettyPrint(Ty)
       '\b 'to '\o F' 'b '. '\o) .
  eq eMetaPrettyPrint1(ME, ME', DB, sort S to S' ., SMS, OMS)
    = ('\b 'sort '\o eMetaPrettyPrint(S) '\b 'to '\o eMetaPrettyPrint(S') 'b '. '\o) .
  eq eMetaPrettyPrint1(ME, ME', DB, class S to S' ., SMS, OMS)
    = ('\b 'class '\o eMetaPrettyPrint(S) '\b 'to '\o eMetaPrettyPrint(S') 'b '. '\o) .
  eq eMetaPrettyPrint1(ME, ME', DB, attr QI . S to QI' ., SMS, OMS)
    = ('\b 'attr '\o eMetaPrettyPrint(S) '\b '. '\o QI '\b 'to '\o QI' 'b '. '\o) .
  eq eMetaPrettyPrint1(ME, ME', DB, msg F to F' ., SMS, OMS)
    = ('\b 'msg '\o F '\b 'to '\o F' 'b '. '\o) .
  eq eMetaPrettyPrint1(ME, ME', DB, msg F : TyL -> Ty to F' ., SMS, OMS)
    = ('\b 'msg '\o F '\b ':
       '\o eMetaPrettyPrint(TyL) '\b '-> '\o eMetaPrettyPrint(Ty)
       '\b 'to '\o F' 'b '. '\o) .

  eq eMetaPrettyPrint1(ME, ME', DB, strat_to`expr_.(CS, Strat), SMS, OMS)
    = ('\b 'strat '\o metaPrettyPrintStrategy(getFlatModule(ME, DB), CS) '\b 'to
               'expr '\o metaPrettyPrintStrategy(getFlatModule(ME', DB), Strat) '\b '. '\o) .
  eq eMetaPrettyPrint1(ME, ME', DB, strat F to F' ., SMS, OMS)
    = ('\b 'strat '\o F '\b 'to '\o F' 'b '. '\o) .
  eq eMetaPrettyPrint1(ME, ME', DB, strat F : TyL @ Ty to F' ., SMS, OMS)
    = ('\b 'strat '\o F
       if TyL == nil then nil else '\b ': '\o eMetaPrettyPrint(TyL) fi
       '\b '@ '\o eMetaPrettyPrint(Ty)
       '\b 'to '\o F' 'b '. '\o) .
endfm

*******************************************************************************

***
*** 8.3 Input Processing
***

*** The processing functions presented in the following modules are in charge
*** of taking each term generated by the \texttt{metaParse} function and,
*** after transforming it into an element of the data types \texttt{Module} or
*** \texttt{View}, or generating some output, returning the database resulting
*** from introducing in it such a term. We shall see in
*** Section~\ref{database-handling} how the appropriate function is called
*** after having performed a first analysis of the term, in which it is
*** detected whether the input corresponds to a unit, view, or command. In the
*** cases of units and views the processing is quite similar. After a
*** preprocessing of the term, the function \texttt{parseDecl} is called with
*** each of the subterms representing declarations, resulting in units or
*** views with the parsed declarations in it.

***
*** 8.3.1 Module Processing
***

*** The processing of a term resulting from the parsing of some input
*** corresponding to a unit is accomplished by the \texttt{procModule} function.
*** This function takes as arguments a term of sort \texttt{Term}, which
*** represents some preunit, and a database. The function then enters into the
*** given database the unit obtained from the transformation of such term
*** into a term of sort \texttt{Module}.

fmod UNIT-PROCESSING is
  pr DATABASE .
  pr UNIT-DECL-PARSING .
  pr FM-EVALUATION .
  pr FM-RENAMING-SET-APPL-ON-UNIT .
  pr META-FULL-MAUDE-SIGN .
  pr FM-MOD-EXP-PARSING .

  vars QI F X : Qid .
  var  M : Module .
  vars PU PU' U U' : Module .
  vars DB DB' : Database .
  vars T T' T'' T3 : Term .
  var  TL : TermList .
  vars PL PL' PL'' : ParameterList .
  var  PDL : ParameterDeclList .
  var  IL IL' : ImportList .
  var  ME : ModuleExpression .
  var  S : Sort .
  var  SS : SortSet .
  var  ME' : ModuleExpression .
  var  VMAPS : RenamingSet .
  var  B : Bool .
  var  VDS : VariableSet .
  var  QIL : QidList .
  var  PDR : ParseDeclResult .
  var  DT : Default{Term} .

*** The \texttt{parseParList} takes a term representing a list of parameters
*** and returns the corresponding list.

  op parseParList : Term -> ParameterDeclList .
  eq parseParList('_::_['token[T], T']) = downQid(T) :: parseModExp(T') .
  eq parseParList('_`,_[T, T']) = (parseParList(T), parseParList(T')) .

*** All the operators declared as constructors of sort \texttt{PreModule} in
*** the signature of Full Maude, given in Appendix~\ref{signature-full-maude},
*** are declared with two arguments, namely, the name, or name and interface,
*** of the unit, and the list of declarations of such units. The function
*** \texttt{procModule3} is called with the term corresponding to the name, or
*** name and interface, of the module as first argument, the term corresponding
*** to the set of declarations as second argument, and an empty module of the
*** appropriate type, in which the different declarations will be accumulated,
*** as third argument.

*** The task of the function \texttt{procModule4} is then to make a second
*** level parsing of the input, building up, simultaneously, the preunit
*** represented in the term passed as argument, and the unit resulting from the
*** declarations without bubbles. This unit without bubbles will be used by the
*** \texttt{evalPreModule} function to build the signature with which to
*** analyze the bubbles in the preunit (see Section~\ref{evaluation}).

*** The case of parameterized modules requires a special treatment of the
*** parameters. These parameters are evaluated and are added as submodules in
*** the appropriate way.

*** When the last declaration is parsed, the function \texttt{evalPreModule} is
*** called with the preunit (the top module with bubbles) as first argument,
*** the empty copy of it as second argument, the top module without bubbles as
*** third argument, and the database.

*** Note that the \texttt{procModule} function adds a declaration importing the
*** module \texttt{CONFIGURATION+}, presented in
*** Section~\ref{non-built-in-predefined}, to the object-oriented modules, and
*** that \texttt{procModule4} adds a declaration importing the built-in module
*** \texttt{BOOL} to all modules.

  op procModule : Term Database -> Database .
  ***  moved to MOD-EXPR-EVAL to solve dependency
  ***  op procModule : Qid Database -> Database .
  op procModule2 : Term Term Database -> Database .
  op procModule2 : Term Database -> Database .
  op procModule3 : Term Term Term Module Database -> Database .
  op procModule3 : Term Term Module Database -> Database .
  op procModule4 : Term Term Module Module VariableSet Database -> Database .
  op procModule4 : Term Module Module VariableSet Database -> Database .

  *** When recompiling a module, it's called with a Qid, and it's
  *** not reentered into the database.

  ceq procModule(QI, DB)
    = if DT == null
      then evalModule(U, VDS, DB)
      else procModule2(DT, DB)
      fi
    if < DT ; VDS ; U > := getTermModule(QI, DB) .
  eq procModule(T, DB) = procModule2(T, T, DB) .

  *** procModule2 just calls procModule3 with the name and the declarations of
  *** the module, and an empty unit of the right type.

  eq procModule2(T, 'fmod_is_endfm[T', T''], DB)
    = procModule3(T, T', T'', emptyFModule, DB) .
  eq procModule2(T, 'obj_is_endo[T', T''], DB)
    = procModule3(T, T', T'', emptyFModule, DB) .
  eq procModule2(T, 'obj_is_jbo[T', T''], DB)
    = procModule3(T, T', T'', emptyFModule, DB) .
  eq procModule2(T, 'mod_is_endm[T', T''], DB)
    = procModule3(T, T', T'', emptySModule, DB) .
  eq procModule2(T, 'omod_is_endom[T', T''], DB)
    = procModule3(T, T', T'',
        addImports((including 'CONFIGURATION+ .),
          emptyOModule),
        DB) .
  eq procModule2(T, 'smod_is_endsm[T', T''], DB)
    = procModule3(T, T', T'', emptyStratModule, DB) .
  eq procModule2(T, 'fth_is_endfth[T', T''], DB)
    = procModule3(T, T', T'', emptyFTheory, DB) .
  eq procModule2(T, 'th_is_endth[T', T''], DB)
    = procModule3(T, T', T'', emptySTheory, DB) .
  eq procModule2(T, 'oth_is_endoth[T', T''], DB)
    = procModule3(T, T', T'',
        addImports((including 'CONFIGURATION+ .),
          emptyOTheory),
        DB) .
  eq procModule2(T, 'sth_is_endsth[T', T''], DB)
    = procModule3(T, T', T'', emptyStratTheory, DB) .

  eq procModule2('fmod_is_endfm[T, T'], DB)
    = procModule3(T, T', emptyFModule, DB) .
  eq procModule2('obj_is_endo[T, T'], DB)
    = procModule3(T, T', emptyFModule, DB) .
  eq procModule2('obj_is_jbo[T, T'], DB)
    = procModule3(T, T', emptyFModule, DB) .
  eq procModule2('mod_is_endm[T, T'], DB)
    = procModule3(T, T', emptySModule, DB) .
  eq procModule2('omod_is_endom[T, T'], DB)
    = procModule3(T, T',
        addImports((including 'CONFIGURATION+ .),
          emptyOModule),
        DB) .
  eq procModule2('smod_is_endsm[T, T'], DB)
    = procModule3(T, T', emptyStratModule, DB) .
  eq procModule2('fth_is_endfth[T, T'], DB)
    = procModule3(T, T', emptyFTheory, DB) .
  eq procModule2('th_is_endth[T, T'], DB)
    = procModule3(T, T', emptySTheory, DB) .
  eq procModule2('oth_is_endoth[T, T'], DB)
    = procModule3(T, T',
        addImports((including 'CONFIGURATION+ .),
          emptyOTheory),
        DB) .
  eq procModule2('sth_is_endsth[T, T'], DB)
    = procModule3(T, T', emptyStratTheory, DB) .

  *** procModule3 evaluates the name of the module and calls procModule4
  *** with the declarations, two empty units (one to contain the declarations
  *** with bubbles and another one the declarations without bubbles), and
  *** a set of op decls initialy empty in which to store the variables

  ceq procModule3(T, 'token[T'], T'', U, DB)
    = procModule4(T, T'', setName(U, QI), setName(U, QI), none, DB)
    if QI := downQid(T') .
  ceq procModule3(T, '_`{_`}['token[T'], T''], T3, U, DB)
    = procModule4(T, T3, setPars(setName(U, QI), parseParList(T'')),
        setName(U, QI), none, DB)
    if QI := downQid(T') .

  ceq procModule3('token[T], T', U, DB)
    = procModule4(T', setName(U, QI), setName(U, QI), none, DB)
    if QI := downQid(T) .
  ceq procModule3('_`{_`}['token[T], T'], T'', U, DB)
    = procModule4(T'', setPars(setName(U, QI), parseParList(T')),
        setName(U, QI), none, DB)
    if QI := downQid(T) .

  *** procModule4 parses one by one each of the declarations in the module.
  *** Note that is parseDecl that adds the parsed declaration to the right
  *** place. When it is done, it calls evalPreModule with the resulting
  *** preModule-unit-vars triple.

  ceq procModule4(T, '__[T', T''], PU, U, VDS, DB)
    = procModule4(T, T'', preModule(PDR), unit(PDR), vars(PDR), DB)
    if PDR := parseDecl(T', PU, U, VDS) .
  ceq procModule4(T, F[TL], PU, U, VDS, DB)
    = evalPreModule(preModule(PDR), unit(PDR), vars(PDR),
        insTermModule(getHeader(U), T, DB))
    if F =/= '__
       /\ PDR := parseDecl(F[TL], PU, U, VDS) .
  eq procModule4(T, T', unitError(QIL), V:[Module], V:[VariableSet], DB)
    = warning(DB, QIL) .
  eq procModule4(T, T', V:[Module], unitError(QIL), V:[VariableSet], DB)
    = warning(DB, QIL) .
  eq procModule4(T, T', V:[Module], V':[Module], variableSetError(QIL), DB)
    = warning(DB, QIL) .
  eq procModule4(T, F[TL], PU, U, VDS, DB)
    = warning(DB,'Error: 'no 'parse 'for F 'declaration '\n)
    [owise] .

  ceq procModule4('__[T, T'], PU, U, VDS, DB)
    = procModule4(T', preModule(PDR), unit(PDR), vars(PDR), DB)
    if PDR := parseDecl(T, PU, U, VDS) .
  ceq procModule4(F[TL], PU, U, VDS, DB)
    = evalPreModule(preModule(PDR), unit(PDR), vars(PDR), DB)
    if F =/= '__
       /\ PDR := parseDecl(F[TL], PU, U, VDS) .
  eq procModule4(T, unitError(QIL), U, VDS, DB) = warning(DB, QIL) .
  eq procModule4(T, PU, unitError(QIL), VDS, DB) = warning(DB, QIL) .
  eq procModule4(T, PU, U, variableSetError(QIL), DB) = warning(DB, QIL) .
  eq procModule4(F[TL], PU, U, VDS, DB)
    = warning(DB,'Error: 'no 'parse 'for F 'declaration '\n)
    [owise] .

endfm

*******************************************************************************

***
*** 8.3.2 View Processing
***

*** A similar process is followed for views. Note that in case of operator
*** maps going to derived terms we have bubbles, which will have to be treated
*** using the signatures of the appropriate modules.

fmod VIEW-PROCESSING is
  pr UNIT-PROCESSING .
  pr VIEW-DECL-PARSING .
  pr VIEW-BUBBLE-PARSING .

  vars QI X F : Qid .
  var  QIL : QidList .
  vars T T' T'' T3 T4 : Term .
  var  M : Module .
  var  VE : ViewExpression .
  var  V : View .
  vars PV PV' : PreView .
  vars ME ME' : ModuleExpression .
  vars DB DB' : Database .
  var  DB? : [Database] .
  vars OPDS : OpDeclSet .
  var  VDS VDS' VDS''  : VariableSet .
  var  MDS : MsgDeclSet .
  var  StratDcls : StratDeclSet .
  var  TL : TermList .
  vars PDL PDL' : ParameterDeclList .
  var  H : Header .
  var  IL : ImportList .
  var  SMS : SortMappingSet .
  var  OMS : OpMappingSet .
  var  TMS : StratMappingSet .

*** As the functions \texttt{getThSorts} and \texttt{getThClasses}
*** presented in Section~\ref{instantiation}, the functions
*** \texttt{getThOpDeclSet} and \texttt{getThMsgDeclSet} return, respectively,
*** the set of declarations of operators, and the set of declarations of
*** messages in the theory part of the structure of the module given as
*** argument.

  op getThOpDeclSet : Header Database -> OpDeclSet .
  op getThMsgDeclSet : Header Database -> MsgDeclSet .
  op getThStratDeclSet : Header Database -> StratDeclSet .

  op getThOpDeclSetAux : ImportList Database -> OpDeclSet .
  op getThMsgDeclSetAux : ImportList Database -> MsgDeclSet .
  op getThStratDeclSetAux : ImportList Database -> StratDeclSet .

  eq getThOpDeclSet(ME, DB)
    = if theory(getTopModule(ME, DB))
      then (getThOpDeclSetAux(getImports(getTopModule(ME, DB)), DB)
            getOps(getTopModule(ME, DB)))
      else none
      fi .

  eq getThOpDeclSetAux(((including ME .) IL), DB)
    = (getThOpDeclSet(ME, DB) getThOpDeclSetAux(IL, DB)) .
  eq getThOpDeclSetAux(((extending ME .) IL), DB)
    = (getThOpDeclSet(ME, DB) getThOpDeclSetAux(IL, DB)) .
  eq getThOpDeclSetAux(((protecting ME .) IL), DB)
    = (getThOpDeclSet(ME, DB) getThOpDeclSetAux(IL, DB)) .
  eq getThOpDeclSetAux(nil, DB) = none .

  eq getThMsgDeclSet(ME, DB)
    = if theory(getTopModule(ME, DB))
      then (getThMsgDeclSetAux(getImports(getTopModule(ME, DB)), DB)
            getMsgs(getTopModule(ME, DB)))
      else none
      fi .

  eq getThMsgDeclSetAux(((including ME .) IL), DB)
    = (getThMsgDeclSet(ME, DB) getThMsgDeclSetAux(IL, DB)) .
  eq getThMsgDeclSetAux(((extending ME .) IL), DB)
    = (getThMsgDeclSet(ME, DB) getThMsgDeclSetAux(IL, DB)) .
  eq getThMsgDeclSetAux(((protecting ME .) IL), DB)
    = (getThMsgDeclSet(ME, DB) getThMsgDeclSetAux(IL, DB)) .
  eq getThMsgDeclSetAux(nil, DB) = none .

  eq getThStratDeclSet(ME, DB)
    = if theory(getTopModule(ME, DB))
      then (getThStratDeclSetAux(getImports(getTopModule(ME, DB)), DB)
            getStratDcls(getTopModule(ME, DB)))
      else none
      fi .

  eq getThStratDeclSetAux(((including ME .) IL), DB)
    = (getThStratDeclSet(ME, DB) getThStratDeclSetAux(IL, DB)) .
  eq getThStratDeclSetAux(((extending ME .) IL), DB)
    = (getThStratDeclSet(ME, DB) getThStratDeclSetAux(IL, DB)) .
  eq getThStratDeclSetAux(((protecting ME .) IL), DB)
    = (getThStratDeclSet(ME, DB) getThStratDeclSetAux(IL, DB)) .
  eq getThStratDeclSetAux(nil, DB) = none .

*** The processing of terms representing previews accomplished by the function
*** \texttt{procView} is quite similar to the one accomplished by
*** \texttt{procModule} on terms representing preunits. The algorithms followed
*** are also quite similar. Both proceed recursively on the list of
*** declarations, accumulating them in a preunit or in a preview.

*** The solving of bubbles in views requires the signatures of the source and
*** target units extended, respectively, with the declarations of variables in
*** the view and with the mappings of these declarations. As we shall see in
*** Section~\ref{databaseADT}, the signatures of the built-in modules are not
*** accesible at the metalevel, and thus built-in modules cannot be used
*** directly as arguments of built-in functions. Thus, to be able to use them
*** as targTS of views, a `dummy' module is created importing the
*** corresponding predefined module. The source and target module expressions
*** of the view are evaluated before the view processing itself starts.

*** As we saw in Section~\ref{view-decl-parsing}, parsing of terms representing
*** operator and message maps requires the set of operator and message
*** declarations in the theory part of the source theory.

  op procPars : ParameterDeclList Database -> Database .

  eq procPars((X :: ME, PDL), DB)
    = procPars(PDL, createCopy((X :: ME), database(evalModExp(ME, DB)))) .
  eq procPars((nil).ParameterDeclList, DB) = DB .

  op procView : Term Database -> Database .
  op procView2 : Term Database -> Database .
  op procView : Term PreView Database -> Database .
  op procViewAux : Term PreView OpDeclSet MsgDeclSet StratDeclSet Module Database -> Database .

  eq procView(QI, DB)
    = procView2(getTermView(QI, DB), DB) .

  eq procView2('view_from_to_is_endv['token[T], T', T'', T3], DB)
    = procView(T3,
          emptyPreView(downQid(T), parseModExp(T'), parseModExp(T'')),
          DB) .
  eq procView2('view_from_to_is_endv['_`{_`}['token[T], T'], T'', T3, T4], DB)
    = procView(T4,
        setPars(
          emptyPreView(downQid(T), parseModExp(T''), parseModExp(T3)),
          parseParList(T')),
        procPars(parseParList(T'), DB)) .

  eq procView('view_from_to_is_endv['token[T], T', T'', T3], DB)
    = procView(T3,
        emptyPreView(downQid(T), parseModExp(T'), parseModExp(T'')),
        insertTermView(downQid(T),
          'view_from_to_is_endv['token[T], T', T'', T3], DB)) .
  eq procView('view_from_to_is_endv['_`{_`}['token[T], T'], T'', T3, T4], DB)
    = procView(T4,
        setPars(
          emptyPreView(downQid(T), parseModExp(T''), parseModExp(T3)),
          parseParList(T')),
        procPars(parseParList(T'),
          insertTermView(downQid(T),
            'view_from_to_is_endv['_`{_`}['token[T], T'], T'', T3, T4],
            DB))) .

  ceq procView(V, DB)
    = insertView(V, DB')
    if DB' := database(evalModExp(getFrom(V), nil, database(evalModExp(getTo(V), getPars(V), DB)))) .

  ceq procView(T, PV, DB)
    = procViewAux(T, PV,
        getThOpDeclSet(ME, DB?),
        getThMsgDeclSet(ME, DB?),
        getThStratDeclSet(ME, DB?),
        getFlatModule(ME, DB?),
        DB?)
    if preview_from_to_is____endpv(VE, ME, ME', none, none, none, none) := PV
    /\ DB? := database(evalModExp(ME', nil, database(evalModExp(ME, nil, DB)))) .
  ceq procView(T, PV, DB)
    = procViewAux(T, PV,
        getThOpDeclSet(ME, DB?),
        getThMsgDeclSet(ME, DB?),
        getThStratDeclSet(ME, DB?),
        getFlatModule(ME, DB?),
        DB?)
    if preview_from_to_is____endpv(VE{PDL}, ME, ME', none, none, none, none) := PV
    /\ DB? := database(evalModExp(ME', PDL, database(evalModExp(ME, PDL, DB)))) .

  eq procViewAux('none.ViewDeclSet,
       preview_from_to_is____endpv(VE{PDL}, ME, ME', VDS, SMS, OMS, TMS),
       OPDS, MDS, StratDcls, M, DB)
    = insertView(view VE{PDL} from ME to ME' is none none none endv, DB) .
  eq procViewAux('none.ViewDeclSet,
       preview_from_to_is____endpv(VE, ME, ME', VDS, SMS, OMS, TMS),
       OPDS, MDS, StratDcls, M, DB)
    = insertView(view VE from ME to ME' is none none none endv, DB) .
  eq procViewAux('__[T, T'], PV, OPDS, MDS, StratDcls, M, DB)
  *** - OPDS and MDS are, respectively, the set of operation and
  ***   message declarations in the theory part of the source.
  *** - M is the signature of the source theory.
    = procViewAux(T', parseDecl(T, PV, OPDS, MDS, StratDcls, M), OPDS, MDS, StratDcls, M, DB) .
  ceq procViewAux(F[TL], PV, OPDS, MDS, StratDcls, M, DB)
    = insertView(
        view VE{PDL} from ME to ME' is
          SMS
          solveBubbles(OMS, VDS, VDS', M, getFlatModule(ME', DB))
          solveBubbles(TMS, VDS, VDS', M, getFlatModule(ME', DB))
        endv,
        DB)
    if F =/= '__
       /\ preview_from_to_is____endpv(VE{PDL}, ME, ME', VDS, SMS, OMS, TMS)
            := parseDecl(F[TL], PV, OPDS, MDS, StratDcls, M)
       /\ VDS' := applyMapsToVars(maps2rens(SMS), none, VDS) .
  ceq procViewAux(F[TL], PV, OPDS, MDS, StratDcls, M, DB)
    = insertView(
        view VE from ME to ME' is
          SMS
          solveBubbles(OMS, VDS, VDS', M, getFlatModule(ME', DB))
          solveBubbles(TMS, VDS, VDS', M, getFlatModule(ME', DB))
        endv,
        DB)
    if F =/= '__
       /\ preview_from_to_is____endpv(VE, ME, ME', VDS, SMS, OMS, TMS)
            := parseDecl(F[TL], PV, OPDS, MDS, StratDcls, M)
       /\ VDS' := applyMapsToVars(maps2rens(SMS), none, VDS) .
  eq procViewAux(T, PV, OPDS, MDS, StratDcls, unitError(QIL), DB) = warning(DB, QIL) .
endfm

*******************************************************************************

***
*** 8.3.3 Command Processing
***

*** The function \texttt{procCommand} only handles the \texttt{reduce},
*** \texttt{rewrite}, and \texttt{down} commands. The other commands are
*** directly evaluated by the rules for the top-level handling of the
*** database (see Section~\ref{database-handling}). The \texttt{procCommand}
*** function takes a term, which represents one of these commands, the name of
*** the default module, and a database. The result is a list of quoted
*** identifiers representing the result of the evaluation of the command that
*** will be placed in the read-eval-print loop to be printed in the terminal.

*** The \texttt{reduce} and \texttt{rewrite} commands are basically evaluated
*** calling the built-in functions \texttt{metaReduce} and
*** \texttt{metaRewrite}, respectively. These functions are called with the
*** appropriate modules. In the case of commands in which an explicit module
*** is not specified the default module is used.

*** The preparation of the output for these functions becomes more complex
*** when the \texttt{down} command is used. To deal with the \texttt{down}
*** command, an auxiliary function \texttt{procCommand2} is introduced,
*** returning the term resulting from the evaluation of the command.

view Strategy from TRIV to META-LEVEL is
  sort Elt to Strategy .
endv

fmod FM-COMMAND-PROCESSING is
  pr AX-COHERENCE-COMPLETION .
  pr UNIT-PROCESSING .
  pr UNIT-META-PRETTY-PRINT .
  inc (2TUPLE * (op `(_`,_`) to <<_;_>>,
                 op p1_ to getDatabase,
                 op p2_ to getQidList)) {Database, QidList} .
  pr META-FULL-MAUDE-SIGN .
  pr FM-META-NARROWING-SEARCH * (op addOps to addOpsSE, op addEqs to addEqsSE, op addSorts to addSortsSE) .

  eq getDatabase(<< DB ; qidError(QIL) >>) = warning(DB, QIL) .
  eq getQidList(<< DB ; qidError(QIL) >>) = QIL .

  op {_,_} : Term Type ~> ResultPair [ctor] .
  op {_,_,_} : Term Type Substitution ~> ResultTriple [ctor] .
  op {_,_,_,_} : Term Type Substitution Context ~> Result4Tuple [ctor] .
  op {_,_} : Substitution Context ~> MatchPair [ctor] .

*** projection functions (from prelude.maude)
  op getTerm : ResultPair ~> Term .
  eq getTerm({T:[Term], T':[Type]}) = T:[Term] .
  op getType : ResultPair ~> Type .
  eq getType({T:[Term], T':[Type]}) = T':[Type] .

  op getTerm : ResultTriple ~> Term .
  eq getTerm({T:[Term], T':[Type], S:[Substitution]}) = T:[Term] .
  op getType : ResultTriple ~> Type .
  eq getType({T:[Term], T':[Type], S:[Substitution]}) = T':[Type] .
  op gTSubstitution : ResultTriple ~> Substitution .
  eq gTSubstitution({T:[Term], T':[Type], S:[Substitution]})
    = S:[Substitution] .

  op getTerm : Result4Tuple ~> Term .
  eq getTerm({T:[Term], T':[Type], S:[Substitution], C:[Context]}) = T:[Term] .
  op getType : Result4Tuple ~> Type .
  eq getType({T:[Term], T':[Type], S:[Substitution], C:[Context]}) = T':[Type] .
  op gTSubstitution : Result4Tuple ~> Substitution .
  eq gTSubstitution({T:[Term], T':[Type], S:[Substitution], C:[Context]})
    = S:[Substitution] .
  op getContext : Result4Tuple ~> Context .
  eq getContext({T:[Term], T':[Type], S:[Substitution], C:[Context]})
    = C:[Context] .

  op gTSubstitution : MatchPair ~> Substitution .
  eq gTSubstitution({S:[Substitution], C:[Context]}) = S:[Substitution] .
  op getContext : MatchPair ~> Context .
  eq getContext({S:[Substitution], C:[Context]}) = C:[Context] .

  vars T T' T'' T''' OT : Term .
  var  TL : TermList .
  vars DB DB' DB'' : Database .
  var  DB? : [Database] .
  vars M M' : Module .
  var  M? : [Module] .
  vars ME ME' : ModuleExpression .
  vars H H' : Header .
  vars MNS MNS' MNS'' MNS3 MNS4 : Set{ModuleName} .
  var  VE : ViewExpression .
  var  VES : Set{ViewExpression} .
  vars N I J : Nat .
  var  I? : [Nat] .
  vars D D' : Bound .
  var  D? : [Bound] .
  var  B : Bool .
  var  B? : [Bool] .
  vars MIS MIS' : Set{ModuleInfo} .
  var  VIS : Set{ViewInfo} .
  vars PDS PDS' : Set{ParameterDecl} .
  var  QIL : QidList .
  var  SS : SortSet .
  var  SSDS : SubsortDeclSet .
  vars VS VDS VDS' : VariableSet .
  var  OPDS : OpDeclSet .
  var  OPDS? : [OpDeclSet] .
  var  MAS : MembAxSet .
  var  EqS : EquationSet .
  var  RlS : RuleSet .
  vars QI QI' F V O : Qid .
  var  Ct : Constant .
  var  IL : ImportList .
  var  TM : [Tuple{Term,Module,Bool,VariableSet,Database}] .
  var  TMVB : [Tuple{Term,Module,Bool,VariableSet,Bound,Database}] .
  var  TMVBN : [Tuple{Term,Module,VariableSet,Bound,Nat}] .
  var  TMSBOBD : [Tuple{Term,Module,Strategy,Bool,VariableSet,Bound,Database}] .
  var  T? : [Term] .
  var  RP : [ResultPair] .
  var  RT : [ResultTriple] .
  var  Sb? : [Substitution] .
  var  MP? : [MatchPair] .
  var  CD : Condition .
  var  Sb : Substitution .
  var  UP? : [UnificationPair] .
  var  UP : UnificationProblem .
  vars St Strat : Strategy .
  var  SrwOpt : SrewriteOption .
  var  RP? : [ResultPair] .

  op tupleTMBODerror : QidList -> [Tuple{Term,Module,Bool,VariableSet,Database}] .
  op tupleTMBOBDerror : QidList -> [Tuple{Term,Module,Bool,VariableSet,Bound,Database}] .
  op tupleTMSBOBDerror : QidList -> [Tuple{Term,Module,Strategy,Bool,VariableSet,Bound,Database}] .
  op tupleTMOBNerror : QidList -> [Tuple{Term,Module,VariableSet,Bound,Nat}] .
  op getMsg : [Tuple{Term,Module,Bool,VariableSet,Database}] -> QidList .
  op getMsg : [Tuple{Term,Module,Bool,VariableSet,Bound,Database}] -> QidList .
  op getMsg : [Tuple{Term,Module,Strategy,Bool,VariableSet,Bound,Database}] -> QidList .
  op getMsg : [Tuple{Term,Module,VariableSet,Bound,Nat}] -> QidList .
  eq getMsg(tupleTMBODerror(QIL)) = QIL .
  eq getMsg(tupleTMBOBDerror(QIL)) = QIL .
  eq getMsg(tupleTMSBOBDerror(QIL)) = QIL .
  eq getMsg(tupleTMOBNerror(QIL)) = QIL .

  pr 5TUPLE{Term,Module,Bool,VariableSet,Database}
       * (op ((_,_,_,_,_)) to `{_`,_`,_`,_`,_`},
          op p1_ to getTerm,
          op p2_ to getModule,
          op p3_ to getBool,
          op p4_ to getVars,
          op p5_ to getDatabase) .
  pr 6TUPLE{Term,Module,Bool,VariableSet,Bound,Database}
       * (op ((_,_,_,_,_,_)) to `{_`,_`,_`,_`,_`,_`},
          op p1_ to getTerm,
          op p2_ to getModule,
          op p3_ to getBool,
          op p4_ to getVars,
          op p5_ to getBound,
          op p6_ to getDatabase) .
  pr 5TUPLE{Term,Module,VariableSet,Bound,Nat}
       * (op ((_,_,_,_,_)) to `{_`,_`,_`,_`,_`},
          op p1_ to getTerm,
          op p2_ to getModule,
          op p3_ to getVars,
          op p4_ to getBound,
          op p5_ to getNat) .
  pr 7TUPLE{Term,Module,Strategy,Bool,VariableSet,Bound,Database}
       * (op ((_,_,_,_,_,_,_)) to `{_`,_`,_`,_`,_`,_`,_`},
          op p1_ to getTerm,
          op p2_ to getModule,
          op p3_ to getStrategy,
          op p4_ to getBool,
          op p5_ to getVars,
          op p6_ to getBound,
          op p7_ to getDatabase) .

  op boundError : QidList -> [Bound] .

---(
  eq getTerm({T, M, B, VDS, DB}) = T .
  eq getTerm(tupleTMBODerror(QIL)) = qidError(QIL) .
  eq getModule({T, M, B, VDS, DB}) = M .
  eq getModule(tupleTMBODerror(QIL)) = unitError(QIL) .
  eq getVars({T, M, B, VDS, DB}) = VDS .
  eq getVars(tupleTMBODerror(QIL)) = opDeclError(QIL) .
  eq getBool({T, M, B, VDS, DB}) = B .
  eq getBool(tupleTMBODerror(QIL)) = false .
  eq getDatabase({T, M, B, VDS, DB}) = DB .
  eq getDatabase(tupleTMBODerror(QIL)) = emptyDatabase .

  eq getTerm({T, M, B, VDS, D, DB}) = T .
  eq getModule({T, M, B, VDS, D, DB}) = M .
  eq getVars({T, M, B, VDS, D, DB}) = VDS .
  eq getBound({T, M, B, VDS, D, DB}) = D .
  eq getBool({T, M, B, VDS, D, DB}) = B .
  eq getDatabase({T, M, B, VDS, D, DB}) = DB .

  eq getTerm({T, M, VDS, D, I}) = T .
  eq getModule({T, M, VDS, D, I}) = M .
  eq getVars({T, M, VDS, D, I}) = VDS .
  eq getBound({T, M, VDS, D, I}) = D .
  eq getNat({T, M, VDS, D, I}) = I .
---)

  ---- procLoad

  op procLoad : Term ModuleExpression Database -> Tuple{Database,QidList} .
  op procLoad : Term ModuleExpression Module VariableSet Database -> Tuple{Database,QidList} .

  eq procLoad(T, ME, DB)
   = if compiledModule(ME, DB)
     then procLoad(T, ME, getFlatModule(ME, DB), getVars(ME, DB), DB)
     else procLoad(T, modExp(evalModExp(ME, DB)),
               getFlatModule(modExp(evalModExp(ME, DB)),
                 database(evalModExp(ME, DB))),
               getVars(modExp(evalModExp(ME, DB)), database(evalModExp(ME, DB))),
               database(evalModExp(ME, DB)))
     fi .

  ceq procLoad(T, ME, M, VDS, DB)
    = if downTerm(T:[Term], emptyFModule) =/= emptyFModule
      then << evalModule(downModule(T:[Term]), none, DB) ;
              'Introduced 'module header2Qid(getHeader(downModule(T:[Term]))) '\n >>
      else << DB ; '\r 'Error: '\o 'Incorrect 'metamodule. '\n >>
      fi
    if T:[Term] := getTerm(metaReduce(M, solveBubbles(T, M, true, VDS, DB))) .

  ---- procCommand

  op procCommand : Term ModuleExpression Database -> Tuple{Database,QidList} .
  op procCommand : Term ModuleExpression Module VariableSet Database -> QidList .
  op procDownCommand : Term ModuleExpression Database -> Tuple{Database,QidList} .

  op procParse : ModuleExpression Module Term VariableSet Database -> QidList .

  op procRed : ModuleExpression Module Term VariableSet Database -> QidList .
  op solveBubblesRed : Term Module Bool VariableSet Database
       -> [Tuple{Term,Module,Bool,VariableSet,Database}] .
  op solveBubblesRed2 : Term Database -> [Tuple{Term,Module,Bool,VariableSet,Database}] .
  op solveBubblesRed3 : Term Module ModuleExpression VariableSet Database
       -> [Tuple{Term,Module,Bool,VariableSet,Database}] .

  op procRew : ModuleExpression Module Term VariableSet Database -> QidList .
  op solveBubblesRew :
       Term Module Bool Bound VariableSet Database -> [Tuple{Term,Module,Bool,VariableSet,Bound,Database}] .
  op solveBubblesRew2 :
       Term Module Bool VariableSet Database -> [Tuple{Term,Module,Bool,VariableSet,Bound,Database}] .

  op procFrew : ModuleExpression Module Term Bound Nat VariableSet Database -> QidList .
  op solveBubblesFrew : Term Module Bool Bound Nat VariableSet Database -> [Tuple{Term,Module,VariableSet,Bound,Nat}] .
  op solveBubblesFrew2 : Term Module Bool Nat VariableSet Database -> [Tuple{Term,Module,VariableSet,Bound,Nat}] .

----  sort SrewriteOption .
----  ops breadthFirst depthFirst : -> SrewriteOption [ctor] .

  op procSrew : ModuleExpression Module Term VariableSet Database SrewriteOption -> QidList .
  op solveBubblesSrew : Term Module Bool Strategy Bound VariableSet Database
       -> [Tuple{Term,Module,Strategy,Bool,VariableSet,Bound,Database}]  .
  op solveBubblesSrew2 : Term Module Bool Strategy Bound VariableSet Database
       -> [Tuple{Term,Module,Strategy,Bool,VariableSet,Bound,Database}]  .
  op solveBubblesSrew3 : Term Module Bool Strategy Bound VariableSet Database
       -> [Tuple{Term,Module,Strategy,Bool,VariableSet,Bound,Database}]  .
  op procSrew2 : Module Term Strategy Bound SrewriteOption -> QidList .
  op procSrew3 : Module Term Strategy Bound Nat SrewriteOption -> QidList .

  op procSearch : ModuleExpression Module Term Term Qid Bound Bound VariableSet Database -> QidList .
  op solveBubblesSearchL : Module Term Term Qid Bound Bound Bool VariableSet Database -> QidList .
  op solveBubblesSearchL1 : Module Term Term Qid Bound Bound Bool VariableSet Database -> QidList .
  op solveBubblesSearchR : Module Term Term Qid Bound Bound Bool VariableSet Database -> QidList .
  op solveBubblesSearchR1 : Module Module Term Term Qid Bound Bound Bool VariableSet Database -> QidList .
  op solveBubblesSearchR2 : Module Term Term Qid Bound Bound VariableSet -> QidList .
  op procSearch2 : Module Term Term Condition Qid Bound Bound -> QidList .
  op procSearch3 : Module Term Term Condition Qid Bound Nat Bound -> QidList .

  op procVUNarrow : ModuleExpression Module Term Term Qid Bound Bound VariableSet Database -> QidList .
  op solveBubblesVUNarrowL : Module Term Term Qid Bound Bound Bool VariableSet Database -> QidList .
  op solveBubblesVUNarrowL1 : Module Term Term Qid Bound Bound Bool VariableSet Database -> QidList .
  op solveBubblesVUNarrowR : Module Term Term Qid Bound Bound Bool VariableSet Database -> QidList .
  op solveBubblesVUNarrowR1 : Module Module Term Term Qid Bound Bound Bool VariableSet Database -> QidList .
  op solveBubblesVUNarrowR2 : Module Term Term Qid Bound Bound VariableSet -> QidList .
  op procVUNarrow2 : Module Term Term Condition Qid Bound Bound -> QidList .
  op procVUNarrow3 : Module Nat TermList ResultTripleSet -> QidList .

  op procFVUNarrow : ModuleExpression Module Term Term Qid Bound Bound VariableSet Database -> QidList .
  op solveBubblesFVUNarrowL : Module Term Term Qid Bound Bound Bool VariableSet Database -> QidList .
  op solveBubblesFVUNarrowL1 : Module Term Term Qid Bound Bound Bool VariableSet Database -> QidList .
  op solveBubblesFVUNarrowR : Module Term Term Qid Bound Bound Bool VariableSet Database -> QidList .
  op solveBubblesFVUNarrowR1 : Module Module Term Term Qid Bound Bound Bool VariableSet Database -> QidList .
  op solveBubblesFVUNarrowR2 : Module Term Term Qid Bound Bound VariableSet -> QidList .
  op procFVUNarrow2 : Module Term Term Condition Qid Bound Bound -> QidList .
  op procFVUNarrow3 : Module Nat TermList ResultTripleSet -> QidList .

  op procNarrowSearch : ModuleExpression Module Term Term Qid Bound Bound VariableSet Database -> QidList .
  op solveBubblesNarrowSearchL : Module Term Term Qid Bound Bound Bool VariableSet Database -> QidList .
  op solveBubblesNarrowSearchL1 : Module Term Term Qid Bound Bound Bool VariableSet Database -> QidList .
  op solveBubblesNarrowSearchR : Module Term Term Qid Bound Bound Bool VariableSet Database -> QidList .
  op solveBubblesNarrowSearchR1 : Module Module Term Term Qid Bound Bound Bool VariableSet Database -> QidList .
  op solveBubblesNarrowSearchR2 : Module Term Term Qid Bound Bound VariableSet -> QidList .
  op procNarrowSearch2 : Module Term Term Condition Qid Bound Bound -> QidList .
  op procNarrowSearch3 : Module Nat TermList ResultTripleSet -> QidList .

  op procMatch : ModuleExpression Module Term Term Qid Bound VariableSet Database -> QidList .
  op procMatch2 : Module Term Term Condition Qid Bound -> QidList .
  op procMatch3 : Module Term Term Condition Qid Bound Nat -> QidList .
  op solveBubblesMatch : Module Module Term Term Qid Bound Bool VariableSet Database ~> QidList .
  op solveBubblesMatch2 : Module Term Term Qid Bound VariableSet ~> QidList .

  op procUnify : ModuleExpression Module Term Bound VariableSet Database -> QidList .
  op procUnify2 : ModuleExpression Module Term Bound VariableSet Database -> QidList .
  op addInfoUnify : Module -> [Module] .
  op parseUnify : Term VariableSet -> UnificationProblem .
  op procUnify2 : Module UnificationProblem Bound -> QidList .
  op eMetaPrettyPrint : Module UnificationProblem -> QidList .
  op procUnify3 : Module UnificationProblem Bound Nat -> QidList .
  op procUnify3Aux : Module UnificationPair Nat -> QidList .
  op unificationProblemError : QidList -> [UnificationProblem] .

  op procIdUnify : ModuleExpression Module Term Bound VariableSet Database -> QidList .
  op procIdUnify2 : Module UnificationProblem Bound -> QidList .
  op procIdUnify3 : Module UnificationProblem Nat SubstitutionSet -> QidList .

  op procVariantUnify : ModuleExpression Module Term Bound VariableSet Database -> QidList .
  op procVariantUnify2 : Module UnificationProblem Bound -> QidList .
  op procVariantUnify3 : Module UnificationProblem Nat SubstitutionSet -> QidList .

  op procAsymmetricVariantUnify : ModuleExpression Module Term Bound VariableSet Database -> QidList .
  op procAsymmetricVariantUnify2 : Module UnificationProblem Bound -> QidList .
  op procAsymmetricVariantUnify3 : Module UnificationProblem Nat SubstitutionSet -> QidList .

  op procGetVariants : ModuleExpression Module Term Bound VariableSet Database -> QidList .
  op procGetVariants2 : Module Term Bound -> QidList .
  op procGetVariants3 : Module Term Nat VariantFourSet -> QidList .

  op solveBubblesUnify : Module Term VariableSet ~> UnificationProblem .
  op solveBubblesRedUnify : Term Module Bool VariableSet Database
       -> [Tuple{Term,Module,Bool,VariableSet,Database}] .
  op solveBubblesRedUnify2 : Term Database -> [Tuple{Term,Module,Bool,VariableSet,Database}] .
  op solveBubblesRedUnify3 : Term Module ModuleExpression VariableSet Database
       -> [Tuple{Term,Module,Bool,VariableSet,Database}] .
  op procRewUnify : ModuleExpression Module Term VariableSet Database -> QidList .
  op solveBubblesRewUnify : Term Module Bool Bound VariableSet Database
       -> [Tuple{Term,Module,Bool,VariableSet,Bound,Database}] .
  op solveBubblesRewUnify2 : Term Module Bool VariableSet Database
       -> [Tuple{Term,Module,Bool,VariableSet,Bound,Database}] .

  op eMetaPrettyPrint : Module Substitution -> QidList .

  eq eMetaPrettyPrint(M, V <- T ; Sb:Substitution)
    = V '--> '\s eMetaPrettyPrint(M, T)
      if eMetaPrettyPrint(M, Sb:Substitution) == nil
      then nil
      else '; '\n eMetaPrettyPrint(M, Sb:Substitution)
      fi .
  eq eMetaPrettyPrint(M, (none).Substitution) = nil .

  op procCommandUp : ModuleExpression Module Term VariableSet Database -> Term .
  op procRedUp : ModuleExpression Module Term VariableSet Database -> Term .
  op procRewUp : ModuleExpression Module Term Bound VariableSet Database -> Term .
  op procFrewUp : ModuleExpression Module Term Bound Nat VariableSet Database -> Term .
  op procSrewUp : ModuleExpression Module Term Bound VariableSet Database SrewriteOption -> Term .

*** Processing of commands.

  ceq procDownCommand('down_:_[T, T'], ME, DB)
    = if T'':[Term] :: Term
      then << DB'' ;
              ('\b 'result '\o
               '\s eMetaPrettyPrint(leastSort(M, T'':[Term]))
               '\s '\b ': '\o '\n '\s '\s
               eMetaPrettyPrint(M, T'':[Term]) '\n) >>
      else << DB ; ('\r 'Error: '\o 'Incorrect 'input. '\n) >>
      fi
    if DB' := database(evalModExp(ME, DB))
    /\ < DB'' ; ME' > := evalModExp(parseModExp(T), DB')
    /\ M := getFlatModule(ME', DB'')
    /\ T'':[Term] := procCommandUp(ME, getFlatModule(ME, DB''), T', getVars(ME, DB''), DB'').

  eq procCommand(T, ME, DB)
   = if compiledModule(ME, DB)
     then << DB ; procCommand(T, ME, getFlatModule(ME, DB), getVars(ME, DB), DB) >>
     else << database(evalModExp(ME, DB)) ;
             procCommand(T, modExp(evalModExp(ME, DB)),
               getFlatModule(modExp(evalModExp(ME, DB)), database(evalModExp(ME, DB))),
               getVars(modExp(evalModExp(ME, DB)), database(evalModExp(ME, DB))),
               database(evalModExp(ME, DB))) >>
     fi
     [owise] .

----  eq procCommand(T, ME, unitError(QIL), VS, DB) = qidError(QIL) .
  eq procCommand(T, ME, unitError(QIL), VS, DB) = QIL .

  eq procCommand('parse_.[T], ME, M, VS, DB)
   = procParse(ME, M, T, VS, DB) .

  eq procCommand('reduce_.[T], ME, M, VS, DB)
    = procCommand('red_.[T], ME, M, VS, DB) .
  eq procCommand('red_.[T], ME, M, VS, DB)
    = procRed(ME, M, T, VS, DB) .

  eq procCommand('rewrite_.[T], ME, M, VS, DB)
    = procCommand('rew_.[T], ME, M, VS, DB) .
  eq procCommand('rew_.[T], ME, M, VS, DB)
    = procRew(ME, M, T, VS, DB) .

  eq procCommand('frewrite_.[T], ME, M, VS, DB)
    = procCommand('frew_.[T], ME, M, VS, DB) .
  eq procCommand('frew_.[T], ME, M, VS, DB)
    = procFrew(ME, M, T, unbounded, 1, VS, DB) .

  eq procCommand('srewrite_.[T], ME, M, VS, DB)
    = procCommand('srew_.[T], ME, M, VS, DB) .
  eq procCommand('dsrewrite_.[T], ME, M, VS, DB)
    = procCommand('dsrew_.[T], ME, M, VS, DB) .
  eq procCommand('srew_.[T], ME, M, VS, DB)
    = procSrew(ME, M, T, VS, DB, breadthFirst) .
  eq procCommand('dsrew_.[T], ME, M, VS, DB)
    = procSrew(ME, M, T, VS, DB, depthFirst) .

  eq procCommand('search_=>1_.[T, T'], ME, M, VS, DB)
    = procSearch(ME, M, T, T', '+, unbounded, 1, VS, DB) .
  eq procCommand('search_=>*_.[T, T'], ME, M, VS, DB)
    = procSearch(ME, M, T, T', '*, unbounded, unbounded, VS, DB) .
  eq procCommand('search_=>+_.[T, T'], ME, M, VS, DB)
    = procSearch(ME, M, T, T', '+, unbounded, unbounded, VS, DB) .
  eq procCommand('search_=>!_.[T, T'], ME, M, VS, DB)
    = procSearch(ME, M, T, T', '!, unbounded, unbounded, VS, DB) .

  eq procCommand('vu-narrow_=>1_.[T, T'], ME, M, VS, DB)
    = procVUNarrow(ME, M, T, T', '+, unbounded, 1, VS, DB) .
  eq procCommand('vu-narrow_=>*_.[T, T'], ME, M, VS, DB)
    = procVUNarrow(ME, M, T, T', '*, unbounded, unbounded, VS, DB) .
  eq procCommand('vu-narrow_=>+_.[T, T'], ME, M, VS, DB)
    = procVUNarrow(ME, M, T, T', '+, unbounded, unbounded, VS, DB) .
  eq procCommand('vu-narrow_=>!_.[T, T'], ME, M, VS, DB)
    = procVUNarrow(ME, M, T, T', '!, unbounded, unbounded, VS, DB) .

  eq procCommand('fvu-narrow_=>1_.[T, T'], ME, M, VS, DB)
    = procFVUNarrow(ME, M, T, T', '+, unbounded, 1, VS, DB) .
  eq procCommand('fvu-narrow_=>*_.[T, T'], ME, M, VS, DB)
    = procFVUNarrow(ME, M, T, T', '*, unbounded, unbounded, VS, DB) .
  eq procCommand('fvu-narrow_=>+_.[T, T'], ME, M, VS, DB)
    = procFVUNarrow(ME, M, T, T', '+, unbounded, unbounded, VS, DB) .
  eq procCommand('fvu-narrow_=>!_.[T, T'], ME, M, VS, DB)
    = procFVUNarrow(ME, M, T, T', '!, unbounded, unbounded, VS, DB) .

  eq procCommand('search_~>1_.[T, T'], ME, M, VS, DB)
    = procNarrowSearch(ME, M, T, T', '+, unbounded, 1, VS, DB) .
  eq procCommand('search_~>*_.[T, T'], ME, M, VS, DB)
    = procNarrowSearch(ME, M, T, T', '*, unbounded, unbounded, VS, DB) .
  eq procCommand('search_~>+_.[T, T'], ME, M, VS, DB)
    = procNarrowSearch(ME, M, T, T', '+, unbounded, unbounded, VS, DB) .
  eq procCommand('search_~>!_.[T, T'], ME, M, VS, DB)
    = procNarrowSearch(ME, M, T, T', '!, unbounded, unbounded, VS, DB) .

  eq procCommand('match_<=?_.[T, T'], ME, M, VS, DB)
    = procMatch(ME, M, T, T', 'match, 0, VS, DB) .
  eq procCommand('xmatch_<=?_.[T, T'], ME, M, VS, DB)
    = procMatch(ME, M, T, T', 'xmatch, 0, VS, DB) .

  eq procCommand('unify_.['ububble[T]], ME, M, VS, DB)
    = procUnify(ME, M, 'bubble[T], unbounded, VS, DB) .

  eq procCommand('id-unify_.['ububble[T]], ME, M, VS, DB)
    = procIdUnify(ME, M, 'bubble[T], unbounded, VS, DB) .

  eq procCommand('variant`unify_.['ububble[T]], ME, M, VS, DB)
    = procVariantUnify(ME, M, 'bubble[T], unbounded, VS, DB) .

  eq procCommand('asymmetric`variant`unify_.['ububble[T]], ME, M, VS, DB)
    = procAsymmetricVariantUnify(ME, M, 'bubble[T], unbounded, VS, DB) .

  eq procCommand('get`variants_.['ububble[T]], ME, M, VS, DB)
    = procGetVariants(ME, M, 'bubble[T], unbounded, VS, DB) .

  eq procCommandUp(ME, M, 'down_:_[T, T'], VDS, DB)
    = downTerm(procCommandUp(ME, M, T', VDS, DB)) .
  eq procCommandUp(ME, M, 'red_.['ububble[T]], VDS, DB)
    = downTerm(procRedUp(ME, M, 'bubble[T], VDS, DB)) .
  eq procCommandUp(ME, M, 'reduce_.['ububble[T]], VDS, DB)
    = downTerm(procRedUp(ME, M, 'bubble[T], VDS, DB)) .
  eq procCommandUp(ME, M, 'rew_.['ububble[T]], VDS, DB)
    = downTerm(procRewUp(ME, M, 'bubble[T], unbounded, VDS, DB)) .
  eq procCommandUp(ME, M, 'rewrite_.['ububble[T]], VDS, DB)
    = downTerm(procRewUp(ME, M, 'bubble[T], unbounded, VDS, DB)) .
  eq procCommandUp(ME, M, 'frew_.['ububble[T]], VDS, DB)
    = downTerm(procFrewUp(ME, M, 'bubble[T], unbounded, 0, VDS, DB)) .
  eq procCommandUp(ME, M, 'frewrite_.['ububble[T]], VDS, DB)
    = downTerm(procFrewUp(ME, M, 'bubble[T], unbounded, 0, VDS, DB)) .
  eq procCommandUp(ME, M, 'srew_.['ububble[T]], VDS, DB)
    = downTerm(procSrewUp(ME, M, 'bubble[T], unbounded, VDS, DB, breadthFirst)) .
  eq procCommandUp(ME, M, 'srewrite_.['ububble[T]], VDS, DB)
    = downTerm(procSrewUp(ME, M, 'bubble[T], unbounded, VDS, DB, breadthFirst)) .
  eq procCommandUp(ME, M, 'dsrew_.['ububble[T]], VDS, DB)
    = downTerm(procSrewUp(ME, M, 'bubble[T], unbounded, VDS, DB, depthFirst)) .
  eq procCommandUp(ME, M, 'dsrewrite_.['ububble[T]], VDS, DB)
    = downTerm(procSrewUp(ME, M, 'bubble[T], unbounded, VDS, DB, depthFirst)) .

  ceq procRedUp(ME, M, T, VDS, DB)
    = if metaReduce(getModule(TM), getTerm(TM)) :: ResultPair
      then getTerm(metaReduce(getModule(TM), getTerm(TM)))
      else qidError('\r 'Error: '\o 'Incorrect 'command. '\n
                    getMsg(TM))
      fi
    if TM := solveBubblesRed(T, M,
               included('META-MODULE, getImports(getTopModule(ME, DB)), DB),
               VDS, DB) .

  ceq procRewUp(ME, M, T, D, VDS, DB)
    = if metaRewrite(getModule(TMVB), getTerm(TMVB), getBound(TMVB))
           :: ResultPair
      then getTerm(metaRewrite(getModule(TMVB), getTerm(TMVB), getBound(TMVB)))
      else qidError('\r 'Error: '\o 'Incorrect 'command. '\n)
      fi
    if TMVB := solveBubblesRew(T, M,
                included('META-MODULE, getImports(getTopModule(ME, DB)), DB),
                D, VDS, DB) .

  ceq procSrewUp(ME, M, T, D, VDS, DB, SrwOpt)
    = if RP? :: ResultPair
      then getTerm(RP?)
      else qidError('\r 'Error: '\o 'Incorrect 'command. '\n)
      fi
    if TMSBOBD := solveBubblesSrew(T, M,
                    included('META-MODULE, getImports(getTopModule(ME, DB)), DB),
                    idle, D, VDS, DB)
    /\ RP? := metaSrewrite(getModule(TMSBOBD), getTerm(TMSBOBD), getStrategy(TMSBOBD), SrwOpt, getBound(TMSBOBD)).

  ceq procFrewUp(ME, M, T, D, I, VDS, DB)
    = if metaFrewrite(
           getModule(TMVBN), getTerm(TMVBN), getBound(TMVBN), getNat(TMVBN))
         :: ResultPair
      then getTerm(
             metaFrewrite(getModule(TMVBN), getTerm(TMVBN),
               getBound(TMVBN), getNat(TMVBN)))
      else qidError('\r 'Error: '\o 'Incorrect 'command. '\n)
      fi
    if TMVBN := solveBubblesFrew(T, M,
                 included('META-MODULE, getImports(getTopModule(ME, DB)), DB),
                 D, I, VDS, DB) .

  ceq procParse(ME, M, T, VDS, DB)
    = if leastSort(getModule(TM), getTerm(TM)) :: Type
      then (eMetaPrettyPrint(leastSort(getModule(TM), getTerm(TM)))
            '\s '\b ': '\o '\n '\s '\s
            eMetaPrettyPrint(getModule(TM), getTerm(TM)) '\n)
      else getMsg(TM)
      fi
    if TM := solveBubblesRed(T, M,
               included('META-MODULE, getImports(getTopModule(ME, DB)), DB),
               VDS, DB) .
  eq procParse(ME, unitError(QIL), T, VDS, DB) = QIL .
  eq procParse(ME, noModule, T, VDS, DB) = getMsg(DB) .

  ceq procRed(ME, M, T, VDS, DB)
    = if metaReduce(getModule(TM), getTerm(TM)) :: ResultPair
      then ('\b 'reduce 'in
            '\o eMetaPrettyPrint(getHeader(getModule(TM))) '\b ': '\o '\n '\s '\s
            eMetaPrettyPrint(getModule(TM), getTerm(TM)) '\n
            '\b 'result '\o '\s
            eMetaPrettyPrint(getType(metaReduce(getModule(TM), getTerm(TM))))
            '\s '\b ': '\o '\n '\s '\s
            eMetaPrettyPrint(getModule(TM),
              getTerm(metaReduce(getModule(TM), getTerm(TM))))
            '\n)
      else ('\b 'Error: '\o 'Incorrect 'command '\n getMsg(TM))
      fi
    if TM := solveBubblesRed(T, M,
               included('META-MODULE, getImports(getTopModule(ME, DB)), DB),
               VDS, DB) .
  eq procRed(ME, unitError(QIL), T, VDS, DB) = QIL .
  eq procRed(ME, noModule, T, VDS, DB) = getMsg(DB) .

  eq metaReduce(unitError(QIL), T) = {qidError(QIL), '`[Term`]} .
  eq metaReduce(U:[Module], qidError(QIL)) = {qidError(QIL), '`[Term`]} .

  eq solveBubblesRed('ububble[T], M, B, VDS, DB)
    = solveBubblesRed('bubble[T], M, B, VDS, DB) .
  ceq solveBubblesRed('bubble[QI], M, B, VDS, DB)
    = if T? :: Term
      then {T?, M, B, VDS, DB}
      else tupleTMBODerror('\r 'Error: '\o 'no 'parse 'for downQidList(QI) '\n)
      fi
    if T? := solveBubbles('bubble[QI], M, B, VDS, DB) .
  ceq solveBubblesRed('bubble['__[TL]], M, B, VDS, DB)
    = if T? :: Term
      then {T?, M, B, VDS, DB}
      else if metaParse(GRAMMAR-RED, downQidList('__[TL, ''..Qid]), '@RedInPart@) :: ResultPair
           then solveBubblesRed2(
                  getTerm(metaParse(GRAMMAR-RED, downQidList('__[TL, ''..Qid]), '@RedInPart@)),
                  DB)
           else tupleTMBODerror(
                  '\r 'Warning: '\o
                    printSyntaxError(
                      metaParse(GRAMMAR-RED, downQidList('__[TL, ''..Qid]),
                       '@RedInPart@), downQidList('__[TL, ''..Qid])) '\n
                    '\r 'Error: '\o 'no 'parse 'for downQidList('__[TL, ''..Qid]) '\n)
           fi
      fi
    if T? := solveBubbles('bubble['__[TL]], M, B, VDS, DB) .
  *** There is some problem parsing 'in_:_ in solveBubblesRed, but it
  *** seems to work with the additional '.

  ceq solveBubblesRed2('in_:_.[T, T'], DB)
    = if unitInDb(ME, DB')
      then solveBubblesRed3(T', getFlatModule(ME, DB'), ME, getVars(ME, DB'), DB')
      else tupleTMBODerror('\r 'Error: '\o 'It 'is 'not 'possible 'to 'compile eMetaPrettyPrint(ME) '. '\n)
      fi
    if < DB' ; ME > := evalModExp(parseModExp(T), DB) .
  eq solveBubblesRed2('in_:_.[T, T'], DB)
    = tupleTMBODerror('\r 'Error: '\o 'It 'isn't 'possible 'to 'compile eMetaPrettyPrint(parseModExp(T)) '. '\n)
    [owise] .

  eq solveBubblesRed3(T, M, ME, VDS, DB)
    = {solveBubbles(T, M,
         included('META-MODULE, getImports(getTopModule(ME, DB)), DB),
         VDS, DB),
       M,
       included('META-MODULE, getImports(getTopModule(ME, DB)), DB),
       VDS,
       DB} .

  op GRAMMAR-RED : -> FModule [memo] .
  eq GRAMMAR-RED
    = addImports((including 'FM-MOD-EXPR .),
        addSorts('@RedInPart@,
          addOps((op 'in_:_. : '@ModExp@ '@UBubble@ -> '@RedInPart@ [none] .),
            BUBBLES))) .

  ceq procRew(ME, M, T, VDS, DB)
    = if RP :: ResultPair
      then ('\b 'rewrite 'in '\o eMetaPrettyPrint(getHeader(getModule(TMVB)))
            '\b ': '\o '\n '\s '\s
            eMetaPrettyPrint(getModule(TMVB), getTerm(TMVB)) '\n
            '\b 'result '\o '\s
            eMetaPrettyPrint(getType(RP))
            '\s '\b ': '\o '\n '\s '\s
            eMetaPrettyPrint(getModule(TMVB), getTerm(RP))
            '\n)
      else getMsg(TMVB)
      fi
    if TMVB := solveBubblesRew(T, M,
                included('META-MODULE, getImports(getTopModule(ME, DB)), DB),
                unbounded, VDS, DB)
       /\ RP  := metaRewrite(getModule(TMVB), getTerm(TMVB), getBound(TMVB)) .
  eq procRew(ME, unitError(QIL), T, VDS, DB) = qidError(QIL) .

  eq solveBubblesRew('ububble[T], M, B, D, VDS, DB)
    = solveBubblesRew('bubble[T], M, B, D, VDS, DB) .
  eq solveBubblesRew('bubble[QI], M, B, D, VDS, DB)
    = if solveBubbles('bubble[QI], M, B, VDS, DB) :: Term
      then {solveBubbles('bubble[QI], M, B, VDS, DB), M, B, VDS, unbounded, DB}
      else tupleTMBOBDerror(
             '\r 'Error: '\o 'no 'parsing 'for downQidList(QI) '\n)
      fi .
  eq solveBubblesRew('bubble['__[TL]], M, B, D, VDS, DB)
    = if solveBubbles('bubble['__[TL]], M, B, VDS, DB) :: Term
      then {solveBubbles('bubble['__[TL]], M, B, VDS, DB), M, B, VDS, unbounded, DB}
      else if metaParse(GRAMMAR-REW, downQidList('__[TL, ''..Qid]), '@RewNuPart@)
                :: ResultPair
           then solveBubblesRew2(
                  getTerm(
                    metaParse(GRAMMAR-REW, downQidList('__[TL, ''..Qid]), '@RewNuPart@)),
                  M, B, VDS, DB)
           else {getTerm(solveBubblesRed('bubble['__[TL]], M, B, VDS, DB)),
                 getModule(solveBubblesRed('bubble['__[TL]], M, B, VDS, DB)),
                 getBool(solveBubblesRed('bubble['__[TL]], M, B, VDS, DB)),
                 getVars(solveBubblesRed('bubble['__[TL]], M, B, VDS, DB)),
                 unbounded,
                 getDatabase(solveBubblesRed('bubble['__[TL]], M, B, VDS, DB))}
           fi
      fi .

  eq solveBubblesRew2('`[_`]_.['token[T], T'], M, B, VDS, DB)
    = if downNat(downMetaNat(T)) :: Nat
         and-then solveBubblesRed(T', M, B, VDS, DB)
                    :: Tuple{Term,Module,Bool,VariableSet,Database}
      then {getTerm(solveBubblesRed(T', M, B, VDS, DB)),
            getModule(solveBubblesRed(T', M, B, VDS, DB)),
            getBool(solveBubblesRed(T', M, B, VDS, DB)),
            getVars(solveBubblesRed(T', M, B, VDS, DB)),
            downNat(downMetaNat(T)),
            getDatabase(solveBubblesRed(T', M, B, VDS, DB))}
      else tupleTMBOBDerror('\r 'Error: '\o 'Incorrect 'command. '\n)
      fi .

  op GRAMMAR-REW : -> FModule [memo] .
  eq GRAMMAR-REW
    = addSorts('@RewNuPart@ ; '@Token@ ; '@SortToken@ ; '@ViewToken@ ;
               '@NeTokenList@ ; '@Bubble@ ; '@UBubble@ ; '@StBubble@ ;
               '@EqLBubble@ ; '@RlLBubble@ ; '@SdLBubble@ ; '@RCBubble@ ; '@RBubble@,
        addOps((op '`[_`]_. : '@Token@ '@UBubble@ -> '@RewNuPart@ [none] .),
          BUBBLES)) .

  *** SREW

 ceq procSrew(ME, M, T, VDS, DB, SrwOpt)
    = procSrew2(M', T', Strat, D, SrwOpt)
    if { T', M', Strat, B, VDS', D, DB' }
         := solveBubblesSrew(T, M,
              included('META-MODULE, getImports(getTopModule(ME, DB)), DB),
              idle, unbounded, VDS, DB) .
  eq procSrew(ME, unitError(QIL), T, VDS, DB, SrwOpt) = qidError(QIL) .
  eq procSrew(ME, M, T, VDS, DB, SrwOpt)
    = '\b 'Error: '\o 'Incorrect 'input
    [owise] .

  eq solveBubblesSrew('ububble[T], M, B, St, D, VDS, DB)
    = solveBubblesSrew('bubble[T], M, B, St, D, VDS, DB) .
  eq solveBubblesSrew('bubble[QI], M, B, St, D, VDS, DB)
    = if solveBubbles('bubble[QI], M, B, VDS, DB) :: Term
      then { solveBubbles('bubble[QI], M, B, VDS, DB), M, St, B, VDS, D, DB }
      else tupleTMSBOBDerror('\r 'Error: '\o 'no 'parsing 'for downQidList(QI) '\n)
      fi .
  eq solveBubblesSrew('bubble['__[TL]], M, B, St, D, VDS, DB)
    = if solveBubbles('bubble['__[TL]], M, B, VDS, DB) :: Term
      then { solveBubbles('bubble['__[TL]], M, B, VDS, DB), M, St, B, VDS, D, DB }
      else if metaParse(GRAMMAR-REW, downQidList('__[TL, ''..Qid]), '@RewNuPart@) :: ResultPair
           then solveBubblesSrew2(
                  getTerm(metaParse(GRAMMAR-REW, downQidList('__[TL, ''..Qid]), '@RewNuPart@)),
                  M, B, St, D, VDS, DB)
           else solveBubblesSrew3(
                  getTerm(metaParse(GRAMMAR-SREW, downQidList('__[TL, ''..Qid]), '@SrewNuPart@)),
                  M, B, St, D, VDS, DB)
           fi
      fi .

  eq solveBubblesSrew2('`[_`]_.['token[T], 'ububble['__[TL]]], M, B, St, D, VDS, DB)
    = if downNat(downMetaNat(T)) :: Nat
         and-then metaParse(GRAMMAR-SREW, downQidList('__[TL, ''..Qid]), '@SrewNuPart@) :: ResultPair
      then solveBubblesSrew3(
             getTerm(metaParse(GRAMMAR-SREW, downQidList('__[TL, ''..Qid]), '@SrewNuPart@)),
             M, B, St, downNat(downMetaNat(T)), VDS, DB)
      else tupleTMSBOBDerror('\r 'Error: '\o 'no 'parsing 'for downQidList('__[TL, ''..Qid]) '\n)
      fi .

  eq solveBubblesSrew3('_using_.['stbubble[T], 'ububble[T']], M, B, St, D, VDS, DB)
    = if metaParseStrategy(M, VDS, downQidList(T')) :: Strategy
         and-then solveBubblesRed('bubble[T], M, B, VDS, DB) :: Tuple{Term,Module,Bool,VariableSet,Database}
      then { getTerm(solveBubblesRed('bubble[T], M, B, VDS, DB)),
             getModule(solveBubblesRed('bubble[T], M, B, VDS, DB)),
             metaParseStrategy(M, VDS, downQidList(T')),
             B,
             getVars(solveBubblesRed('bubble[T], M, B, VDS, DB)),
             D,
             DB }
      else tupleTMSBOBDerror('\r 'Error: '\o 'Incorrect 'command. '\n)
      fi .

  op GRAMMAR-SREW : -> FModule [memo] .
  eq GRAMMAR-SREW
    = addSorts('@SrewNuPart@ ; '@Token@ ; '@SortToken@ ; '@ViewToken@ ;
               '@NeTokenList@ ; '@Bubble@ ; '@UBubble@ ; '@StBubble@ ;
               '@EqLBubble@ ; '@RlLBubble@ ; '@SdLBubble@ ; '@RCBubble@ ; '@RBubble@,
        addOps((op '_using_. : '@StBubble@ '@UBubble@ -> '@SrewNuPart@ [none] .),
          BUBBLES)) .

  ceq procSrew2(M, T, St, D, SrwOpt)
    = (if SrwOpt == breadthFirst then 'srewrite else 'dsrewrite fi
          if D == unbounded
          then nil
          else '\s '`[ qid(string(D, 10)) '`] '\s
          fi
          'in eMetaPrettyPrint(getHeader(M)) ':
          eMetaPrettyPrint(M, T) '\s
          'using
          metaPrettyPrintStrategy(M, St) '. '\n '\n
      if RP :: ResultPair
      then ('Solution '1 '\n
            '\b 'result '\o '\s eMetaPrettyPrint(getType(RP))
            '\s '\b ': '\o '\n '\s '\s
            eMetaPrettyPrint(M, getTerm(RP)) '\n '\n)
            procSrew3(M, T, St, D, 1, SrwOpt)
      else ('No 'solution. '\n)
      fi)
    if RP := metaSrewrite(M, T, St, SrwOpt, 0) .

  ceq procSrew3(M, T, St, D, I, SrwOpt)
    = if D == unbounded or-else (D == 0 or-else I < D)
      then if RP :: ResultPair
           then ('Solution qid(string(I + 1, 10)) '\n
                 '\b 'result '\o '\s eMetaPrettyPrint(getType(RP))
                 '\s '\b ': '\o '\n '\s '\s
                 eMetaPrettyPrint(M, getTerm(RP)) '\n '\n)
                 procSrew3(M, T, St, D, s I, SrwOpt)
           else ('No 'more 'solutions. '\n)
           fi
      else nil
      fi
    if RP := metaSrewrite(M, T, St, SrwOpt, I) .

  *** FREW

  ceq procFrew(ME, M, T, D, I, VDS, DB)
    = if RP :: ResultPair
      then ('\b 'frewrite 'in '\o eMetaPrettyPrint(getHeader(getModule(TMVBN)))
            '\b ': '\o  '\n '\s '\s
            eMetaPrettyPrint(getModule(TMVBN), getTerm(TMVBN)) '\n
            '\b 'result '\o '\s eMetaPrettyPrint(getType(RP))
            '\s '\b ': '\o '\n '\s '\s
            eMetaPrettyPrint(getModule(TMVBN), getTerm(RP)) '\n)
      else ('\r 'Error: '\o 'Incorrect 'command. '\n)
      fi
    if TMVBN := solveBubblesFrew(T, M,
                 included('META-MODULE, getImports(getTopModule(ME, DB)), DB),
                 D, I, VDS, DB)
       /\ RP   := metaFrewrite(getModule(TMVBN), getTerm(TMVBN),
                               getBound(TMVBN),  getNat(TMVBN)) .
  eq procFrew(ME, unitError(QIL), T, D, I, VDS, DB) = qidError(QIL) .

  eq solveBubblesFrew('ububble[T], M, B, D, I, VDS, DB)
    = solveBubblesFrew('bubble[T], M, B, D, I, VDS, DB) .
  eq solveBubblesFrew('bubble[QI], M, B, D, I, VDS, DB)
    = if solveBubbles('bubble[QI], M, B, VDS, DB) :: Term
      then {solveBubbles('bubble[QI], M, B, VDS, DB), M, VDS, unbounded, I}
      else tupleTMOBNerror(
             '\r 'Error: '\o 'no 'parse 'for downQidList(QI) '\n)
      fi .
  eq solveBubblesFrew('bubble['__[TL]], M, B, D, I, VDS, DB)
    = if solveBubbles('bubble['__[TL]], M, B, VDS, DB) :: Term
      then {solveBubbles('bubble['__[TL]], M, B, VDS, DB),
              M, VDS, unbounded, I}
      else if metaParse(GRAMMAR-FREW, downQidList('__[TL, ''..Qid]),
                '@FrewNuPart@)
                :: ResultPair
           then solveBubblesFrew2(
                  getTerm(
                    metaParse(GRAMMAR-FREW, downQidList('__[TL, ''..Qid]),
                      '@FrewNuPart@)),
                  M, B, I, VDS, DB)
           else {getTerm(solveBubblesRed('bubble['__[TL]], M, B, VDS, DB)),
                 getModule(solveBubblesRed('bubble['__[TL]], M, B, VDS, DB)),
                 getVars(solveBubblesRed('bubble['__[TL]], M, B, VDS, DB)),
                 unbounded, I}
           fi
      fi .
  *** There is some problem parsing _ in solveBubblesRed, but it
  *** seems to work with the additional '.

  eq solveBubblesFrew2('`[_`]_.['token[T], T'], M, B, I, VDS, DB)
    = if downNat(downMetaNat(T)) :: Nat
         and-then solveBubblesRed(T', M, B, VDS, DB)
                    :: Tuple{Term,Module,Bool,VariableSet,Database}
      then {getTerm(solveBubblesRed(T', M, B, VDS, DB)),
            getModule(solveBubblesRed(T', M, B, VDS, DB)),
            getVars(solveBubblesRed(T', M, B, VDS, DB)),
            downNat(downMetaNat(T)),
            I}
      else tupleTMOBNerror(
             '\r 'Error: '\o 'Incorrect 'command. '\n)
      fi .
  eq solveBubblesFrew2('`[_`,_`]_.['token[T], 'token[T'], T''],
       M, B, I, VDS, DB)
    = if downNat(downMetaNat(T)) :: Nat
         and-then downNat(downMetaNat(T')) :: Nat
         and-then solveBubblesRed(T'', M, B, VDS, DB)
                    :: Tuple{Term,Module,Bool,VariableSet,Database}
      then {getTerm(solveBubblesRed(T'', M, B, VDS, DB)),
            getModule(solveBubblesRed(T'', M, B, VDS, DB)),
            getVars(solveBubblesRed(T'', M, B, VDS, DB)),
            downNat(downMetaNat(T)),
            downNat(downMetaNat(T'))}
      else tupleTMOBNerror('\r 'Error: '\o 'Incorrect 'command. '\n)
      fi .

  op GRAMMAR-FREW : -> FModule [memo] .
  eq GRAMMAR-FREW
    = addSorts('@FrewNuPart@ ; '@Token@ ; '@SortToken@ ; '@ViewToken@ ;
               '@NeTokenList@ ; '@Bubble@ ; '@UBubble@ ; '@StBubble@ ;
               '@EqLBubble@ ; '@RlLBubble@ ; '@SdLBubble@ ; '@RCBubble@ ; '@RBubble@,
        addOps(
          (op '`[_`]_. : '@Token@ '@UBubble@ -> '@FrewNuPart@ [none] .
           op '`[_`,_`]_. : '@Token@ '@Token@ '@UBubble@ -> '@FrewNuPart@ [none] .),
          BUBBLES)) .

  eq metaFrewrite(fmod QI is IL sorts SS . SSDS OPDS MAS EqS endfm, T, D, I)
    = metaReduce(fmod QI is IL sorts SS . SSDS OPDS MAS EqS endfm, T) .
  eq metaFrewrite(M, T, 0, I) = {T, leastSort(M, T)} .
  eq metaFrewrite(M, T, D, 0) = {T, leastSort(M, T)} .

  *** SEARCH

  op GRAMMAR-SEARCH : -> FModule [memo] .
  eq GRAMMAR-SEARCH
    = addSorts('@SearchNuPart@ ; '@Token@ ; '@SortToken@ ; '@ViewToken@ ;
               '@NeTokenList@ ; '@Bubble@ ; '@UBubble@ ; '@StBubble@ ;
               '@EqLBubble@ ; '@RlLBubble@ ; '@SdLBubble@ ; '@RCBubble@ ; '@RBubble@,
        addOps((op '`[_`,_`]_. : '@Token@ '@Token@ '@UBubble@ -> '@SearchNuPart@ [none] .)
               (op '`[`,_`]_. : '@Token@ '@UBubble@ -> '@SearchNuPart@ [none] .),
          BUBBLES)) .

  ceq procSearch(ME, M, T, T', QI, D, D', VDS, DB)
    *** D is a bound on the number of solutions, and D' is a bound on the depth of the search
    = if solveBubblesRl(T, T', M, B, VDS, DB) :: Term
      then procSearch2(M,
             lhs(solveBubblesRl(T, T', M, B, VDS, DB)),
             rhs(solveBubblesRl(T, T', M, B, VDS, DB)), nil, QI, D, D')
      else solveBubblesSearchL(M, T, T', QI, D, D', B, VDS, DB)
      fi
    if B := included('META-MODULE, getImports(getTopModule(ME, DB)), DB) .

  eq solveBubblesSearchL(M, 'ububble[T'], T, QI', D, D', B, VDS, DB)
    = solveBubblesSearchL(M, 'bubble[T'], T, QI', D, D', B, VDS, DB) .
  eq solveBubblesSearchL(M, 'bubble[QI], T, QI', D, D', B, VDS, DB)
    = if solveBubbles('bubble[QI], M, B, VDS, DB) :: Term
      then solveBubblesSearchR(M, solveBubbles('bubble[QI], M, B, VDS, DB), T, QI', D, D', B, VDS, DB)
      else ('\r 'Error: '\o 'no 'parsing 'for downQidList(QI) '\n)
      fi .
  eq solveBubblesSearchL(M, 'bubble['__[TL]], T, QI, D, D', B, VDS, DB)
    = if solveBubbles('bubble['__[TL]], M, B, VDS, DB) :: Term
      then solveBubblesSearchR(M, solveBubbles('bubble['__[TL]], M, B, VDS, DB), T, QI, D, D', B, VDS, DB)
      else if metaParse(GRAMMAR-SEARCH, downQidList('__[TL, ''..Qid]), '@SearchNuPart@) :: ResultPair
           then solveBubblesSearchL1(
                  M,
                  getTerm(metaParse(GRAMMAR-SEARCH, downQidList('__[TL, ''..Qid]), '@SearchNuPart@)),
                  T, QI, D, D', B, VDS, DB)
           else solveBubblesSearchR(
                  getModule(solveBubblesRew('bubble['__[TL]], M, B, D, VDS, DB)),
                  getTerm(solveBubblesRew('bubble['__[TL]], M, B, D, VDS, DB)),
                  T,
                  QI,
                  getBound(solveBubblesRew('bubble['__[TL]], M, B, D, VDS, DB)),
                  D',
                  getBool(solveBubblesRew('bubble['__[TL]], M, B, D, VDS, DB)),
                  getVars(solveBubblesRew('bubble['__[TL]], M, B, D, VDS, DB)),
                  getDatabase(solveBubblesRew('bubble['__[TL]], M, B, D, VDS, DB)))
           fi
      fi .

  eq solveBubblesSearchL1(M, '`[`,_`]_.['token[T], T'], T'', QI, D, D', B, VDS, DB)
    = if downNat(downMetaNat(T)) :: Nat
         and-then solveBubblesRed(T', M, B, VDS, DB) :: Tuple{Term,Module,Bool,VariableSet,Database}
      then solveBubblesSearchR(
             getModule(solveBubblesRed(T', M, B, VDS, DB)),
             getTerm(solveBubblesRed(T', M, B, VDS, DB)),
             T'', QI, D,
             downNat(downMetaNat(T)),
             B,
             getVars(solveBubblesRed(T', M, B, VDS, DB)),
             DB)
      else ('\r 'Error: '\o 'Incorrect 'command. '\n)
      fi .
  eq solveBubblesSearchL1(M, '`[_`,_`]_.['token[T], 'token[T'], T''], T''', QI, D, D', B, VDS, DB)
    = if downNat(downMetaNat(T)) :: Nat
         and-then downNat(downMetaNat(T')) :: Nat
         and-then solveBubblesRed(T'', M, B, VDS, DB) :: Tuple{Term,Module,Bool,VariableSet,Database}
      then solveBubblesSearchR(
             getModule(solveBubblesRed(T'', M, B, VDS, DB)),
             getTerm(solveBubblesRed(T'', M, B, VDS, DB)),
             T''', QI,
             downNat(downMetaNat(T)),
             downNat(downMetaNat(T')),
             B,
             getVars(solveBubblesRed(T'', M, B, VDS, DB)),
             DB)
      else ('\r 'Error: '\o 'Incorrect 'command. '\n)
      fi .

  eq solveBubblesSearchR(M, T, T', QI, D, D', B, VDS, DB)
    = solveBubblesSearchR1(
        M,
        addOps(
          op '_s.t._. : leastSort(M, T) '@Condition@ -> 'PatternCondition [none] .
          op '_such`that_. : leastSort(M, T) '@Condition@ -> 'PatternCondition [none] .,
          addSorts('PatternCondition,
            addInfoConds(M))),
        T, T', QI, D, D', B, VDS, DB) .
  eq solveBubblesSearchR(M:[Module], T:[Term], T':[Term], QI:[Qid], D:[Bound], D':[Bound], B:[Bool], VDS:[VariableSet], DB:[Database])
    = ('\r 'Error: '\o 'Incorrect 'use 'of 'the 'search 'command. '\n) .

  eq solveBubblesSearchR1(M, M', T, 'ububble[T'], QI', D, D', B, VDS, DB)
    = solveBubblesSearchR1(M, M', T, 'bubble[T'], QI', D, D', B, VDS, DB) .
  ceq solveBubblesSearchR1(M, M', T, 'bubble[QI], QI', D, D', B, VDS, DB)
    = if T?:[Term] :: Term
      then procSearch2(M, T, T?:[Term], nil, QI', D, D')
      else ('\r 'Error: '\o 'Incorrect 'use 'of 'the 'search 'command. '\n)
      fi
    if T?:[Term] := solveBubbles('bubble[QI], M, B, VDS, DB) .
  ceq solveBubblesSearchR1(M, M', T, 'bubble['__[TL]], QI, D, D', B, VDS, DB)
    = if T?:[Term] :: Term
      then procSearch2(M, T, T?:[Term], nil, QI, D, D')
      else if metaParse(M', VDS, downQidList('__[TL, ''..Qid]), 'PatternCondition) :: ResultPair
           then solveBubblesSearchR2(M, T,
                  getTerm(
                    metaParse(M', VDS, downQidList('__[TL, ''..Qid]), 'PatternCondition)),
                  QI, D, D', VDS)
           else '\r 'Error: '\o 'Incorrect 'use 'of 'the 'search 'command. '\n
           fi
      fi
    if T?:[Term] := solveBubbles('bubble['__[TL]], M, B, VDS, DB) .

  eq solveBubblesSearchR2(M, T, QI, QI', D, D', VDS)
    = procSearch2(M, T, QI, nil, QI', D, D') .
  eq solveBubblesSearchR2(M, T, F[T], QI, D, D', VDS)
    = procSearch2(M, T, F[T], nil, QI, D, D') .
  eq solveBubblesSearchR2(M, T, F[T', T''], QI, D, D', VDS)
    = if F == '_s.t._. or F == '_such`that_.
      then procSearch2(M, T, T', parseCond(T''), QI, D, D')
      else procSearch2(M, T, F[T', T''], nil, QI, D, D')
      fi .
  eq solveBubblesSearchR2(M, T, F[T', T'', TL], QI, D, D', VDS)
    = procSearch2(M, T, F[T', T'', TL], nil, QI, D, D') .

  ceq procSearch2(M, T, T', CD, QI, D, D')
    = if RT :: ResultTriple
      then ('search
            if D == unbounded and D' == unbounded
            then nil
            else '\s '`[
                 if D == unbounded
                 then nil
                 else qid(string(D, 10))
                 fi
                 if D' == unbounded
                 then nil
                 else '`, qid(string(D', 10))
                 fi
                 '`] '\s
            fi
            'in eMetaPrettyPrint(getHeader(M)) ':
            eMetaPrettyPrint(M, T) '\s qid("=>" + string(QI)) '\s
            eMetaPrettyPrint(M, T'') '. '\n '\n
            'Solution '1 '\n
            if gTSubstitution(RT) == none
            then 'empty 'substitution '\n '\n
            else eMetaPrettyPrint(M, gTSubstitution(RT)) '\n '\n
            fi
            procSearch3(M, T, T'', CD, QI, D, 1, D'))
      else if RT == failure
           then ('search
           if D == unbounded and D' == unbounded
            then nil
            else '\s '`[
                 if D == unbounded
                 then nil
                 else qid(string(D, 10))
                 fi
                 if D' == unbounded
                 then nil
                 else '`, qid(string(D', 10))
                 fi
                 '`] '\s
            fi
            'in eMetaPrettyPrint(getHeader(M)) ':
                 eMetaPrettyPrint(M, T)
                 '\s qid("=>" + string(QI)) '\s
                 eMetaPrettyPrint(M, T'') '. '\n '\n
                'No 'solution. '\n)
           else '\r 'Error: '\o 'Incorrect 'use 'of 'the 'search 'command. '\n
           fi
      fi
    if T'' := prepSearchPattern(T')
       /\ RT := metaSearch(M, T, T'', CD, QI, D', 0) .

  eq procSearch3(M, T, T', CD, QI, D, I, D')
    = if D == unbounded or-else (D == 0 or-else I < D)
      then if metaSearch(M, T, T', CD, QI, D', I) :: ResultTriple
           then ('Solution qid(string(I + 1, 10)) '\n
                 if gTSubstitution(metaSearch(M, T, T', CD, QI, D', I)) == none
                 then 'empty 'substitution '\n '\n
                 else eMetaPrettyPrint(M,
                            gTSubstitution(
                              metaSearch(M, T, T', CD, QI, D', I))) '\n '\n
                 fi
                 procSearch3(M, T, T', CD, QI, D, I + 1, D'))
           else ('No 'more 'solutions. '\n)
           fi
      else nil
      fi .

-------------------
*** Equal to procSearch except replacing metaSearch by metaNarrowSearch

  ceq procVUNarrow(ME, M, T, T', QI, D, D', VDS, DB)
    *** D is a bound on the number of solutions, and D' is a bound on the depth of the vu-narrow command
    = if solveBubblesRl(T, T', M, B, VDS, DB) :: Term
      then procVUNarrow2(M,
             lhs(solveBubblesRl(T, T', M, B, VDS, DB)),
             rhs(solveBubblesRl(T, T', M, B, VDS, DB)), nil, QI, D, D')
      else solveBubblesVUNarrowL(M, T, T', QI, D, D', B, VDS, DB)
      fi
    if B := included('META-MODULE, getImports(getTopModule(ME, DB)), DB) .

  eq solveBubblesVUNarrowL(M, 'ububble[T'], T, QI, D, D', B, VDS, DB)
    = solveBubblesVUNarrowL(M, 'bubble[T'], T, QI, D, D', B, VDS, DB) .
  eq solveBubblesVUNarrowL(M, 'bubble[QI], T, QI, D, D', B, VDS, DB)
    = if solveBubbles('bubble[QI], M, B, VDS, DB) :: Term
      then solveBubblesVUNarrowR(M, solveBubbles('bubble[QI], M, B, VDS, DB), T, QI, D, D', B, VDS, DB)
      else ('\r 'Error: '\o 'no 'parsing 'for downQidList(QI) '\n)
      fi .
  eq solveBubblesVUNarrowL(M, 'bubble['__[TL]], T, QI, D, D', B, VDS, DB)
    = if solveBubbles('bubble['__[TL]], M, B, VDS, DB) :: Term
      then solveBubblesVUNarrowR(M, solveBubbles('bubble['__[TL]], M, B, VDS, DB), T, QI, D, D', B, VDS, DB)
      else if metaParse(GRAMMAR-SEARCH, downQidList('__[TL, ''..Qid]), '@SearchNuPart@) :: ResultPair
           then solveBubblesVUNarrowL1(
                  M,
                  getTerm(
                    metaParse(GRAMMAR-SEARCH, downQidList('__[TL, ''..Qid]),
                      '@SearchNuPart@)),
                  T, QI, D, D', B, VDS, DB)
           else solveBubblesVUNarrowR(
                  getModule(solveBubblesRew('bubble['__[TL]], M, B, D, VDS, DB)),
                  getTerm(solveBubblesRew('bubble['__[TL]], M, B, D, VDS, DB)),
                  T,
                  QI,
                  getBound(solveBubblesRew('bubble['__[TL]], M, B, D, VDS, DB)),
                  D',
                  getBool(solveBubblesRew('bubble['__[TL]], M, B, D, VDS, DB)),
                  getVars(solveBubblesRew('bubble['__[TL]], M, B, D, VDS, DB)),
                  getDatabase(solveBubblesRew('bubble['__[TL]], M, B, D, VDS, DB)))
           fi
      fi .

  eq solveBubblesVUNarrowL1(M, '`[`,_`]_.['token[T], T'], T'', QI, D, D', B, VDS, DB)
    = if downNat(downMetaNat(T)) :: Nat
         and-then solveBubblesRed(T', M, B, VDS, DB) :: Tuple{Term,Module,Bool,VariableSet,Database}
      then solveBubblesVUNarrowR(
             getModule(solveBubblesRed(T', M, B, VDS, DB)),
             getTerm(solveBubblesRed(T', M, B, VDS, DB)),
             T'', QI, D,
             downNat(downMetaNat(T)),
             B,
             getVars(solveBubblesRed(T', M, B, VDS, DB)),
             DB)
      else ('\r 'Error: '\o 'Incorrect 'command. '\n)
      fi .
  eq solveBubblesVUNarrowL1(M, '`[_`,_`]_.['token[T], 'token[T'], T''], T''', QI, D, D', B, VDS, DB)
    = if downNat(downMetaNat(T)) :: Nat
         and-then downNat(downMetaNat(T')) :: Nat
         and-then solveBubblesRed(T'', M, B, VDS, DB) :: Tuple{Term,Module,Bool,VariableSet,Database}
      then solveBubblesVUNarrowR(
             getModule(solveBubblesRed(T'', M, B, VDS, DB)),
             getTerm(solveBubblesRed(T'', M, B, VDS, DB)),
             T''', QI,
             downNat(downMetaNat(T)),
             downNat(downMetaNat(T')),
             B,
             getVars(solveBubblesRed(T'', M, B, VDS, DB)),
             DB)
      else ('\r 'Error: '\o 'Incorrect 'command. '\n)
      fi .

  eq solveBubblesVUNarrowR(M, T, T', QI, D, D', B, VDS, DB)
    = solveBubblesVUNarrowR1(
        M,
        addOps(
          op '_s.t._. : leastSort(M, T) '@Condition@ -> 'PatternCondition [none] .
          op '_such`that_. : leastSort(M, T) '@Condition@ -> 'PatternCondition [none] .,
          addSorts('PatternCondition, addInfoConds(M))),
        T,
        T',
        QI,
        D,
        D',
        B,
        VDS,
        DB) .
  eq solveBubblesVUNarrowR(M:[Module], T:[Term], T':[Term], QI:[Qid], D:[Bound], D':[Bound], B:[Bool], VDS:[VariableSet], DB:[Database])
    = qidError('\r 'Error: '\o 'Incorrect 'use 'of 'the 'vu-narrow 'command. '\n) .

  eq solveBubblesVUNarrowR1(M, M', T, 'ububble[T'], QI', D, D', B, VDS, DB)
    = solveBubblesVUNarrowR1(M, M', T, 'bubble[T'], QI', D, D', B, VDS, DB) .
  ceq solveBubblesVUNarrowR1(M, M', T, 'bubble[QI], QI', D, D', B, VDS, DB)
    = if T?:[Term] :: Term
      then procVUNarrow2(M, T, T?:[Term], nil, QI', D, D')
      else ('\r 'Error: '\o 'Incorrect 'use 'of 'the 'vu-narrow 'command. '\n)
      fi
    if T?:[Term] := solveBubbles('bubble[QI], M, B, VDS, DB) .
  ceq solveBubblesVUNarrowR1(M, M', T, 'bubble['__[TL]], QI, D, D', B, VDS, DB)
    = if T?:[Term] :: Term
      then procVUNarrow2(M, T, T?:[Term], nil, QI, D, D')
      else if metaParse(M', VDS, downQidList('__[TL, ''..Qid]), 'PatternCondition) :: ResultPair
           then solveBubblesVUNarrowR2(M, T,
                  getTerm(
                    metaParse(M', VDS, downQidList('__[TL, ''..Qid]), 'PatternCondition)),
                  QI, D, D', VDS)
           else '\r 'Error: '\o 'Incorrect 'use 'of 'the 'vu-narrow 'command. '\n
           fi
      fi
    if T?:[Term] := solveBubbles('bubble['__[TL]], M, B, VDS, DB) .

  eq solveBubblesVUNarrowR2(M, T, QI, QI', D, I, VDS)
    = procVUNarrow2(M, T, QI, nil, QI', D, I) .
  eq solveBubblesVUNarrowR2(M, T, F[T], QI, D, I, VDS)
    = procVUNarrow2(M, T, F[T], nil, QI, D, I) .
  eq solveBubblesVUNarrowR2(M, T, F[T', T''], QI, D, I, VDS)
    = if F == '_s.t._. or F == '_such`that_.
      then procVUNarrow2(M, T, T', parseCond(T''), QI, D, I)
      else procVUNarrow2(M, T, F[T', T''], nil, QI, D, I)
      fi .
  eq solveBubblesVUNarrowR2(M, T, F[T', T'', TL], QI, D, I, VDS)
    = procVUNarrow2(M, T, F[T', T'', TL], nil, QI, D, I) .

----  op axCohComplete : SModule -> SModule .       ---- Defined later in module AX-COHERENCE-COMPLETION

  ceq procVUNarrow2(M, T, T', CD, QI, D, D')
    = if Mx:[Module] :: Module and RTS:[ResultTripleSet] :: ResultTripleSet
      then ('vu-narrow
            if D == unbounded and D' == unbounded
            then nil
            else '\s '`[
                 if D == unbounded
                 then nil
                 else qid(string(D, 10))
                 fi
                 if D' == unbounded
                 then nil
                 else '`, qid(string(D', 10))
                 fi
                 '`] '\s
            fi
            'in eMetaPrettyPrint(getHeader(M)) ':
            eMetaPrettyPrint(M, T) '\s qid("~>" + string(QI)) '\s
            eMetaPrettyPrint(M, T'') '.
            procVUNarrow3(M, 0, Vars((T,T')), RTS:[ResultTripleSet])
            if D =/= unbounded and-then D' == unbounded and-then | RTS:[ResultTripleSet] | < D
            then procVUNarrow2RT(M, T, T', CD, QI, D, D',RTS:[ResultTripleSet],1)
            else nil
            fi
            ('\n '\n 'No 'more 'solutions. '\n))
      else if RTS:[ResultTripleSet] == empty
           then ('vu-narrow
                if D == unbounded and D' == unbounded
                then nil
                else '\s '`[
                     if D == unbounded
                     then nil
                     else qid(string(D, 10))
                     fi
                     if D' == unbounded
                     then nil
                     else '`, qid(string(D', 10))
                     fi
                     '`] '\s
                fi
                'in eMetaPrettyPrint(getHeader(M)) ':
                   eMetaPrettyPrint(M, T)
                   '\s qid("~>" + string(QI)) '\s
                   eMetaPrettyPrint(M, T'') '. '\n '\n
                   'No 'solution. '\n)
           else if getMsg(Mx:[Module]) :: QidList
	        then getMsg(Mx:[Module])
		else '\r 'Error: '\o 'Incorrect 'use 'of 'the 'vu-narrow 'command. '\n
		fi
           fi
      fi
    if T'' := prepSearchPattern(T')
       /\ Mx:[Module] := removeIds(axCohComplete(M), non-handled)
       /\ RTS:[ResultTripleSet]
          := upDown(M,
              metaVUNarrow(
                 Mx:[Module],
                 T,
                 T'',
                 none,
		 QI,
                 D',
                 D,
                 unbounded)
              |> (T,T'')
             ) .

  op procVUNarrow2RT : Module Term Term Condition Qid Bound Bound ResultTripleSet Nat -> QidList .
  ceq procVUNarrow2RT(M, T, T', CD, QI, D, D',RTS',J)
    = nil
   if | RTS' | == D .
  ceq procVUNarrow2RT(M, T, T', CD, QI, D, D',RTS',J)
    = if RTS:[ResultTripleSet] :: ResultTripleSet
      then (procVUNarrow3(M, | RTS' |, Vars((T,T')), RTS:[ResultTripleSet])
            procVUNarrow2RT(M, T, T', CD, QI, D, D',RTS' | RTS:[ResultTripleSet],J + 1) )
      else nil
      fi
    if | RTS' | < D
       /\ T'' := prepSearchPattern(T')
       /\ (RTS' | RTS:[ResultTripleSet])
          := upDown(M,
              metaVUNarrow(
                 removeIds(axCohComplete(M), non-handled),
                 T,
                 T'',
                 none,
                 QI,
                 D',
                 D + J,
                 unbounded)
              |> (T,T'')
             ) .

  eq procVUNarrow3(M, I, TL:TermList, empty)
   = nil .
  eq procVUNarrow3(M, I, TL:TermList, {T:Term,TP:Type,S:Substitution} | RTS:ResultTripleSet)
    = ('\n '\n 'Solution qid(string(I + 1, 10))
       if (S:Substitution |> TL:TermList) == none
       then '\n 'empty 'substitution
       else '\n eMetaPrettyPrint(M, S:Substitution |> TL:TermList)
       fi
       procVUNarrow3(M, I + 1, TL:TermList, RTS:ResultTripleSet)) .

-------------------
-------------------
*** Equal to procSearch except replacing metaSearch by metaNarrowSearch

  ceq procNarrowSearch(ME, M, T, T', QI, D, D', VDS, DB)
    *** D is a bound on the number of solutions, and D' is a bound on the depth of the search
    = if solveBubblesRl(T, T', M, B, VDS, DB) :: Term
      then procNarrowSearch2(M,
             lhs(solveBubblesRl(T, T', M, B, VDS, DB)),
             rhs(solveBubblesRl(T, T', M, B, VDS, DB)), nil, QI, D, D')
      else solveBubblesNarrowSearchL(M, T, T', QI, D, D', B, VDS, DB)
      fi
    if B := included('META-MODULE, getImports(getTopModule(ME, DB)), DB) .

  eq solveBubblesNarrowSearchL(M, 'ububble[T'], T, QI, D, D', B, VDS, DB)
    = solveBubblesNarrowSearchL(M, 'bubble[T'], T, QI, D, D', B, VDS, DB) .
  eq solveBubblesNarrowSearchL(M, 'bubble[QI], T, QI, D, D', B, VDS, DB)
    = if solveBubbles('bubble[QI], M, B, VDS, DB) :: Term
      then solveBubblesNarrowSearchR(M, solveBubbles('bubble[QI], M, B, VDS, DB), T, QI, D, D', B, VDS, DB)
      else ('\r 'Error: '\o 'no 'parsing 'for downQidList(QI) '\n)
      fi .
  eq solveBubblesNarrowSearchL(M, 'bubble['__[TL]], T, QI, D, D', B, VDS, DB)
    = if solveBubbles('bubble['__[TL]], M, B, VDS, DB) :: Term
      then solveBubblesNarrowSearchR(M, solveBubbles('bubble['__[TL]], M, B, VDS, DB), T, QI, D, D', B, VDS, DB)
      else if metaParse(GRAMMAR-SEARCH, VDS, downQidList('__[TL, ''..Qid]), '@SearchNuPart@) :: ResultPair
           then solveBubblesNarrowSearchL1(
                  M,
                  getTerm(
                    metaParse(GRAMMAR-SEARCH, downQidList('__[TL, ''..Qid]), '@SearchNuPart@)),
                  T, QI, D, D', B, VDS, DB)
           else solveBubblesNarrowSearchR(
                  getModule(solveBubblesRew('bubble['__[TL]], M, B, D, VDS, DB)),
                  getTerm(solveBubblesRew('bubble['__[TL]], M, B, D, VDS, DB)),
                  T,
                  QI,
                  getBound(solveBubblesRew('bubble['__[TL]], M, B, D, VDS, DB)),
                  D',
                  getBool(solveBubblesRew('bubble['__[TL]], M, B, D, VDS, DB)),
                  getVars(solveBubblesRew('bubble['__[TL]], M, B, D, VDS, DB)),
                  getDatabase(solveBubblesRew('bubble['__[TL]], M, B, D, VDS, DB)))
           fi
      fi .

  eq solveBubblesNarrowSearchL1(M, '`[`,_`]_.['token[T], T'], T'', QI, D, D', B, VDS, DB)
    = if downNat(downMetaNat(T)) :: Nat
         and-then solveBubblesRed(T', M, B, VDS, DB) :: Tuple{Term,Module,Bool,VariableSet,Database}
      then solveBubblesNarrowSearchR(
             getModule(solveBubblesRed(T', M, B, VDS, DB)),
             getTerm(solveBubblesRed(T', M, B, VDS, DB)),
             T'', QI, D,
             downNat(downMetaNat(T)),
             B,
             getVars(solveBubblesRed(T', M, B, VDS, DB)),
             DB)
      else ('\r 'Error: '\o 'Incorrect 'command. '\n)
      fi .
  eq solveBubblesNarrowSearchL1(M, '`[_`,_`]_.['token[T], 'token[T'], T''], T''', QI, D, D', B, VDS, DB)
    = if downNat(downMetaNat(T)) :: Nat
         and-then downNat(downMetaNat(T')) :: Nat
         and-then solveBubblesRed(T'', M, B, VDS, DB) :: Tuple{Term,Module,Bool,VariableSet,Database}
      then solveBubblesNarrowSearchR(
             getModule(solveBubblesRed(T'', M, B, VDS, DB)),
             getTerm(solveBubblesRed(T'', M, B, VDS, DB)),
             T''', QI,
             downNat(downMetaNat(T)),
             downNat(downMetaNat(T')),
             B,
             getVars(solveBubblesRed(T'', M, B, VDS, DB)),
             DB)
      else ('\r 'Error: '\o 'Incorrect 'command. '\n)
      fi .

  eq solveBubblesNarrowSearchR(M, T, T', QI, D, D', B, VDS, DB)
    = solveBubblesNarrowSearchR1(
        M,
        addOps(
          op '_s.t._. : leastSort(M, T) '@Condition@ -> 'PatternCondition [none] .
          op '_such`that_. : leastSort(M, T) '@Condition@ -> 'PatternCondition [none] .,
          addSorts('PatternCondition, addInfoConds(M))),
        T,
        T',
        QI,
        D,
        D',
        B,
        VDS,
        DB) .
  eq solveBubblesNarrowSearchR(M:[Module], T:[Term], T':[Term], QI:[Qid], D:[Bound], D':[Bound], B:[Bool], VDS:[VariableSet], DB:[Database])
    = '\r 'Error: '\o 'Incorrect 'use 'of 'the 'search 'command. '\n .

  eq solveBubblesNarrowSearchR1(M, M', T, 'ububble[T'], QI', D, D', B, VDS, DB)
    = solveBubblesNarrowSearchR1(M, M', T, 'bubble[T'], QI', D, D', B, VDS, DB) .
  ceq solveBubblesNarrowSearchR1(M, M', T, 'bubble[QI], QI', D, D', B, VDS, DB)
    = if T?:[Term] :: Term
      then procNarrowSearch2(M, T, T?:[Term], nil, QI', D, D')
      else ('\r 'Error: '\o 'Incorrect 'use 'of 'the 'search 'command. '\n)
      fi
    if T?:[Term] := solveBubbles('bubble[QI], M, B, VDS, DB) .
  ceq solveBubblesNarrowSearchR1(M, M', T, 'bubble['__[TL]], QI, D, D', B, VDS, DB)
    = if T?:[Term] :: Term
      then procNarrowSearch2(M, T, T?:[Term], nil, QI, D, D')
      else if metaParse(M', VDS, downQidList('__[TL, ''..Qid]), 'PatternCondition)
                :: ResultPair
           then solveBubblesNarrowSearchR2(M, T,
                  getTerm(
                    metaParse(M', VDS, downQidList('__[TL, ''..Qid]), 'PatternCondition)),
                  QI, D, D', VDS)
           else '\r 'Error: '\o 'Incorrect 'use 'of 'the 'search 'command. '\n
           fi
      fi
    if T?:[Term] := solveBubbles('bubble['__[TL]], M, B, VDS, DB) .

  eq solveBubblesNarrowSearchR2(M, T, QI, QI', D, I, VDS)
    = procNarrowSearch2(M, T, QI, nil, QI', D, I) .
  eq solveBubblesNarrowSearchR2(M, T, F[T], QI, D, I, VDS)
    = procNarrowSearch2(M, T, F[T], nil, QI, D, I) .
  eq solveBubblesNarrowSearchR2(M, T, F[T', T''], QI, D, I, VDS)
    = if F == '_s.t._. or F == '_such`that_.
      then procNarrowSearch2(M, T, T', parseCond(T''), QI, D, I)
      else procNarrowSearch2(M, T, F[T', T''], nil, QI, D, I)
      fi .
  eq solveBubblesNarrowSearchR2(M, T, F[T', T'', TL], QI, D, I, VDS)
    = procNarrowSearch2(M, T, F[T', T'', TL], nil, QI, D, I) .

----  op axCohComplete : SModule -> SModule .       ---- Defined later in module AX-COHERENCE-COMPLETION

  sort IdsToRemove .                             ---- moved from FM-VARIANTS
  ops all non-handled : -> IdsToRemove .         ---- moved from FM-VARIANTS
  op removeIds : Module IdsToRemove ~> Module .  ---- moved from FM-VARIANTS

  ceq procNarrowSearch2(M, T, T', CD, QI, D, D')
    = if Mx:[Module] :: Module and RTS:[ResultTripleSet] :: ResultTripleSet
      then ('search
            if D == unbounded and D' == unbounded
            then nil
            else '\s '`[
                 if D == unbounded
                 then nil
                 else qid(string(D, 10))
                 fi
                 if D' == unbounded
                 then nil
                 else '`, qid(string(D', 10))
                 fi
                 '`] '\s
            fi
            'in eMetaPrettyPrint(getHeader(M)) ':
            eMetaPrettyPrint(M, T) '\s qid("~>" + string(QI)) '\s
            eMetaPrettyPrint(M, T'') '.
            procNarrowSearch3(M, 0, Vars((T,T')), RTS:[ResultTripleSet])
            if D =/= unbounded and-then D' == unbounded and-then | RTS:[ResultTripleSet] | < D
            then procNarrowSearch2RT(M, T, T', CD, QI, D, D',RTS:[ResultTripleSet],1)
            else nil
            fi
            ('\n '\n 'No 'more 'solutions. '\n))
      else if RTS:[ResultTripleSet] == empty
           then ('search
                if D == unbounded and D' == unbounded
                then nil
                else '\s '`[
                     if D == unbounded
                     then nil
                     else qid(string(D, 10))
                     fi
                     if D' == unbounded
                     then nil
                     else '`, qid(string(D', 10))
                     fi
                     '`] '\s
                fi
                'in eMetaPrettyPrint(getHeader(M)) ':
                   eMetaPrettyPrint(M, T)
                   '\s qid("~>" + string(QI)) '\s
                   eMetaPrettyPrint(M, T'') '. '\n '\n
                   'No 'solution. '\n)
           else if getMsg(Mx:[Module]) :: QidList
	        then getMsg(Mx:[Module])
		else '\r 'Error: '\o 'Incorrect 'use 'of 'the 'search 'command. '\n
		fi
           fi
      fi
    if T'' := prepSearchPattern(T')
       /\ Mx:[Module] := removeIds(axCohComplete(M), non-handled)
       /\ RTS:[ResultTripleSet]
          := upDown(M,
              metaNarrowSearchGen(
                 Mx:[Module],
                 T,
                 T'',
                 none,
                 typeOfRelation(QI),
                 D',
                 D,
                 unbounded,
                 full E-ACU-unify noStrategy E-normalize-terms)
              |> (T,T'')
             ) .

  var RTS' : ResultTripleSet .

  op procNarrowSearch2RT : Module Term Term Condition Qid Bound Bound ResultTripleSet Nat -> QidList .
  ceq procNarrowSearch2RT(M, T, T', CD, QI, D, D',RTS',J)
    = nil
   if | RTS' | == D .
  ceq procNarrowSearch2RT(M, T, T', CD, QI, D, D',RTS',J)
    = if RTS:[ResultTripleSet] :: ResultTripleSet
      then (procNarrowSearch3(M, | RTS' |, Vars((T,T')), RTS:[ResultTripleSet])
            procNarrowSearch2RT(M, T, T', CD, QI, D, D',RTS' | RTS:[ResultTripleSet],J + 1) )
      else nil
      fi
    if | RTS' | < D
       /\ T'' := prepSearchPattern(T')
       /\ (RTS' | RTS:[ResultTripleSet])
          := upDown(M,
              metaNarrowSearchGen(
                 removeIds(axCohComplete(M), non-handled),
                 T,
                 T'',
                 none,
                 typeOfRelation(QI),
                 D',
                 D + J,
                 unbounded,
                 full E-ACU-unify noStrategy E-normalize-terms)
              |> (T,T'')
             ) .

  eq procNarrowSearch3(M, I, TL:TermList, empty)
   = nil .
  eq procNarrowSearch3(M, I, TL:TermList, {T:Term,TP:Type,S:Substitution} | RTS:ResultTripleSet)
    = ('\n '\n 'Solution qid(string(I + 1, 10))
       if (S:Substitution |> TL:TermList) == none
       then '\n 'empty 'substitution
       else '\n eMetaPrettyPrint(M, S:Substitution |> TL:TermList)
       fi
       procNarrowSearch3(M, I + 1, TL:TermList, RTS:ResultTripleSet)) .

-------------------

  sort Tuple{TermList, Nat} .
  op <_;_> : Term Nat -> Tuple{TermList, Nat} .
  op term : Tuple{TermList, Nat} -> TermList .
  op index : Tuple{TermList, Nat} -> Nat .
  eq term(< TL:[TermList] ; I:[Nat] >) = TL:[TermList] .
  eq index(< TL:[TermList] ; I:[Nat] >) = I:[Nat] .

  op prepSearchPattern : Term -> Term .
  op prepSearchPattern : TermList Nat -> Tuple{TermList, Nat} .

  eq prepSearchPattern(T) = term(prepSearchPattern(T, 0)) .

  eq prepSearchPattern('<_:_|_>[OT, Ct, T], I)
    = < '<_:_|_>[OT, qid("V#" + string(I, 10) + ":" + string(getName(Ct))),
           '_`,_[term(prepSearchPattern(T, s s I)),
                 qid("V#" + string(s I, 10) + ":AttributeSet")]] ;
        index(prepSearchPattern(T, s s I)) > .
  eq prepSearchPattern('<_:_|`>[OT, Ct], I)
    = < '<_:_|_>[OT, qid("V#" + string(I, 10) + ":" + string(getName(Ct))),
           qid("V#" + string(s I, 10) + ".AttributeSet")] ;
        s I > .
  eq prepSearchPattern(F[TL], I)
    = < F[term(prepSearchPattern(TL, I))] ; index(prepSearchPattern(TL, I)) >
    [owise] .

  eq prepSearchPattern(F, I) = < F ; I > .
  ----eq prepSearchPattern(Ct, I) = < Ct ; I > .

  ceq prepSearchPattern((T, TL), I)
    = < (term(prepSearchPattern(T, I)),
         term(prepSearchPattern(TL, index(prepSearchPattern(T, I))))) ;
        index(prepSearchPattern(TL, index(prepSearchPattern(T, I)))) >
    if TL =/= empty .

  *** MATCH

  ceq procMatch(ME, M, T, T', QI, I, VDS, DB)
    *** the number I the number of solutions
    = if solveBubblesRl(T, T', M, B, VDS, DB) :: Term
      then procMatch2(M,
             lhs(solveBubblesRl(T, T', M, B, VDS, DB)),
             rhs(solveBubblesRl(T, T', M, B, VDS, DB)), nil, QI, I)
      else if solveBubblesRew(T, M, B, I, VDS, DB)
                :: Tuple{Term,Module,Bool,VariableSet,Bound,Database}
           then solveBubblesMatch(
                  getModule(solveBubblesRew(T, M, B, I, VDS, DB)),
                  addOps(
                    op '_s.t._. :
                       leastSort(
                         getModule(solveBubblesRew(T, M, B, I, VDS, DB)),
                         getTerm(solveBubblesRew(T, M, B, I, VDS, DB)))
                       '@Condition@ -> 'PatternCondition [none] .
                    op '_such`that_. :
                       leastSort(
                         getModule(solveBubblesRew(T, M, B, I, VDS, DB)),
                         getTerm(solveBubblesRew(T, M, B, I, VDS, DB)))
                       '@Condition@ -> 'PatternCondition [none] .,
                    addSorts('PatternCondition,
                      addInfoConds(
                        getModule(solveBubblesRew(T, M, B, I, VDS, DB))))),
                  getTerm(solveBubblesRew(T, M, B, I, VDS, DB)),
                  T',
                  QI,
                  (if getBound(solveBubblesRew(T, M, B, I, VDS, DB))
                         == unbounded
                   then 0
                   else getBound(solveBubblesRew(T, M, B, I, VDS, DB))
                   fi),
                  B,
                  getVars(solveBubblesRew(T, M, B, I, VDS, DB)),
                  DB)
           else getMsg(solveBubblesRew(T, M, B, I, VDS, DB))
           fi
      fi
    if B := included('META-MODULE, getImports(getTopModule(ME, DB)), DB) .

  eq solveBubblesMatch(M, M', T, 'ububble[T'], QI', I, B, VDS, DB)
    = solveBubblesMatch(M, M', T, 'bubble[T'], QI', I, B, VDS, DB) .
  ceq solveBubblesMatch(M, M', T, 'bubble[QI], QI', I, B, VDS, DB)
    = if T?:[Term] :: Term
      then procMatch2(M, T, T?:[Term], nil, QI', I)
      else ('\r 'Error: '\o 'Incorrect 'use 'of 'the 'match 'command. '\n)
      fi
    if T?:[Term] := solveBubbles('bubble[QI], M, B, VDS, DB) .
  ceq solveBubblesMatch(M, M', T, 'bubble['__[TL]], QI, I, B, VDS, DB)
    = if T?:[Term] :: Term
      then procMatch2(M, T, T?:[Term], nil, QI, I)
      else if metaParse(M', VDS, downQidList('__[TL, ''..Qid]), 'PatternCondition) :: ResultPair
           then solveBubblesMatch2(M, T,
                  getTerm(
                    metaParse(M', VDS, downQidList('__[TL, ''..Qid]), 'PatternCondition)),
                  QI, I, VDS)
           else '\r 'Error: '\o 'Incorrect 'use 'of 'the 'match 'command. '\n
           fi
      fi
    if T?:[Term] := solveBubbles('bubble['__[TL]], M, B, VDS, DB) .

  eq solveBubblesMatch2(M, T, QI, QI', I, VDS)
    = procMatch2(M, T, QI, nil, QI', I) .
  eq solveBubblesMatch2(M, T, F[T], QI, I, VDS)
    = procMatch2(M, T, F[T], nil, QI, I) .
  eq solveBubblesMatch2(M, T, F[T', T''], QI, I, VDS)
    = if F == '_s.t._. or F == '_such`that_.
      then procMatch2(M, T, T', parseCond(T''), QI, I)
      else procMatch2(M, T, F[T', T''], nil, QI, I)
      fi .
  eq solveBubblesMatch2(M, T, F[T', T'', TL], QI, I, VDS)
    = procMatch2(M, T, F[T', T'', TL], nil, QI, I) .

  ceq procMatch2(M, T, T', CD, 'match, I)
    = if Sb? :: Substitution
      then ('match
            if I == 0 then nil else '\s '`[ qid(string(I, 10)) '`] '\s fi
            'in eMetaPrettyPrint(getHeader(M)) ':
            eMetaPrettyPrint(M, T) '\s '<=? '\s eMetaPrettyPrint(M, T') '. '\n '\n
            'Solution '1 '\n
            if Sb? == none
            then 'empty 'substitution
            else eMetaPrettyPrint(M, Sb?)
            fi '\n '\n
            procMatch3(M, T, T', CD, 'match, I, 1))
      else if Sb? == noMatch
           then ('match
                 if I == 0
                 then nil
                 else '\s '`[ qid(string(I, 10)) '`] '\s
                 fi
                 'in eMetaPrettyPrint(getHeader(M)) ':
                       eMetaPrettyPrint(M, T) '\s '<=? '\s
                       eMetaPrettyPrint(M, T') '. '\n '\n
                       'No 'solution. '\n)
           else '\r 'Error: '\o 'Incorrect 'use 'of 'the 'match 'command. '\n
           fi
      fi
    if Sb? := metaMatch(M, T, T', CD, 0) .
  ceq procMatch2(M, T, T', CD, 'xmatch, I)
    = if MP? :: MatchPair
      then ('xmatch
            if I == 0 then nil else '\s '`[ qid(string(I, 10)) '`] '\s fi
            'in eMetaPrettyPrint(getHeader(M)) ':
            eMetaPrettyPrint(M, T) '\s '<=? '\s eMetaPrettyPrint(M, T') '. '\n '\n
            'Solution '1 '\n
            if gTSubstitution(MP?) == none
            then 'empty 'substitution
            else eMetaPrettyPrint(M, gTSubstitution(MP?))
            fi '\n '\n
            procMatch3(M, T, T', CD, 'xmatch, I, 1))
      else if MP? == noMatch
           then ('xmatch
                 if I == 0
                 then nil
                 else '\s '`[ qid(string(I, 10)) '`] '\s
                 fi
                 'in eMetaPrettyPrint(getHeader(M)) ':
                      eMetaPrettyPrint(M, T) '\s '<=? '\s
                      eMetaPrettyPrint(M, T') '. '\n '\n
                      'No 'solution. '\n)
           else '\r 'Error: '\o 'Incorrect 'use 'of 'the 'xmatch 'command. '\n
           fi
      fi
    if MP? := metaXmatch(M, T, T', CD, 0, unbounded, 0) .

  eq procMatch3(M, T, T', CD, 'match, I, J)
    = if I == 0 or J < I
      then if metaMatch(M, T, T', CD, J) :: Substitution
           then ('Solution qid(string(J + 1, 10)) '\n
                 if metaMatch(M, T, T', CD, J) == none
                 then 'empty 'substitution
                 else eMetaPrettyPrint(M, metaMatch(M, T, T', CD, J))
                 fi '\n '\n
                 procMatch3(M, T, T', CD, 'match, I, J + 1))
           else ('No 'more 'solutions. '\n)
           fi
      else nil
      fi .
  eq procMatch3(M, T, T', CD, 'xmatch, I, J)
    = if I == 0 or J < I
      then if metaXmatch(M, T, T', CD, 0, unbounded, J) :: MatchPair
           then ('Solution qid(string(J + 1, 10)) '\n
                 if gTSubstitution(metaXmatch(M, T, T', CD, 0, unbounded, J))
                      == none
                 then 'empty 'substitution
                 else eMetaPrettyPrint(M,
                            gTSubstitution(
                               metaXmatch(M, T, T', CD, 0, unbounded, J)))
                 fi '\n '\n
                 procMatch3(M, T, T', CD, 'xmatch, I, J + 1))
           else ('No 'more 'solutions. '\n)
           fi
      else nil
      fi .

  *** UNIFY

  ceq procUnify(ME, M, T, D, VDS, DB)
    *** D is a bound on the number of solutions
    = if solveBubblesRewUnify(T, addInfoUnify(M), B, D, VDS, DB)
           :: Tuple{Term,Module,Bool,VariableSet,Bound,Database}
      then procUnify2(
             getModule(solveBubblesRewUnify(T, addInfoUnify(M), B, D, VDS, DB)),
             parseUnify(
               getTerm(solveBubblesRewUnify(T, addInfoUnify(M), B, D, VDS, DB)),
               getVars(solveBubblesRewUnify(T, addInfoUnify(M), B, D, VDS, DB))),
             getBound(solveBubblesRewUnify(T, addInfoUnify(M), B, D, VDS, DB)))
      else getMsg(solveBubblesRewUnify(T, addInfoUnify(M), B, D, VDS, DB))
      fi
    if B := included('META-MODULE, getImports(getTopModule(ME, DB)), DB) .

  eq addInfoUnify(M)
    = addOps(op '_/\_ : '@UnificationProblem@ '@UnificationProblem@ -> '@UnificationProblem@
                               [ctor assoc prec(73)] .
             op '_=?_  : 'Universal 'Universal -> '@UnificationProblem@
                               [ctor poly(1 2) prec(71)] .,
        addSorts('@UnificationProblem@, M)) .

  eq parseUnify('_/\_[T, T'], VDS) = parseUnify(T, VDS) /\ parseUnify(T', VDS) .
  eq parseUnify('_=?_[T, T'], VDS) = T =? T' .

  ceq procUnify2(M, UP, D)
    = if UP? :: UnificationPair?
      then ('unify
            if D == unbounded then nil else '\s '`[ qid(string(D, 10)) '`] '\s fi
            'in eMetaPrettyPrint(getHeader(M)) ':
            eMetaPrettyPrint(M, UP) '\n '\n
            if UP? == noUnifier
            then 'No 'unifier
            else procUnify3Aux(M, UP?, 0) ----'\n '\n
                 procUnify3(M, UP, D, 1)
            fi)
      else '\r 'Error: '\o 'Incorrect 'use 'of 'the 'unify 'command. '\n
      fi
    if UP? := metaUnify(M, UP, 0, 0) .
  eq procUnify2(M?, UP??:[UnificationProblem], D?) = getMsg(M?) [owise] .

  eq eMetaPrettyPrint(M, T =? T')
    = eMetaPrettyPrint(M, T) '\s '=? '\s eMetaPrettyPrint(M, T') '. .
  eq eMetaPrettyPrint(M, T =? T' /\ UP)
    = eMetaPrettyPrint(M, T =? T') '\s '/\ '\s eMetaPrettyPrint(M, UP) '. .

  eq procUnify3Aux(M, {Sb, N}, I)
    = 'Solution qid(string(I + 1, 10)) '\n
      if Sb == none
      then 'empty 'substitution '\n '\n
      else eMetaPrettyPrint(M, Sb) '\n '\n
      fi .

  eq procUnify3(M, UP, D, I)
    = if D == unbounded or-else I < D
      then if metaUnify(M, UP, 0, I) :: UnificationPair
           then (procUnify3Aux(M, metaUnify(M, UP, 0, I), I)
                 procUnify3(M, UP, D, I + 1))
           else ('No 'more 'solutions. '\n)
           fi
      else nil
      fi .

  eq solveBubblesUnify(M, 'ububble[T], VDS)
    = solveBubblesUnify(M, 'bubble[T], VDS) .
  ceq solveBubblesUnify(M, 'bubble[T], VDS)
    = if metaParse(M, VDS, QIL, '@UnificationProblem@) :: ResultPair
      then parseUnify(getTerm(metaParse(M, VDS, QIL, '@UnificationProblem@)), VDS)
      else unificationProblemError('\r 'Warning: '\o
             printSyntaxError(metaParse(M, VDS, QIL, '@UnificationProblem@), QIL) '\n)
      fi
    if QIL := downQidList(T) .

  eq solveBubblesRewUnify('ububble[T], M, B, D, VDS, DB)
    = solveBubblesRewUnify('bubble[T], M, B, D, VDS, DB) .
  eq solveBubblesRewUnify('bubble[QI], M, B, D, VDS, DB)
    = if solveBubbles('bubble[QI], M, B, VDS, DB) :: Term
      then {solveBubbles('bubble[QI], M, B, VDS, DB), M, B, VDS, unbounded, DB}
      else tupleTMBOBDerror(
             '\r 'Error: '\o 'no 'parsing 'for downQidList(QI) '\n)
      fi .
  eq solveBubblesRewUnify('bubble['__[TL]], M, B, D, VDS, DB)
    = if solveBubbles('bubble['__[TL]], M, B, VDS, DB) :: Term
      then {solveBubbles('bubble['__[TL]], M, B, VDS, DB), M, B, VDS, unbounded, DB}
      else if metaParse(GRAMMAR-REW, downQidList('__[TL, ''..Qid]), '@RewNuPart@) :: ResultPair
           then solveBubblesRewUnify2(
                  getTerm(
                    metaParse(GRAMMAR-REW, downQidList('__[TL, ''..Qid]), '@RewNuPart@)),
                  M, B, VDS, DB)
           else {getTerm(solveBubblesRedUnify('bubble['__[TL]], M, B, VDS, DB)),
                 getModule(solveBubblesRedUnify('bubble['__[TL]], M, B, VDS, DB)),
                 getBool(solveBubblesRedUnify('bubble['__[TL]], M, B, VDS, DB)),
                 getVars(solveBubblesRedUnify('bubble['__[TL]], M, B, VDS, DB)),
                 unbounded,
                 getDatabase(solveBubblesRedUnify('bubble['__[TL]], M, B, VDS, DB))}
           fi
      fi .

  eq solveBubblesRewUnify2('`[_`]_.['token[T], T'], M, B, VDS, DB)
    = if downNat(downMetaNat(T)) :: Nat
         and-then solveBubblesRedUnify(T', M, B, VDS, DB)
                    :: Tuple{Term,Module,Bool,VariableSet,Database}
      then {getTerm(solveBubblesRedUnify(T', M, B, VDS, DB)),
            getModule(solveBubblesRedUnify(T', M, B, VDS, DB)),
            getBool(solveBubblesRedUnify(T', M, B, VDS, DB)),
            getVars(solveBubblesRedUnify(T', M, B, VDS, DB)),
            downNat(downMetaNat(T)),
            getDatabase(solveBubblesRedUnify(T', M, B, VDS, DB))}
      else tupleTMBOBDerror('\r 'Error: '\o 'Incorrect 'command. '\n)
      fi .

  eq solveBubblesRedUnify('ububble[T], M, B, VDS, DB)
    = solveBubblesRedUnify('bubble[T], M, B, VDS, DB) .
  ceq solveBubblesRedUnify('bubble[QI], M, B, VDS, DB)
    = if T? :: Term
      then {T?, M, B, VDS, DB}
      else tupleTMBODerror('\r 'Error: '\o 'no 'parse 'for downQidList(QI) '\n)
      fi
    if T? := solveBubbles('bubble[QI], M, B, VDS, DB) .
  ceq solveBubblesRedUnify('bubble['__[TL]], M, B, VDS, DB)
    = if T? :: Term
      then {T?, M, B, VDS, DB}
      else if metaParse(GRAMMAR-RED, downQidList('__[TL, ''..Qid]), '@RedInPart@)
                :: ResultPair
           then solveBubblesRedUnify2(
                  getTerm(
                    metaParse(GRAMMAR-RED, downQidList('__[TL, ''..Qid]), '@RedInPart@)),
                  DB)
           else tupleTMBODerror('\r 'Warning: '\o
                      printSyntaxError(
                        metaParse(GRAMMAR-RED, downQidList('__[TL, ''..Qid]),
                        '@RedInPart@), downQidList('__[TL, ''..Qid])) '\n
                      '\r 'Error: '\o
                      'no 'parse 'for downQidList('__[TL, ''..Qid]) '\n)
           fi
      fi
    if T? := solveBubbles('bubble['__[TL]], M, B, VDS, DB) .
  *** There is some problem parsing 'in_:_ in solveBubblesRed, but it
  *** seems to work with the additional '.

  ceq solveBubblesRedUnify2('in_:_.[T, T'], DB)
    = if unitInDb(ME, DB')
      then solveBubblesRed3(T', addInfoUnify(getFlatModule(ME, DB')), ME, getVars(ME, DB'), DB')
      else tupleTMBODerror('\r 'Error: '\o 'The 'module eMetaPrettyPrint(ME) 'is 'not 'in 'the 'database '. '\n)
      fi
    if < DB' ; ME > := evalModExp(parseModExp(T), DB) .
  eq solveBubblesRedUnify2('in_:_.[T, T'], DB)
    = tupleTMBODerror('\r 'Error: '\o 'It 'isn't 'possible 'to 'compile eMetaPrettyPrint(parseModExp(T)) '. '\n)
    [owise] .

  *** ID-UNIFY

  ceq procIdUnify(ME, M, T, D, VDS, DB)
    *** D is a bound on the number of solutions
    = if solveBubblesRewUnify(T, addInfoUnify(M), B, D, VDS, DB) :: Tuple{Term,Module,Bool,VariableSet,Bound,Database}
      then procIdUnify2(
             getModule(solveBubblesRewUnify(T, addInfoUnify(M), B, D, VDS, DB)),
             parseUnify(
               getTerm(solveBubblesRewUnify(T, addInfoUnify(M), B, D, VDS, DB)),
               getVars(solveBubblesRewUnify(T, addInfoUnify(M), B, D, VDS, DB))),
             getBound(solveBubblesRewUnify(T, addInfoUnify(M), B, D, VDS, DB)))
      else getMsg(solveBubblesRewUnify(T, addInfoUnify(M), B, D, VDS, DB))
      fi
    if B := included('META-MODULE, getImports(getTopModule(ME, DB)), DB) .

  ceq procIdUnify2(M, T =? T', D)
    = if X:[SubstitutionSet] :: SubstitutionSet
      then ('id-unify
            if D == unbounded then nil else '\s '`[ qid(string(D, 10)) '`] '\s fi
            'in eMetaPrettyPrint(getHeader(M)) ':
            eMetaPrettyPrint(M, T =? T')
            if X:[SubstitutionSet] == empty
            then '\n 'No 'unifier
            else procIdUnify3(M, T =? T', 0, X:[SubstitutionSet])
            fi)
      else '\r 'Error: '\o 'Incorrect 'use 'of 'the 'id-unify 'command. '\n
      fi
    if X:[SubstitutionSet] := metaACUUnify(M, T, T') .
  eq procIdUnify2(M?, UP??:[UnificationProblem], D?) = getMsg(M?) [owise] .

  eq procIdUnify3(M, UP, I, empty)
   = ('\n '\n 'No 'more 'solutions. '\n) .
  eq procIdUnify3(M, UP, I, S:Substitution | SS:SubstitutionSet)
   = '\n '\n 'Solution qid(string(I + 1, 10))
      if S:Substitution == none
      then '\n 'empty 'substitution
      else '\n eMetaPrettyPrint(M, S:Substitution)
      fi
     procIdUnify3(M, UP, I + 1, SS:SubstitutionSet) .

  *** FM-VARIANT-UNIFY

  ceq procVariantUnify(ME, M, T, D, VDS, DB)
    *** D is a bound on the number of solutions
    = if solveBubblesRewUnify(T, addInfoUnify(M), B, D, VDS, DB) :: Tuple{Term,Module,Bool,VariableSet,Bound,Database}
      then procVariantUnify2(
             getModule(solveBubblesRewUnify(T, addInfoUnify(M), B, D, VDS, DB)),
             parseUnify(
               getTerm(solveBubblesRewUnify(T, addInfoUnify(M), B, D, VDS, DB)),
               getVars(solveBubblesRewUnify(T, addInfoUnify(M), B, D, VDS, DB))),
             getBound(solveBubblesRewUnify(T, addInfoUnify(M), B, D, VDS, DB)))
      else getMsg(solveBubblesRewUnify(T, addInfoUnify(M), B, D, VDS, DB))
      fi
    if B := included('META-MODULE, getImports(getTopModule(ME, DB)), DB) .

  ceq procVariantUnify2(M, T =? T', D)
    = if X:[SubstitutionSet] :: SubstitutionSet
      then ('variant 'unify
            if D == unbounded then nil else '\s '`[ qid(string(D, 10)) '`] '\s fi
            'in eMetaPrettyPrint(getHeader(M)) ':
            eMetaPrettyPrint(M, T =? T')
            if X:[SubstitutionSet] == empty
            then '\n 'No 'variant 'unifier
            else procVariantUnify3(M, T =? T', 0, X:[SubstitutionSet])
            fi)
      else '\r 'Error: '\o 'Incorrect 'use 'of 'the 'variant 'unify 'command. '\n
      fi
    if X:[SubstitutionSet]
       := toSubstitution(
            metaVariantUnify(
               removeIds(axCohComplete(M), non-handled),
               T,
               T',
               highestVar((T,T')) + 1,
               minimal-unifiers reducible
            )
          ) .
  eq procVariantUnify2(M?, UP??:[UnificationProblem], D?) = getMsg(M?) [owise] .

  eq procVariantUnify3(M, UP, I, empty)
   = ('\n '\n 'No 'more 'solutions. '\n) .
  eq procVariantUnify3(M, UP, I, S:Substitution | SS:SubstitutionSet)
   = '\n '\n 'Solution qid(string(I + 1, 10))
      if S:Substitution == none
      then '\n 'empty 'substitution
      else '\n eMetaPrettyPrint(M, S:Substitution)
      fi
     procVariantUnify3(M, UP, I + 1, SS:SubstitutionSet) .

  *** ASYMMETRIC-VARIANT-UNIFY

  ceq procAsymmetricVariantUnify(ME, M, T, D, VDS, DB)
    *** D is a bound on the number of solutions
    = if solveBubblesRewUnify(T, addInfoUnify(M), B, D, VDS, DB) :: Tuple{Term,Module,Bool,VariableSet,Bound,Database}
      then procAsymmetricVariantUnify2(
             getModule(solveBubblesRewUnify(T, addInfoUnify(M), B, D, VDS, DB)),
             parseUnify(
               getTerm(solveBubblesRewUnify(T, addInfoUnify(M), B, D, VDS, DB)),
               getVars(solveBubblesRewUnify(T, addInfoUnify(M), B, D, VDS, DB))),
             getBound(solveBubblesRewUnify(T, addInfoUnify(M), B, D, VDS, DB)))
      else getMsg(solveBubblesRewUnify(T, addInfoUnify(M), B, D, VDS, DB))
      fi
    if B := included('META-MODULE, getImports(getTopModule(ME, DB)), DB) .

  ---op axCohComplete : SModule -> SModule . --- Defined later in module AX-COHERENCE-COMPLETION
  ---op removeIds : Module ~> Module . ---Defined later in module FM-VARIANTS

  ceq procAsymmetricVariantUnify2(M, T =? T', D)
    = if X:[SubstitutionSet] :: SubstitutionSet
      then ('variant 'unify
            if D == unbounded then nil else '\s '`[ qid(string(D, 10)) '`] '\s fi
            'in eMetaPrettyPrint(getHeader(M)) ':
            eMetaPrettyPrint(M, T =? T')
            if X:[SubstitutionSet] == empty
            then '\n 'No 'asymmetric 'unifier
            else procAsymmetricVariantUnify3(M, T =? T', 0, X:[SubstitutionSet])
            fi)
      else '\r 'Error: '\o 'Incorrect 'use 'of 'the 'asymmetric 'variant 'unify 'command. '\n
      fi
    if X:[SubstitutionSet]
       := toSubstitution(
            metaVariantUnify(
               removeIds(axCohComplete(M), non-handled),
               T,
               T',
               highestVar((T,T')) + 1,
               minimal-unifiers irreducible
            )
          ) .
  eq procAsymmetricVariantUnify2(M?, UP??:[UnificationProblem], D?) = getMsg(M?) [owise] .

  eq procAsymmetricVariantUnify3(M, UP, I, empty)
   = ('\n '\n 'No 'more 'solutions. '\n) .
  eq procAsymmetricVariantUnify3(M, UP, I, S:Substitution | SS:SubstitutionSet)
   = '\n '\n 'Solution qid(string(I + 1, 10))
      if S:Substitution == none
      then '\n 'empty 'substitution
      else '\n eMetaPrettyPrint(M, S:Substitution)
      fi
     procAsymmetricVariantUnify3(M, UP, I + 1, SS:SubstitutionSet) .

  *** GET-VARIANTS

  ceq procGetVariants(ME, M, T, D, VDS, DB)
    *** D is a bound on the number of solutions
    = if solveBubblesRewUnify(T, M, B, D, VDS, DB) :: Tuple{Term,Module,Bool,VariableSet,Bound,Database}
      then procGetVariants2(
             getModule(solveBubblesRewUnify(T, M, B, D, VDS, DB)),
             getTerm(solveBubblesRewUnify(T, M, B, D, VDS, DB)),
             getBound(solveBubblesRewUnify(T, M, B, D, VDS, DB)))
      else getMsg(solveBubblesRewUnify(T, M, B, D, VDS, DB))
      fi
    if B := included('META-MODULE, getImports(getTopModule(ME, DB)), DB) .

  ceq procGetVariants2(M, T, D)
    = if X:[VariantFourSet] :: VariantFourSet
      then ('get 'variants
            if D == unbounded then nil else '\s '`[ qid(string(D, 10)) '`] '\s fi
            'in eMetaPrettyPrint(getHeader(M)) ':
            eMetaPrettyPrint(M, T)
            if X:[VariantFourSet] == empty
            then '\n 'No 'variant
            else procGetVariants3(M, T, 0, X:[VariantFourSet])
            fi)
      else '\r 'Error: '\o 'Incorrect 'use 'of 'the 'get 'variants 'command. '\n
      fi
    if X:[VariantFourSet]
         := getVariants(
              removeIds(axCohComplete(M), non-handled),
              T,
              highestVar(T) + 1,
              ACUUnify irreducible minimal-unifiers
            ) .
  eq procGetVariants2(M?, UP??:[Term], D?) = getMsg(M?) [owise] .

  eq procGetVariants3(M, T, I, (empty).VariantFourSet)
   = ('\n '\n 'No 'more 'variants. '\n) .
  eq procGetVariants3(M, T, I, {T1:Term,S:Substitution,S*:Substitution,NextVar:Nat} | VS:VariantFourSet)
   = '\n '\n 'Variant qid(string(I + 1, 10))
      '\n
      '`{
      eMetaPrettyPrint(M, T1:Term) '`,
      if S:Substitution == none
      then 'empty 'substitution
      else eMetaPrettyPrint(M, S:Substitution)
      fi
      '`}
     procGetVariants3(M, T, I + 1, VS:VariantFourSet) .
endfm

----load check-input-module.maude

---- Input modules are assumed not to have:
---- - idem
---- - assoc without comm
---- - variable alone in lhs
---- - owise
---- - iter
---- - built-ins
---- - something else?

fmod CHECK-INPUT-MODULE is
  inc FM-EXT-TERM .
  inc FM-MODULE-HANDLING  * (op addOps to addOpsSE, op addEqs to addEqsSE, op addSorts to addSortsSE) .
  inc FM-COMMAND-PROCESSING .

  op checkModule : Module -> Bool .
  op attr : OpDeclSet Attr -> Bool .
  ops assocWithoutComm specialAttr : OpDeclSet -> Bool .
  op nonValidAttrs : OpDeclSet AttrSet -> Bool .
  op singleVbleInLHSs : RuleSet -> Bool .
  op singleVbleInLHSs : EquationSet -> Bool .

  var  M : Module .
  var  F : Qid .
  var  TpL : TypeList .
  vars Tp Tp' Tp'' Tp''' : Type .
  var  TpS : TypeSet .
  var  At : Attr .
  vars AtS AtS' : AttrSet .
  vars ODS ODS' : OpDeclSet .
  var  V : Variable .
  var  VS : QidSet .
  var  RlS : RuleSet .
  var  EqS : EquationSet .
  vars T LHS RHS : Term .
  var  Cond : Condition .

  eq attr(op F : TpL -> Tp [owise AtS] . ODS, At AtS) = true .
  eq attr(op F : TpL -> Tp [idem AtS] . ODS, idem) = true .
  eq attr(op F : TpL -> Tp [iter AtS] . ODS, iter) = true .
  eq attr(ODS, At) = false [owise] .

  eq nonValidAttrs(op F : TpL -> Tp [At AtS] . ODS, At AtS') = true .
  eq nonValidAttrs(ODS, AtS) = false [owise] .

  ---- special attributes only allowed for constants
  eq specialAttr(op F : TpL -> Tp [special(NEHL:NeHookList) AtS] . ODS) = TpL =/= nil .
  eq specialAttr(ODS) = false [owise] .

  eq assocWithoutComm(op F : TpL -> Tp [assoc AtS] . ODS)
    = (not comm in AtS) or-else assocWithoutComm(ODS) .
  eq assocWithoutComm(ODS) = false [owise] .

  eq singleVbleInLHSs(rl V => RHS [AtS] . RlS) = true .
  eq singleVbleInLHSs(crl V => RHS if Cond [AtS] . RlS) = true .
  eq singleVbleInLHSs(RlS) = false [owise] .

  eq singleVbleInLHSs(eq V = RHS [AtS] . EqS) = true .
  eq singleVbleInLHSs(ceq V = RHS if Cond [AtS] . EqS) = true .
  eq singleVbleInLHSs(EqS) = false [owise] .

  op isRegular : EquationSet -> Bool .
  op isRegular : RuleSet -> Bool .
  eq isRegular(eq LHS = RHS [AtS] . EqS) = (vars(LHS) == vars(RHS)) and isRegular(EqS) .
  eq isRegular(ceq LHS = RHS if Cond [AtS] . EqS) = (vars(LHS) == vars(RHS)) and isRegular(EqS) .
  eq isRegular(rl LHS => RHS [AtS] . RlS) = (vars(LHS) == vars(RHS)) and isRegular(RlS) .
  eq isRegular(crl LHS => RHS if Cond [AtS] . RlS) = (vars(LHS) == vars(RHS)) and isRegular(RlS) .

  ---- We say that a term l is linear iff all its variables appear only once in it.

  op linear : Term -> Bool .
  eq linear(T) = | vars(T) | == size(varlist(T)) .

  ---- We say that a term l is C-nonlinear iff all its variables are c-nonlinear.
  ---- A variable x : s in vars(l) is c-nonlinear if it is nonlinear in l and
  ---- there is a \Sigma-subterm t with ls[t]_B <= s with a position p such that
  ---- t|_p = f(u,v) with B_f = {C_f}.

  op c-nonlinear : Qid Term Module -> Bool . ---- the variable (1st arg.) is c-linear in the term (2nd arg.)
  op c-nonlinear : Term Module -> Bool . ---- no repeated variables and all such varaibles are c-linear
  op c-nonlinearAux : QidSet Module -> Bool .
  op c-nonlinearAux : Type Module -> Bool .
  op c-nonlinearAux : Type TypeSet OpDeclSet OpDeclSet Module -> Bool .
  op c-nonlinearAux2 : TypeList TypeSet OpDeclSet Module -> Bool .

  eq c-nonlinear(V, T, M) = occurrences(V, T) > 1 and-then c-nonlinearAux(V, M) .

  eq c-nonlinear(T, M) = not linear(T) and-then c-nonlinearAux(vars(T), M) .

  eq c-nonlinearAux(V ; VS, M) = c-nonlinearAux(getType(V), M) or-else c-nonlinearAux(VS, M) .
  eq c-nonlinearAux(none, M) = false .

  eq c-nonlinearAux(Tp, M) = c-nonlinearAux(Tp, Tp, getOps(M), getOps(M), M) .

  ceq c-nonlinearAux(Tp, TpS, op F : Tp' Tp'' -> Tp''' [comm AtS] . ODS, ODS', M)
    = true
    if sortLeq(M, Tp''', Tp) .
  eq c-nonlinearAux(Tp, TpS, op F : TpL -> Tp' [AtS] . ODS, ODS', M)
    = if not comm in AtS and-then (not Tp in TpS and-then sortLeq(M, Tp', Tp))
      then c-nonlinearAux2(TpL, TpS, ODS', M) ---- all the sorts in that declarations have already been checked
      else c-nonlinearAux(Tp, TpS, ODS, ODS', M)
      fi
    [owise] .
  eq c-nonlinearAux(Tp, TpS, none, ODS, M)
    = false .

  eq c-nonlinearAux2(Tp TpL, TpS, ODS, M)
    = if Tp in TpS
      then false
      else c-nonlinearAux(Tp, Tp ; TpS, ODS, ODS, M)
      fi
      or-else c-nonlinearAux2(TpL, TpS, ODS, M) .
  eq c-nonlinearAux2(nil, TpS, ODS, M) = false .

---(
  eq c-permute(C, M) = C .
  eq c-permute(V, M) = V .
  ceq c-permute(F[T, T'], M)
    = c-combine(F, c-permute((T, T'), M)) # c-combine(F, c-permute((T', T), M))
    if isCommutative(M, F, getTypes(M, (T, T'))) .
  eq c-permute(F[TL], M)
    = c-combine(F, c-permute(TL, M))
    [owise] .

  eq c-permute((T, T'), M)
    = c-permute(T, M) .
---)
endfm

--------------------------------------------------------------------------------

view SubstitutionSet from TRIV to FM-SUBSTITUTIONSET is
  sort Elt to SubstitutionSet .
endv

fmod MODULE-VARIANTS is
  inc CHECK-INPUT-MODULE .
  inc FM-META-NARROWING-SEARCH * (op addOps to addOpsSE, op addEqs to addEqsSE, op addSorts to addSortsSE) .
  inc FM-UNIT .
  pr 2TUPLE{SubstitutionSet, Nat}
      * (op `(_`,_`) : SubstitutionSet Nat -> Tuple{SubstitutionSet, Nat} to <_;_>,
         op p1_ : Tuple{SubstitutionSet, Nat} -> SubstitutionSet to getSubst,
         op p2_ : Tuple{SubstitutionSet, Nat} -> Nat to getIndex) .
  pr CONVERSION .
  pr FM-EXT-TERM .
  pr FM-EXT-DECL .
  pr 2TUPLE{Module,Module}
      * (op `(_`,_`) : Module Module -> Tuple{Module, Module} to <_;_>) .

  vars V W : Variable .
  var  C : Constant .
  vars M M' M'' : Module .
  var  N : Nat .
  vars T T' T'' LHS RHS : Term .
  var  F : Qid .
  var  TL : TermList .
  var  AtS : AttrSet .
  var  VFS : VariantFourSet .
  var  VtS : VariantTripleSet .
  vars Tp Tp' Tp'' : Type .
  var  TpL : TypeList .
  var  Rl : Rule .
  var  RlS : RuleSet .
  var  Eq : Equation .
  var  EqS : EquationSet .
  var  ODS : OpDeclSet .
  var  Cond : Condition .
  var  S : Sort .
  var  VS : QidSet .
  vars Subst Subst' : Substitution .
  vars SubstS SubstS' : SubstitutionSet .
  var  H : Header .
  var  SS : SortSet .
  var  SSDS : SubsortDeclSet .
  vars OPDS OPDS' : OpDeclSet .
  var  MAS : MembAxSet .
  var  IL : ImportList .

  ------------------------------------------------------------------------------
  ---- Given a module \mathcal{R} = (\Sigma, E, R)
  ---- removeIds(\mathcal{R}) = removeIds((\widehat{\Sigma}, B, \widetilde{U}), R)
  ---- where
  ---- - \widehat{\Sigma} is obtained by
  ----   - adding to $\Sigma$ a fresh new sort [Tuple] and
  ----   - a tupling operator <_,...,_> : [s] [s_1] ... [s_n] -> [Tuple]
  ----     for each rule l -> r if u_1 -> v_1 /\ ... /\ u_n -> v_n in R,
  ----     where l has sort s and v_i has sort s_i, 1 <= i <= n,
  ---- - B_f = E_f \cap {A_f, C_f}
  ---- - U_f = E_f \cap {LU_f, RU_f},
  ----   with LU_f and RU_f rewrite rules f(e,x) -> x and f(x,e) -> x, and
  ----   where \widetilde{U} is the B-coherence completion of U,
  ----   which is described as \widetilde{U} = \bigcup_{f:[s_1]...[s_n] -> [s] \in \Sigma} \widetilde{U}_f.
  ----   If A_f \not \in B_f, or A_f, C_f \in B_f, then \widetilde{U}_f = U_f.
  ----   Otherwise, if A_f \in B_f, but C_f \not \in B_f, then,
  ----     if LU_f \in U_f, then we add the rule f(x,f(e,y)) -> f(x,y) and
  ----     if RU_f \in U_f, then we add the rule f(f(x,e'),y) -> f(x,y).
  ---- makeIdsModule computes (\widehat{\Sigma}, B, \widetilde{U})
  ------------------------------------------------------------------------------

  sort VariantProcedure .
  ops narrowing ad-hoc built-in : -> VariantProcedure .
  var VP : VariantProcedure .
----  sort IdsToRemove .                             ---- moved to FM-COMMAND-PROCESSING
----  ops all non-handled : -> IdsToRemove .         ---- moved to FM-COMMAND-PROCESSING
  var Which : IdsToRemove .

  op removeIds : Module IdsToRemove ~> Module .  ---- moved to FM-COMMAND-PROCESSING
  ---- given a module returns an equivalent module without ids but with variants of eqs and rls
  ---- the second argument may be either all (all id attributes are removed) or non-handled (only those not directly handled by Maude's unification are removed)
  op removeIds : Module IdsToRemove VariantProcedure ~> Module .
  ---- given a module returns an equivalent module without ids but with variants
  ---- of eqs and rls using the specified procedure for calculating variants
  op getVariants : Module Module RuleSet VariantProcedure -> RuleSet .
  ---- given a (\widehat{\Sigma}, B, \widetilde{U}) returns the variants of the given set of rules
  ---- It takes the modules without and with ids. The module with id attributes is used to normalize.
  op getVariants : Module Module EquationSet VariantProcedure -> EquationSet .
  ---- given a (\widehat{\Sigma}, B, \widetilde{U}) returns the variants of the given set of equations
  ---- It takes the modules without and with ids. The module with id attributes is used to normalize.
  op getVariants# : Module Module Term VariantProcedure -> VariantTripleSet .
  ---- given a (\widehat{\Sigma}, B, \widetilde{U}) returns the variants of a term (a tuple)
  op getRlVariants : Module VariantTripleSet Term Condition AttrSet -> RuleSet .
  ---- given the variants of a tuple < LHS, target terms in condition >, a RHS, a condition, and an attribute set,
  ---- it constructs the corresponding variant rules
  op getEqVariants : Module VariantTripleSet Term Condition AttrSet -> EquationSet .
  ---- given the variants of a tuple < LHS, target terms in condition >, a RHS, a condition, and an attribute set,
  ---- it constructs the corresponding variant equations

  eq removeIds(M, Which) ---- Which may be either all or non-handled
    = if nonValidAttrs(getOps(M), owise idem) ----  iter
      then unitError('The 'module 'uses 'non-supported 'attributes '`(owise 'or 'idem`). '\n)
      else if singleVbleInLHSs(getRls(M))
           then unitError('The 'module 'contains 'rules 'with 'single 'variables 'in 'their 'left-hand 'sides. '\n)
           else if singleVbleInLHSs(getEqs(M))
                then unitError('The 'module 'contains 'equations 'with 'single 'variables 'in 'their 'left-hand 'sides. '\n)
                else if assocWithoutComm(getOps(M))
                     then moreGeneralEqs(moreGeneralRls(removeIds(M, Which, ad-hoc)))
                     else moreGeneralEqs(moreGeneralRls(removeIds(M, Which, narrowing))) ---- built-in
                     fi
                fi
           fi
      fi .

  eq removeIds(M, Which, VP)
    ---- the narrowing based getVariant function requires a module with id attributes turned into eqs
    ---- and sort Tuple and tuple operators in; the ad-hoc getVariant (FroCos th 2) only needs the
    ---- tuple declarations.
    = setRls(
        addEqs(
          getVariants(makeIdsTuplingModule(M, Which), addTupling(M, M), getEqs(M), VP),
          makeIdsModule(M, Which)),
        getVariants(makeIdsTuplingModule(M, Which), addTupling(M, M), getRls(M), VP)) .

  eq getVariants(M, M', Rl RlS, VP)
    = getRlVariants(M', getVariants#(M, M', makeTuple(lhs(Rl), cond(Rl)), VP), rhs(Rl), cond(Rl), atts(Rl))
      getVariants(M, M', RlS, VP) .
  eq getVariants(M, M', (none).RuleSet, VP) = none .

  eq getVariants(M, M', Eq EqS, VP)
    = getEqVariants(M', getVariants#(M, M', makeTuple(lhs(Eq), cond(Eq)), VP), rhs(Eq), cond(Eq), atts(Eq))
      getVariants(M, M', EqS, VP) .
  eq getVariants(M, M', (none).EquationSet, VP) = none .

  eq getVariants#(M, M', T, narrowing) = makeVariantSet(getVariants(M, T, 1, irreducible ACUUnify minimal-unifiers)) .

  op makeVariantSet : VariantFourSet -> VariantTripleSet .
  eq makeVariantSet({T, Subst, Subst', N} | VFS) = {T, Subst, N, none, false} | makeVariantSet(VFS) .
  eq makeVariantSet(empty) = empty .

  eq getRlVariants(M, ({'@<@_@>@[T], Subst, N, P:Parent, B:Bool} | VtS), T', nil, AtS)
    = (rl getTerm(metaNormalize(M, T))
         => getTerm(metaNormalize(M, _<<_(T', Subst))) [AtS] .)
      getRlVariants(M, VtS, T', nil, AtS) .
  eq getRlVariants(M, ({F[T, TL], Subst, N, P:Parent, B:Bool} | VtS), T', Cond, AtS)
    = (crl getTerm(metaNormalize(M, T))
         => getTerm(metaNormalize(M, _<<_(T', Subst)))
         if makeCond(TL, Cond, Subst) [AtS] .)
      getRlVariants(M, VtS, T', Cond, AtS) .
  eq getRlVariants(M, empty, T', Cond, AtS) = none .

  eq getEqVariants(M, ({'@<@_@>@[T], Subst, N, P:Parent, B:Bool} | VtS), T', nil, AtS)
    = (eq getTerm(metaNormalize(M, T))
         = getTerm(metaNormalize(M, _<<_(T', Subst))) [AtS] .)
      getEqVariants(M, VtS, T', nil, AtS) .
  eq getEqVariants(M, ({F[T, TL], Subst, N, P:Parent, B:Bool} | VtS), T', Cond, AtS)
    = (ceq getTerm(metaNormalize(M, T))
         = getTerm(metaNormalize(M, _<<_(T', Subst)))
         if makeCond(TL, Cond, Subst) [AtS] .)
      getEqVariants(M, VtS, T', Cond, AtS) .
  eq getEqVariants(M, empty, T', Cond, AtS) = none .

  ------------------------------------------------------------------------------

  op makeTuple : Term Condition -> Term .
  op tupleTermList : Condition -> TermList .
  eq makeTuple(T, Cond)
    = if Cond == nil
      then qid("@<@_@>@")[T]
      else qid("@<@_" + tupleId(Cond) + "@>@")[T, tupleTermList(Cond)]
      fi .
  eq tupleTermList(T' => T'' /\ Cond) = (T'', tupleTermList(Cond)) .
  eq tupleTermList(T' = T'' /\ Cond) = tupleTermList(Cond) .
  eq tupleTermList(T' : S /\ Cond) = tupleTermList(Cond) .
  eq tupleTermList(T' := T'' /\ Cond) = (T', tupleTermList(Cond)) .
  eq tupleTermList(nil) = empty .

  op makeCond : TermList Condition Substitution -> Condition .
  eq makeCond((T, TL), T' => T'' /\ Cond, Subst)
    = (T' << Subst) => T /\ makeCond(TL, Cond, Subst) .
  eq makeCond((T, TL), T' := T'' /\ Cond, Subst)
    = T := (T'' << Subst) /\ makeCond(TL, Cond, Subst) .
  eq makeCond(TL, T' = T'' /\ Cond, Subst)
    = (T' << Subst) = (T'' << Subst) /\ makeCond(TL, Cond, Subst) .
  eq makeCond(TL, T' : S /\ Cond, Subst)
    = (T' << Subst) : S /\ makeCond(TL, Cond, Subst) .
  eq makeCond(empty, nil, Subst) = nil .

  ------------------------------------------------------------------------------
  ---- makeIdsTuplingModule((\Sigma, E, R)) computes (\widehat{\Sigma}, B, \widetilde{U})
  ------------------------------------------------------------------------------
  op makeIdsTuplingModule : Module IdsToRemove -> Module .
  op makeIdsModule : Module IdsToRemove -> Module .
  op addTupling : Module Module -> Module .
  ---- addTupling is called after makeIdsModule, which removes the eqs in it
  ---- the first module is the oiginal one, with the original eqs and rls

  eq makeIdsTuplingModule(M, Which) = addTupling(M, makeIdsModule(M, Which)) .

  eq makeIdsModule(M, Which)
    = setEqs(
        setOps(
          setRls(M, none),
          removeIds(getOps(M), Which)),
        idEqs(M, getOps(M), Which)) .

  eq addTupling(M, M')
    = addOps(
        tuplingOps(M, getEqs(M), getRls(M)),
        addSorts('Tuple, M')) .

  op idEqs : Module OpDeclSet IdsToRemove -> EquationSet .
  ---- the 3rd arguments indicates whether all the id attributes are to be removed (all), or only those not handled by the Maude unification algorithm (non-handled)
  eq idEqs(M, op F : Tp Tp' -> Tp'' [left-id(T) AtS] . ODS, Which)
    = (eq F[T, qid("X:" + string(type2qid(getKind(M, Tp))))] = qid("X:" + string(type2qid(getKind(M, Tp)))) [variant] .) ---- label('lIdEq1)
      if assoc in AtS and not comm in AtS
      then (eq F[qid("X:" + string(type2qid(getKind(M, Tp)))), F[T, qid("Y:" + string(type2qid(getKind(M, Tp))))]]
              = F[qid("X:" + string(type2qid(getKind(M, Tp)))), qid("Y:" + string(type2qid(getKind(M, Tp))))]
              [variant] .) ---- label('lIdEq2)
      else none
      fi
      idEqs(M, ODS, Which) .
  eq idEqs(M, op F : Tp Tp' -> Tp'' [right-id(T) AtS] . ODS, Which)
    = (eq F[qid("X:" + string(type2qid(getKind(M, Tp)))), T] = qid("X:" + string(type2qid(getKind(M, Tp)))) [variant] .) ---- label('rIdEq1)
      if assoc in AtS and not comm in AtS
      then (eq F[F[qid("X:" + string(type2qid(getKind(M, Tp)))), T], qid("Y:" + string(type2qid(getKind(M, Tp))))]
              = F[qid("X:" + string(type2qid(getKind(M, Tp)))), qid("Y:" + string(type2qid(getKind(M, Tp))))]
              [variant] .) ---- label('rIdEq2)
      else none
      fi
      idEqs(M, ODS, Which) .
  eq idEqs(M, op F : Tp Tp' -> Tp'' [id(T) AtS] . ODS, all)
    = if comm in AtS
      then (eq F[T, qid("X:" + string(type2qid(getKind(M, Tp))))] = qid("X:" + string(type2qid(getKind(M, Tp)))) [variant] .) ---- label('idEq1)
      else (eq F[qid("X:" + string(type2qid(getKind(M, Tp)))), T] = qid("X:" + string(type2qid(getKind(M, Tp)))) [variant] .) ---- label('idEq2)
           (eq F[T, qid("X:" + string(type2qid(getKind(M, Tp))))] = qid("X:" + string(type2qid(getKind(M, Tp)))) [variant] .) ---- label('idEq3)
      fi
      if assoc in AtS and not comm in AtS
      then (eq F[qid("X:" + string(type2qid(getKind(M, Tp)))), F[T, qid("Y:" + string(type2qid(getKind(M, Tp))))]]
              = F[qid("X:" + string(type2qid(getKind(M, Tp)))), qid("Y:" + string(type2qid(getKind(M, Tp))))]
              [variant] .)
           (eq F[F[qid("X:" + string(type2qid(getKind(M, Tp)))), T], qid("Y:" + string(type2qid(getKind(M, Tp))))]
              = F[qid("X:" + string(type2qid(getKind(M, Tp)))), qid("Y:" + string(type2qid(getKind(M, Tp))))]
              [variant] .)
      else none
      fi
      idEqs(M, ODS, all) .
  eq idEqs(M, op F : Tp Tp' -> Tp'' [id(T) AtS] . ODS, non-handled)
    ---- modified on Jan 13th, 2011
    ---- The ACU case is now handled, the id attributes are left if also AC
    = if assoc in AtS and comm in AtS
      then none
      else if comm in AtS
           then (eq F[T, qid("X:" + string(type2qid(getKind(M, Tp))))] = qid("X:" + string(type2qid(getKind(M, Tp)))) [variant] .) ---- label('idEq1)
           else (eq F[qid("X:" + string(type2qid(getKind(M, Tp)))), T] = qid("X:" + string(type2qid(getKind(M, Tp)))) [variant] .) ---- label('idEq2)
                (eq F[T, qid("X:" + string(type2qid(getKind(M, Tp))))] = qid("X:" + string(type2qid(getKind(M, Tp)))) [variant] .) ---- label('idEq3)
           fi
           if assoc in AtS and not comm in AtS
           then (eq F[qid("X:" + string(type2qid(getKind(M, Tp)))), F[T, qid("Y:" + string(type2qid(getKind(M, Tp))))]]
                   = F[qid("X:" + string(type2qid(getKind(M, Tp)))), qid("Y:" + string(type2qid(getKind(M, Tp))))]
                   [variant] .)
                (eq F[F[qid("X:" + string(type2qid(getKind(M, Tp)))), T], qid("Y:" + string(type2qid(getKind(M, Tp))))]
                   = F[qid("X:" + string(type2qid(getKind(M, Tp)))), qid("Y:" + string(type2qid(getKind(M, Tp))))]
                   [variant] .)
           else none
           fi
      fi
      idEqs(M, ODS, non-handled) .
  eq idEqs(M, ODS, Which) = none [owise] .

  op removeIds : OpDeclSet IdsToRemove -> OpDeclSet .
  eq removeIds(op F : TpL -> Tp [id(T) AtS] . ODS, all)
    = removeIds(op F : TpL -> Tp [AtS] . ODS, all) .
 ceq removeIds(op F : TpL -> Tp [id(T) AtS] . ODS, non-handled)
    = removeIds(op F : TpL -> Tp [AtS] . ODS, non-handled)
    if not (assoc in AtS and comm in AtS) .
  eq removeIds(op F : TpL -> Tp [left-id(T) AtS] . ODS, Which)
    = removeIds(op F : TpL -> Tp [AtS] . ODS, Which) .
  eq removeIds(op F : TpL -> Tp [right-id(T) AtS] . ODS, Which)
    = removeIds(op F : TpL -> Tp [AtS] . ODS, Which) .
  eq removeIds(ODS, Which) = ODS [owise] .

  op tuplingOps : Module EquationSet RuleSet -> OpDeclSet .
  op tuplingOps : Module EquationSet -> OpDeclSet .
  op tuplingOps : Module RuleSet -> OpDeclSet .
  eq tuplingOps(M, EqS, RlS) = tuplingOps(M, EqS) tuplingOps(M, RlS) .
  eq tuplingOps(M, eq LHS = RHS [AtS] . EqS)
    = (op qid("@<@_@>@") : getKind(M, leastSort(M, LHS)) -> '`[Tuple`] [none] .)
      tuplingOps(M, EqS) .
  eq tuplingOps(M, ceq LHS = RHS if Cond [AtS] . EqS)
    = (op qid("@<@_" + tupleId(Cond) + "@>@") : getKind(M, leastSort(M, LHS)) arityCond(M, Cond) -> '`[Tuple`] [none] .)
      tuplingOps(M, EqS) .
  eq tuplingOps(M, (none).EquationSet) = none .
  eq tuplingOps(M, rl LHS => RHS [AtS] . RlS)
    = (op qid("@<@_@>@") : getKind(M, leastSort(M, LHS)) -> '`[Tuple`] [none] .)
      tuplingOps(M, RlS) .
  eq tuplingOps(M, crl LHS => RHS if Cond [AtS] . RlS)
    = (op qid("@<@_" + tupleId(Cond) + "@>@") : getKind(M, leastSort(M, LHS)) arityCond(M, Cond) -> '`[Tuple`] [none] .)
      tuplingOps(M, RlS) .
  eq tuplingOps(M, (none).RuleSet) = none .

  op arityCond : Module Condition -> TypeList .
  eq arityCond(M, T => T' /\ Cond) = getKind(M, leastSort(M, T')) arityCond(M, Cond) .
  eq arityCond(M, T := T' /\ Cond) = getKind(M, leastSort(M, T)) arityCond(M, Cond) .
  eq arityCond(M, T = T' /\ Cond) = arityCond(M, Cond) .
  eq arityCond(M, T : S /\ Cond) = arityCond(M, Cond) .
  eq arityCond(M, nil) = nil .

  op tupleId : Condition -> String .
  eq tupleId(T => T' /\ Cond) = ",_" + tupleId(Cond) .
  eq tupleId(T := T' /\ Cond) = ",_" + tupleId(Cond) .
  eq tupleId(T = T' /\ Cond) = tupleId(Cond) .
  eq tupleId(T : S /\ Cond) = tupleId(Cond) .
  eq tupleId(Cond) = "" .

  ------------------------------------------------------------------------------
  ---- See Th. 2, FroCos'09
  ---- TO DO: it doesn't give the minimal set of variants

  op getVariants : Module Term SubstitutionSet -> VariantTripleSet .
  op getSubstitutions : Module QidSet OpDeclSet Nat -> Tuple{SubstitutionSet,Nat} .
  op getSubstitutions1 : Module Variable OpDeclSet Nat -> Tuple{SubstitutionSet,Nat} .
  op combineSubsts : SubstitutionSet SubstitutionSet -> SubstitutionSet .

  eq getVariants#(M, M', T, ad-hoc)
    = getVariants(M', T, getSubst(getSubstitutions(M', vars(T), getOps(M'), 0))) .

  eq getVariants(M, T, Subst | SubstS)
    = {getTerm(metaNormalize(M, T << Subst)), Subst, 0, none, false} | getVariants(M, T, SubstS) .
  eq getVariants(M, T, empty) = {T, none, 0, none, false} .

  eq getSubstitutions(M, V ; VS, ODS, N)
    = < combineSubsts(
          getSubst(getSubstitutions1(M, V, ODS, N)),
          getSubst(getSubstitutions(M, VS, ODS, getIndex(getSubstitutions1(M, V, ODS, N))))) ;
        getIndex(getSubstitutions(M, VS, ODS, getIndex(getSubstitutions1(M, V, ODS, N)))) > .
  eq getSubstitutions(M, none, ODS, N) = < empty ; N > .

  eq combineSubsts(Subst | SubstS, Subst' | SubstS')
    = (Subst ; Subst') | combineSubsts(SubstS, Subst' | SubstS') | combineSubsts(Subst, SubstS') .
  eq combineSubsts(SubstS, empty) = SubstS .
  eq combineSubsts(empty, SubstS) = SubstS .

  ceq getSubstitutions1(M, V, op F : TpL -> Tp [id(T) AtS] . ODS, N)
    = < (V <- T) |
        if (assoc in AtS and-then not comm in AtS)
           and-then sortLeq(M, leastSort(M, F[qid("X@" + string(N, 10) + ":" + string(Tp)), T]), getType(V))
        then (V <- (F[qid("X@" + string(N, 10) + ":" + string(Tp)), T]))
           | (V <- (F[T, qid("X@" + string(s N, 10) + ":" + string(Tp))]))
        else empty
        fi |
        getSubst(getSubstitutions1(M, V, ODS, s s N)) ;
        getIndex(getSubstitutions1(M, V, ODS, s s N)) >
    if sortLeq(M, leastSort(M, T), getType(V)) . ----  ls[e] <= s ls[f(y,e)] <= s
  ceq getSubstitutions1(M, V, op F : TpL -> Tp [right-id(T) AtS] . ODS, N)
    = < (V <- T) |
        if (assoc in AtS and-then not comm in AtS)
           and-then sortLeq(M, leastSort(M, F[qid("X@" + string(N, 10) + ":" + string(Tp)), T]), getType(V))
        then (V <- F[T, qid("X@" + string(N, 10) + ":" + string(Tp))])
        else empty
        fi |
        getSubst(getSubstitutions1(M, V, ODS, s s N)) ;
        getIndex(getSubstitutions1(M, V, ODS, s s N)) >
    if sortLeq(M, leastSort(M, T), getType(V)) . ----  ls[e] <= s ls[f(y,e)] <= s
  ceq getSubstitutions1(M, V, op F : TpL -> Tp [left-id(T) AtS] . ODS, N)
    = < (V <- T) |
        if (assoc in AtS and-then not comm in AtS)
           and-then sortLeq(M, leastSort(M, F[qid("X@" + string(N, 10) + ":" + string(Tp)), T]), getType(V))
        then (V <- F[qid("X@" + string(s N, 10) + ":" + string(Tp)), T])
        else empty
        fi |
        getSubst(getSubstitutions1(M, V, ODS, s s N)) ;
        getIndex(getSubstitutions1(M, V, ODS, s s N)) >
    if sortLeq(M, leastSort(M, T), getType(V)) . ----  ls[e] <= s ls[f(y,e)] <= s
  eq getSubstitutions1(M, V, ODS, N) = < empty ; N > [owise] .

  ------------------------------------------------------------------------------
  ---- Given a module with axioms B where for each f we have B_f \in {A_f,C_f},
  ---- we now define a rewrite theory (\Sigma, B', A), where for each f we have
  ---- B'_f = B_f if B_f =/= {A_f}, and B'_f = \emptyset if B_f == {A_f}, and
  ---- where A consists of rules of either the form
  ----  f(f(x, y), z) -> f(x, f(y, z))
  ---- or the form
  ----  f(x, f(y, z)) -> f(f(x, y), z)
  ---- for each f such that B_f == {A_f}. That is, for any such f we "choose" a
  ---- rule asociating f to the right or to the left (but only "one" of these possibilities).

  ---- TO DO: I cannot set a timeout. If the first one doesn't work it hangs up!
  ---- TO DO: All terms are in their flatten form, when removing the assoc atributes I get error messages.

  op removeLonelyAssocs : Module -> Module .
  ---- removes all assoc with no comm, returning an equivalent module
  op $removeLonelyAssocs : OpDeclSet -> OpDeclSet .
  ---- removes those assoc attributes that are not with the comm one
  op $removeLonelyAssocs : Module OpDeclSet OpDeclSet EquationSet ~> Module .
  ---- arg. 1 (Module): the module with assoc attribute removed
  ---- arg. 2 (OpDeclSet): initially all op. decls.; they are evaluated one by one,
  ----   adding the corresponding equation to the 4th arg. in the recursive call
  ---- arg. 3 (OpDeclSet): initially empty; evaluated op. decls. are added to this set
  ---- arg. 4 (EquationSet): assoc. eq. to be added to the module
  op $checkAEq : Module Equation -> Bool .
  ---- checks whether the assoc. eq. given as argument unifies with any lhs in the module
  ---- arg. 1 (Module): the module with assoc attribute removed
  ---- arg. 2 (Equation): tentative assoc. eq. to evaluate
  op $checkAEqAux : Module EquationSet -> Bool .
  ---- tries to narrow with the assoc. eq. (as a rule) on each lhs in the module.
  ---- arg. 1 (Module): module with assoc attribute removed, with the assoc. eq.
  ----   turned into a rule as single rule (no eqs.)
  ---- arg. 2 (EquationSet): eqs. in the original module
  op $anyLonelyAssoc : OpDeclSet -> Bool .
  ---- checks whether the module contains an operator with assoc and no comm

  eq removeLonelyAssocs(M)
    = if $anyLonelyAssoc(getOps(M))
      then if nonValidAttrs(getOps(M), owise idem) ---- iter
           then unitError('The 'module 'uses 'non-supported 'attributes '`(owise 'or 'idem`). '`))
           else if singleVbleInLHSs(getRls(M))
                then unitError('The 'module 'contains 'rules 'with 'single 'variables 'in 'their 'left-hand 'sides. '`))
                else if singleVbleInLHSs(getEqs(M))
                     then unitError('The 'module 'contains 'equations 'with 'single 'variables 'in 'their 'left-hand 'sides. '`))
                     else $removeLonelyAssocs(setOps(M, $removeLonelyAssocs(getOps(M))), getOps(M), none, none)
                     fi
                fi
           fi
      else M
      fi .

  ceq $removeLonelyAssocs(op F : Tp Tp -> Tp [assoc AtS] . OPDS)
    = op F : Tp Tp -> Tp [AtS] . $removeLonelyAssocs(OPDS)
    if not comm in AtS .
  eq $removeLonelyAssocs(OPDS) = OPDS [owise] .

  ceq $removeLonelyAssocs(M, op F : TpL -> Tp [AtS] . OPDS, OPDS', EqS)
    = $removeLonelyAssocs(M, OPDS, op F : TpL -> Tp [AtS] . OPDS', EqS)
    if size(TpL) =/= 2 or not assoc in AtS or comm in AtS .
  ceq $removeLonelyAssocs(M, op F : Tp Tp -> Tp [assoc AtS] . OPDS, OPDS', EqS)
    = $removeLonelyAssocs(M, OPDS, op F : Tp Tp -> Tp [AtS] . OPDS', Eq EqS)
    if not comm in AtS
    /\ Str:String := string(type2qid(getKind(M, Tp)))
    /\ Eq := (eq F[F[qid("X:" + Str:String), qid("Y:" + Str:String)], qid("Z:" + Str:String)]
                = F[qid("X:" + Str:String), F[qid("Y:" + Str:String), qid("Z:" + Str:String)]] [label('assocEq)] .)
    /\ $checkAEq(M, Eq) .
  ceq $removeLonelyAssocs(M, op F : Tp Tp -> Tp [assoc AtS] . OPDS, OPDS', EqS)
    = $removeLonelyAssocs(M, OPDS, op F : Tp Tp -> Tp [AtS] . OPDS', Eq EqS)
    if not comm in AtS
    /\ Str:String := string(type2qid(getKind(M, Tp)))
    /\ Eq := (eq F[qid("X:" + Str:String), F[qid("Y:" + Str:String), qid("Z:" + Str:String)]]
                = F[F[qid("X:" + Str:String), qid("Y:" + Str:String)], qid("Z:" + Str:String)] [label('assocEq)] .)
    /\ $checkAEq(M, Eq) .
  eq $removeLonelyAssocs(M, none, OPDS', EqS) = addEqs(EqS, M) .
  eq $removeLonelyAssocs(M, op F : TpL -> Tp [AtS] . OPDS, OPDS', EqS) = unitError('assoc 'attributes 'cannot 'be 'removed 'for F) [owise] .

  eq $checkAEq(M, Eq) = $checkAEqAux(setRls(setEqs(M, none), rulify(Eq)), getEqs(M)) .

  ceq $checkAEqAux(M, Eq EqS)
    = T:Term == lhs(Eq) ---- the assoc eq doesn't unify with the equation's lhs
      and
      Subst:Substitution == none
      and-then
      $checkAEqAux(M, EqS)
    if {T:Term, Tp:Type, Subst:Substitution} := metaNarrow(M, lhs(Eq), 1) .
  eq $checkAEqAux(M, none) = true .

  ceq $anyLonelyAssoc(op F : Tp Tp -> Tp [assoc AtS] . OPDS)
    = true
    if not comm in AtS .
  eq $anyLonelyAssoc(OPDS) = false [owise] .
endfm

*******************************************************************************

***
*** Interaction with the Persistent Database
***

*** In the case of Full Maude, the persistent state of the system is given by
*** a single object which maintains the database of the system. This object
*** has an attribute \texttt{db}, to keep the actual database in which all the
*** modules being entered are stored, an attribute \texttt{default}, to keep
*** the identifier of the current module by default, and attributes
*** \texttt{input} and \texttt{output} to simplify the communication of the
*** read-eval-print loop given by the \texttt{LOOP-MODE} module with the
*** database. Using the notation for classes in object-oriented modules (see
*** Section~\ref{object-oriented-modules}) we can declare the class
*** \texttt{database} as follows:
***
***   class database | db : Database, input : TermList,
***                    output : QidList, default : ModId .
***
*** Since we assume that \texttt{database} is the only object class that has
*** been defined---so that the only objects of sort \texttt{Object} will
*** belong to the \texttt{database} class---to specify the admissible states
*** in the persistent state of \texttt{LOOP-MODE} for Full Maude, it is enough
*** to give the subsort declaration
***
***   subsort Object < State .

***
*** \subsection{The \texttt{CONFIGURATION+} Module}
***

*** change (2/20/2002): CONFIGURATION is now part of the prelude
***
*** fmod CONFIGURATION is
***   sort Oid Cid Attribute AttributeSet Configuration Object Msg .
***
***   subsort Attribute < AttributeSet .
***   subsorts Object Msg < Configuration .
***
***   op none : -> AttributeSet .
***   op _,_ : AttributeSet AttributeSet -> AttributeSet
***       [assoc comm id: none] .
***   op none : -> Configuration .
***   op __ : Configuration Configuration -> Configuration
***       [assoc comm id: none] .
***   op <_:_|_> : Oid Cid AttributeSet -> Object .
***   op <_:_| > : Oid Cid -> Object .
***
***   var O : Oid .
***   var C : Cid .
***
***   eq < O : C | > = < O : C | none > .
*** endfm

*******************************************************************************

***
*** Top Level Handling of the Persistent Database
***

*** Note that, since the Full Maude specification is given as a system module
***Core Maude, object-oriented declarations cannot be given directly.
*** Instead, the equivalent declarations desugaring the desired
*** object-oriented declarations have to be specified. We use also the same
*** conventions discussed in Section~\ref{omod2mod} regarding the use of
*** variables instead of class names in the objects and in the addition of
*** variables of sort \texttt{AttributeSet} to range over the additional
*** attributes. As we shall see in Chapter~\ref{crc}, this convention will
*** allow us to extend the Full Maude system in a very simple and clean way.

*** To allow the use of the object-oriented notation the predefined module
*** \texttt{CONFIGURATION}, presented in Section~\ref{omod2mod}, is included
*** in the following module \texttt{FM-DATABASE-HANDLING}.


mod FM-DATABASE-HANDLING is
---  inc META-LEVEL + PRE-VARIANT .
  inc META-LEVEL .
  inc CONFIGURATION+ .
  pr VIEW-META-PRETTY-PRINT .
  pr VIEW-PROCESSING .
  pr FM-COMMAND-PROCESSING .
  pr PREDEF-UNITS .
  pr MODULE-VARIANTS .
  pr AX-COHERENCE-COMPLETION .
  pr FM-HELP .

  var  F : Qid .
  var  QIL : QidList .
  var  NQIL NQIL' NQIL'' : NeQidList .
  vars T T' T'' T3 : Term .
  var  TL : TermList .
  var  DB DB' : Database .
  vars ME ME' ME'' : ModuleExpression .
  vars QIL' QIL'' : QidList .
  vars MNS MNS' MNS'' MNS3 MNS4 : Set{ModuleName} .
  var  VE : ViewExpression .
  var  VES : Set{ViewExpression} .
  vars MIS MIS' : Set{ModuleInfo} .
  var  VIS : Set{ViewInfo} .
  vars PDS PDS' : Set{ParameterDecl} .
  var  B : Bool .
  var  I : Import .
  var  IL : ImportList .
  var  MN : ModuleName .

  op initialDatabase : -> Database .
  eq initialDatabase
    = insTermModule('META-MODULE,
        addOps(getOps(#UP#),
          addSorts(getSorts(#UP#),
            addImports(getImports(#UP#), upModule('META-MODULE, false)))),
        emptyDatabase) .

*** We start by introducing a subsort \texttt{DatabaseClass} of sort
*** \texttt{Cid}, the operator declarations necessary for representing objects
*** in class \texttt{DatabaseClass} as defined above, and variables to range
*** over subclasses of class \texttt{DatabaseClass} and over attributes.

  sort DatabaseClass .
  subsort DatabaseClass < Cid .
  op Database : -> DatabaseClass .
  op db :_ : Database -> Attribute .
  op input :_ : TermList -> Attribute .
  op output :_ : QidList -> Attribute .
  op default :_ : Header -> Attribute .

  var Atts : AttributeSet .
  var X@DatabaseClass : DatabaseClass .
  var O : Oid .

*** Next, we introduce an auxiliary function \texttt{parseHeader} to parse
*** names of user-defined modules, and a constant \texttt{nilTermList} of sort
*** \texttt{TermList}. Note that the name of a user-defined module must be a
*** single identifier (a token) or, for parameterized modules, its name---a
*** single identifier---and its interface.

  op parseHeader : Term -> Qid .
  eq parseHeader('token[T]) = downQid(T) .
  eq parseHeader('_`{_`}['token[T], T']) = downQid(T) .

  op nilTermList : -> TermList .

*** Finally, we present the rules processing the inputs of the database. These
*** rules define the behavior of the system for the different commands,
*** modules, theories, and views entered into the system. For example, the
*** first rule processes the different types of modules entered to the system.
*** Note that the operators declared as constructors of sort \texttt{PreModule}
*** in the signature of Full Maude, given in
*** Appendix~\ref{signature-full-maude}, are declared with two arguments,
*** namely the name of the unit, or its name + its interface, and the list
*** of declarations of such a unit.

  crl [module] :
     < O : X@DatabaseClass | db : DB, input : (F[T, T']), output : nil, default : ME, Atts >
     => < O : X@DatabaseClass |
           db : procModule(F[T, T'], DB), input : nilTermList,
           output : ('Introduced 'module header2Qid(parseHeader(T)) '\n),
           default : parseHeader(T), Atts >
     if  (F == 'fmod_is_endfm) or-else
        ((F == 'obj_is_endo)   or-else
        ((F == 'obj_is_jbo)    or-else
        ((F == 'mod_is_endm)   or-else
        ((F == 'smod_is_endsm) or-else
         (F == 'omod_is_endom))))) .

*** Notice the message placed in the output channel, and the change in the
*** current module by default, which is now the new module just processed.
*** Since the name of the module \texttt{T} can be complex---a parameterized
*** module---some extra parsing has to be performed by the auxiliary function
*** \texttt{parseHeader}. Similar rules are given for the processing of
*** theories and views.

  crl [theory] :
     < O : X@DatabaseClass | db : DB, input : (F[T, T']), output : nil, default : ME, Atts >
     => < O : X@DatabaseClass |
           db : procModule(F[T, T'], DB), input : nilTermList,
           output : ('Introduced 'theory header2Qid(parseHeader(T)) '\n),
           default : parseHeader(T), Atts >
     if  (F == 'fth_is_endfth) or-else
         (F == 'th_is_endth)   or-else
         (F == 'oth_is_endoth) or-else
         (F == 'sth_is_endsth) .

  rl [view] :
     < O : X@DatabaseClass | db : DB,
        input : ('view_from_to_is`endv[T, T', T'']),
        output : nil, default : ME, Atts >
     => < O : X@DatabaseClass |
           db : procView('view_from_to_is_endv[T, T', T'', 'none.ViewDeclSet], DB),
           input : nilTermList,
           output : ('Introduced 'view header2Qid(parseHeader(T)) '\n),
           default : ME, Atts > .
  rl [view] :
     < O : X@DatabaseClass | db : DB,
        input : ('view_from_to_is_endv[T, T', T'', T3]),
        output : nil, default : ME, Atts >
     => < O : X@DatabaseClass |
           db : procView('view_from_to_is_endv[T, T', T'', T3], DB),
           input : nilTermList,
           output : ('Introduced 'view header2Qid(parseHeader(T)) '\n),
           default : ME, Atts > .

*** Commands are handled by rules as well. For example, the \texttt{down},
*** \texttt{reduce}, and \texttt{rewrite} commands are handled by the
*** following rules.

  rl [down] :
     < O : X@DatabaseClass | db : DB, input : ('down_:_[T, T']), output : nil, default : ME, Atts >
     => < O : X@DatabaseClass |
           db : getDatabase(procDownCommand('down_:_[T, T'], ME, DB)),
           input : nilTermList,
           output : getQidList(procDownCommand('down_:_[T, T'], ME, DB)),
           default : ME, Atts > .

  crl [red/rew/frew] :
     < O : X@DatabaseClass | db : DB, input : (F[T]), output : QIL, default : ME, Atts >
     => < O : X@DatabaseClass |
           db : getDatabase(procCommand(F[T], ME, DB)),
           input : nilTermList,
           output : getQidList(procCommand(F[T], ME, DB)),
           default : ME, Atts >
     if  (F == 'parse_.)     or-else
         (F == 'red_.)       or-else
         (F == 'reduce_.)    or-else
         (F == 'rew_.)       or-else
         (F == 'rewrite_.)   or-else
         (F == 'frew_.)      or-else
         (F == 'frewrite_.)  or-else
         (F == 'srew_.)      or-else
         (F == 'srewrite_.)  or-else
         (F == 'dsrew_.)     or-else
         (F == 'dsrewrite_.) or-else
         (F == 'unify_.)     or-else
         (F == 'id-unify_.)  or-else
         (F == 'variant`unify_.) or-else
         (F == 'asymmetric`variant`unify_.) or-else
         (F == 'get`variants_.) .

  crl [search] :
     < O : X@DatabaseClass | db : DB, input : (F[T, T']), output : QIL, default : ME, Atts >
     => < O : X@DatabaseClass |
           db : getDatabase(procCommand(F[T, T'], ME, DB)),
           input : nilTermList,
           output : getQidList(procCommand(F[T, T'], ME, DB)),
           default : ME, Atts >
     if  (F == 'search_=>_.)  or-else
        ((F == 'search_=>1_.) or-else
        ((F == 'search_=>*_.) or-else
        ((F == 'search_=>+_.) or-else
        ((F == 'search_=>!_.) or-else
        ((F == 'vu-narrow_=>_.)  or-else
        ((F == 'vu-narrow_=>1_.) or-else
        ((F == 'vu-narrow_=>*_.) or-else
        ((F == 'vu-narrow_=>+_.) or-else
        ((F == 'vu-narrow_=>!_.) or-else
        ((F == 'fvu-narrow_=>_.)  or-else
        ((F == 'fvu-narrow_=>1_.) or-else
        ((F == 'fvu-narrow_=>*_.) or-else
        ((F == 'fvu-narrow_=>+_.) or-else
        ((F == 'fvu-narrow_=>!_.) or-else
        ((F == 'search_~>_.)  or-else
        ((F == 'search_~>1_.) or-else
        ((F == 'search_~>*_.) or-else
        ((F == 'search_~>+_.) or-else
        ((F == 'search_~>!_.) or-else
        ((F == 'match_<=?_.)  or-else
         (F == 'xmatch_<=?_.))))))))))))))))))))) .


  rl [select] :
     < O : X@DatabaseClass | db : DB, input : ('select_.[T]), output : QIL, default : ME, Atts >
     => < O : X@DatabaseClass | db : DB, input : nilTermList, output : (QIL 'The eMetaPrettyPrint(parseModExp(T)) 'has 'been 'set 'as 'current 'module. '\n), default : parseModExp(T), Atts > .

  rl [show-modules] :
     < O : X@DatabaseClass | db : DB,
        input : ('show`modules`..@Command@),
        output : nil, default : ME, Atts >
     => < O : X@DatabaseClass | db : DB, input : nilTermList,
           output : showModules(DB), default : ME, Atts > .
  rl [show-views] :
     < O : X@DatabaseClass | db : DB,
        input : ('show`views`..@Command@),
        output : nil, default : ME, Atts >
     => < O : X@DatabaseClass | db : DB, input : nilTermList,
           output : showViews(DB), default : ME, Atts >  .

*** The \texttt{show module} command, which prints the specified module, or
*** the current one if no module name is specified, is handled by the
*** following rules.

  crl [show-module] :
    < O : X@DatabaseClass | db : DB,
       input : ('show`module`..@Command@),
       output : nil, default : ME, Atts >
    => < O : X@DatabaseClass | db : DB', input : nilTermList,
          output : eMetaPrettyPrint(getFlatModule(ME', DB'), getTopModule(ME', DB')),
          default : ME', Atts >
    if < DB' ; ME' > := evalModExp(ME, DB) .
  crl [show-module] :
    < O : X@DatabaseClass | db : DB, input : ('show`module_.[T]), output : nil, default : ME,   Atts >
    => < O : X@DatabaseClass |
          db : DB', input : nilTermList,
          output : eMetaPrettyPrint(getFlatModule(ME'', DB'), getTopModule(ME'', DB')),
          default : ME, Atts >
    if < DB' ; ME'' > := evalModExp(parseModExp(T), DB) .
  crl [show-module] :
    < O : X@DatabaseClass | db : DB, input : ('show`module_.[T]), output : nil, Atts >
    => < O : X@DatabaseClass | db : DB, input : nil,
          output : ('Error 'evaluating 'the 'given 'module 'expression.), Atts >
    if evalModExp(ME:[ModuleExpression], DB':[Database]) := evalModExp(parseModExp(T), DB) .

  crl [show-all] :
    < O : X@DatabaseClass | db : DB, input : ('show`all`..@Command@),
       output : nil, default : ME, Atts >
    => < O : X@DatabaseClass | db : DB', input : nilTermList,
          output : eMetaPrettyPrint(getFlatModule(ME', DB'), getFlatModule(ME', DB')),
          default : ME', Atts >
    if < DB' ; ME' > := evalModExp(ME, DB) .
  crl [show-all] :
    < O : X@DatabaseClass | db : DB, input : ('show`all_.[T]), output : nil, default : ME, Atts >
    => < O : X@DatabaseClass | db : DB', input : nilTermList,
          output : eMetaPrettyPrint(getFlatModule(ME', DB'), getFlatModule(ME', DB')),
          default : ME, Atts >
    if ME'' := parseModExp(T)
    /\ < DB' ; ME' > := evalModExp(ME'', DB) .

  crl [show-vars] :
    < O : X@DatabaseClass | db : DB, input : ('show`vars`..@Command@),
       output : nil, default : ME, Atts >
    => < O : X@DatabaseClass | db : DB', input : nilTermList,
          output : eMetaPrettyPrintVars(getVars(ME', DB')),
          default : ME', Atts >
    if DB' := database(evalModExp(ME, DB))
       /\ ME' := modExp(evalModExp(ME, DB)) .
  crl [show-vars] :
    < O : X@DatabaseClass | db : DB, input : ('show`vars_.[T]),
       output : nil, default : ME, Atts >
    => < O : X@DatabaseClass | db : DB', input : nilTermList,
          output : eMetaPrettyPrintVars(getVars(ME', DB')),
          default : ME, Atts >
    if ME'' := parseModExp(T)
       /\ DB' := database(evalModExp(ME'', DB))
       /\ ME' := modExp(evalModExp(ME'', DB)) .

  crl [show-sorts] :
    < O : X@DatabaseClass | db : DB, input : ('show`sorts`..@Command@), output : nil, default : ME, Atts >
    => < O : X@DatabaseClass | db : DB', input : nilTermList,
          output : eMetaPrettyPrint(getSorts(getFlatModule(ME', DB'))),
          default : ME', Atts >
    if DB' := database(evalModExp(ME, DB))
       /\ ME' := modExp(evalModExp(ME, DB)) .
  crl [show-sorts] :
    < O : X@DatabaseClass | db : DB, input : ('show`sorts_.[T]), output : nil, default : ME, Atts >
    => < O : X@DatabaseClass | db : DB', input : nilTermList,
          output : eMetaPrettyPrint(getSorts(getFlatModule(ME', DB'))),
          default : ME, Atts >
    if ME'' := parseModExp(T)
       /\ DB' := database(evalModExp(ME'', DB))
       /\ ME' := modExp(evalModExp(ME'', DB)) .

  crl [show-ops] :
    < O : X@DatabaseClass | db : DB, input : ('show`ops`..@Command@), output : nil, default : ME, Atts >
    => < O : X@DatabaseClass | db : DB', input : nilTermList,
          output : eMetaPrettyPrint(getFlatModule(ME', DB'), getOps(getFlatModule(ME', DB'))),
          default : ME', Atts >
    if DB' := database(evalModExp(ME, DB))
       /\ ME' := modExp(evalModExp(ME, DB)) .
  crl [show-ops] :
    < O : X@DatabaseClass | db : DB, input : ('show`ops_.[T]), output : nil, default : ME, Atts >
    => < O : X@DatabaseClass | db : DB', input : nilTermList,
          output : eMetaPrettyPrint(getFlatModule(ME', DB'), getOps(getFlatModule(ME', DB'))),
          default : ME, Atts >
    if ME'' := parseModExp(T)
       /\ DB' := database(evalModExp(ME'', DB))
       /\ ME' := modExp(evalModExp(ME'', DB)) .

  crl [show-mbs] :
    < O : X@DatabaseClass | db : DB, input : ('show`mbs`..@Command@), output : nil, default : ME, Atts >
    => < O : X@DatabaseClass | db : DB', input : nilTermList,
          output : eMetaPrettyPrint(getFlatModule(ME', DB'), getMbs(getFlatModule(ME', DB'))),
          default : ME', Atts >
    if DB' := database(evalModExp(ME, DB))
       /\ ME' := modExp(evalModExp(ME, DB)) .
  crl [show-mbs] :
    < O : X@DatabaseClass | db : DB, input : ('show`mbs_.[T]), output : nil, default : ME, Atts >
    => < O : X@DatabaseClass | db : DB', input : nilTermList,
          output : eMetaPrettyPrint(getFlatModule(ME', DB'), getMbs(getFlatModule(ME', DB'))),
          default : ME, Atts >
    if ME := parseModExp(T)
       /\ DB' := database(evalModExp(ME, DB))
       /\ ME' := modExp(evalModExp(ME, DB)) .

  crl [show-eqns] :
    < O : X@DatabaseClass | db : DB, input : ('show`eqs`..@Command@), output : nil, default : ME, Atts >
    => < O : X@DatabaseClass |
          db : DB', input : nilTermList,
          output : eMetaPrettyPrint(getFlatModule(ME', DB'), getEqs(getFlatModule(ME', DB'))),
         default : ME', Atts >
    if DB' := database(evalModExp(ME, DB))
       /\ ME' := modExp(evalModExp(ME, DB)) .
  crl [show-eqns] :
    < O : X@DatabaseClass | db : DB, input : ('show`eqs_.[T]), output : nil, default : ME, Atts >
    => < O : X@DatabaseClass |
          db : DB', input : nilTermList,
          output : eMetaPrettyPrint(getFlatModule(ME', DB'), getEqs(getFlatModule(ME', DB'))),
          default : ME, Atts >
    if ME'' := parseModExp(T)
       /\ DB' := database(evalModExp(ME'', DB))
       /\ ME' := modExp(evalModExp(ME'', DB)) .

  crl [show-rls] :
    < O : X@DatabaseClass | db : DB, input : ('show`rls`..@Command@), output : nil, default : ME, Atts >
    => < O : X@DatabaseClass | db : DB', input : nilTermList,
          output : eMetaPrettyPrint(getFlatModule(ME', DB'), getRls(getFlatModule(ME', DB'))),
          default : ME', Atts >
    if DB' := database(evalModExp(ME, DB))
       /\ ME' := modExp(evalModExp(ME, DB)) .
  crl [show-rls] :
    < O : X@DatabaseClass | db : DB, input : ('show`rls_.[T]), output : nil, default : ME, Atts >
    => < O : X@DatabaseClass | db : DB', input : nilTermList,
          output : eMetaPrettyPrint(getFlatModule(ME', DB'), getRls(getFlatModule(ME', DB'))),
          default : ME, Atts >
    if ME'' := parseModExp(T)
       /\ DB' := database(evalModExp(ME'', DB))
       /\ ME' := modExp(evalModExp(ME'', DB)) .

  crl [show-view] :
     < O : X@DatabaseClass | db : DB, input : ('show`view_.[T]), output : nil, default : ME, Atts >
     => < O : X@DatabaseClass | db : DB', input : nilTermList,
           output : eMetaPrettyPrint(DB', getView(parseViewExpression(T), DB')),
           default : ME, Atts >
     if DB' := evalViewExpression(parseViewExpression(T), nil, DB) .

  crl [set`protect_on] :
     < O : X@DatabaseClass |
           db : DB,
           input : ('set`protect_on`.[T]),
           output : QIL',
           default : ME, Atts >
     => < O : X@DatabaseClass |
           db : db(MIS, MNS, VIS, VES,
                   MNS' ME', MNS'', MNS3, QIL),
           input : nilTermList,
           output : (QIL' 'set 'protect header2QidList(ME') 'on '\n),
           default : ME, Atts >
     if ME' := parseModExp(T)
        /\ unitInDb(ME', DB)
        /\ db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, QIL) := DB .
  crl [set`protect_off] :
     < O : X@DatabaseClass |
           db : db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, QIL),
           input : ('set`protect_off`.[T]),
           output : QIL',
           default : ME, Atts >
     => < O : X@DatabaseClass |
           db : db(MIS, MNS, VIS, VES, remove(MNS', ME'), MNS'', MNS3, QIL),
           input : nilTermList,
           output : (QIL' 'set 'protect header2QidList(ME') 'off '\n),
           default : ME, Atts >
     if ME' := parseModExp(T) .

  crl [set`extend_on] :
     < O : X@DatabaseClass |
           db : DB,
           input : ('set`extend_on`.[T]),
           output : QIL',
           default : ME, Atts >
     => < O : X@DatabaseClass |
           db : db(MIS, MNS, VIS, VES,
                   MNS', MNS'' ME', MNS3, QIL),
           input : nilTermList,
           output : (QIL' 'set 'extend header2QidList(ME') 'on '\n),
           default : ME, Atts >
     if ME' := parseModExp(T)
        /\ unitInDb(ME', DB)
        /\ db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, QIL) := DB .
  crl [set`extend_off] :
     < O : X@DatabaseClass |
           db : db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, QIL),
           input : ('set`extend_off`.[T]),
           output : QIL',
           default : ME, Atts >
     => < O : X@DatabaseClass |
           db : db(MIS, MNS, VIS, VES, MNS', remove(MNS'', ME'), MNS3, QIL),
           input : nilTermList,
           output : (QIL' 'set 'extend header2QidList(ME') 'off '\n),
           default : ME, Atts >
     if ME' := parseModExp(T) .

  crl [set`include_on] :
     < O : X@DatabaseClass |
           db : DB,
           input : ('set`include_on`.[T]),
           output : QIL',
           default : ME, Atts >
     => < O : X@DatabaseClass |
           db : db(MIS, MNS, VIS, VES,
                   MNS', MNS'', MNS3 . ME', QIL),
           input : nilTermList,
           output : (QIL' 'set 'include header2QidList(ME') 'on '\n),
           default : ME, Atts >
     if ME' := parseModExp(T)
        ----/\ unitInDb(ME', DB)
        /\ db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, QIL) := DB .
  crl [set`include_off] :
     < O : X@DatabaseClass |
           db : db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, QIL),
           input : ('set`include_off`.[T]),
           output : QIL',
           default : ME, Atts >
     => < O : X@DatabaseClass |
           db : db(MIS, MNS, VIS, VES, MNS', MNS'', remove(MNS3, ME'), QIL),
           input : nilTermList,
           output : (QIL' 'set 'include header2QidList(ME') 'off '\n),
           default : ME, Atts >
     if ME' := parseModExp(T) .

  crl [load] :
     < O : X@DatabaseClass |
           db : DB,
           input : ('load_.[T]),
           output : QIL',
           default : ME, Atts >
     => < O : X@DatabaseClass |
           db : getDatabase(procLoad(T, ME, DB)),
           input : nilTermList,
           output : getQidList(procLoad(T, ME, DB)),
           default : ME, Atts >
     if ME' := parseModExp(T) .

  eq 'rm`ids`..@Command@ = 'remove`identity`attributes`..@Command@ .
  eq 'rm`ids_.[T] = 'remove`identity`attributes_.[T] .

  crl [remove-id-attributes] :
    < O : X@DatabaseClass | db : DB,
       input : ('remove`identity`attributes`..@Command@),
       output : nil, default : ME, Atts >
    => < O : X@DatabaseClass | db : DB', input : nilTermList,
          output : (eMetaPrettyPrint(getFlatModule(ME', DB'), removeIds(getFlatModule(ME', DB'), all))),
          default : ME', Atts >
    if < DB' ; ME' > := evalModExp(ME, DB) .
  crl [remove-id-attributes] :
    < O : X@DatabaseClass | db : DB, input : ('remove`identity`attributes_.[T]), output : nil, default : ME,   Atts >
    => < O : X@DatabaseClass |
          db : DB', input : nilTermList,
          output : (eMetaPrettyPrint(getFlatModule(ME'', DB'), removeIds(axCohComplete(getFlatModule(ME'', DB')), all))),
          default : ME, Atts >
    if < DB' ; ME'' > := evalModExp(parseModExp(T), DB) .

  eq 'rm`nh`ids`..@Command@ = 'remove`non-handled`identity`attributes`..@Command@ .
  eq 'rm`nh`ids_.[T] = 'remove`non-handled`identity`attributes_.[T] .

  crl [remove-id-attributes] :
    < O : X@DatabaseClass | db : DB,
       input : ('remove`non-handled`identity`attributes`..@Command@),
       output : nil, default : ME, Atts >
    => < O : X@DatabaseClass | db : DB', input : nilTermList,
          output : (eMetaPrettyPrint(getFlatModule(ME', DB'), removeIds(getFlatModule(ME', DB'), non-handled))),
          default : ME', Atts >
    if < DB' ; ME' > := evalModExp(ME, DB) .
  crl [remove-id-attributes] :
    < O : X@DatabaseClass | db : DB, input : ('remove`non-handled`identity`attributes_.[T]), output : nil, default : ME,   Atts >
    => < O : X@DatabaseClass |
          db : DB', input : nilTermList,
          output : (eMetaPrettyPrint(getFlatModule(ME'', DB'), removeIds(getFlatModule(ME'', DB'), non-handled))),
          default : ME, Atts >
    if < DB' ; ME'' > := evalModExp(parseModExp(T), DB) .

  crl [remove-assoc-attributes] :
    < O : X@DatabaseClass | db : DB,
       input : ('remove`assoc`attributes`..@Command@),
       output : nil, default : ME, Atts >
    => < O : X@DatabaseClass | db : DB', input : nilTermList,
          output : (eMetaPrettyPrint(getFlatModule(ME', DB'), removeLonelyAssocs(getFlatModule(ME', DB')))),
          default : ME', Atts >
    if < DB' ; ME' > := evalModExp(ME, DB) .
  crl [remove-assoc-attributes] :
    < O : X@DatabaseClass | db : DB, input : ('remove`assoc`attributes_.[T]), output : nil, default : ME,   Atts >
    => < O : X@DatabaseClass |
          db : DB', input : nilTermList,
          output : (eMetaPrettyPrint(getFlatModule(ME'', DB'), removeLonelyAssocs(getFlatModule(ME'', DB')))),
          default : ME, Atts >
    if < DB' ; ME'' > := evalModExp(parseModExp(T), DB) .

  crl [acu-coherence-completion] :
    < O : X@DatabaseClass | db : DB,
       input : ('ax`coherence`completion`..@Command@),
       output : nil, default : ME, Atts >
    => < O : X@DatabaseClass | db : DB', input : nilTermList,
          output : (eMetaPrettyPrint(getFlatModule(ME', DB'), axCohComplete(getFlatModule(ME', DB')))),
          default : ME', Atts >
    if < DB' ; ME' > := evalModExp(ME, DB) .
  crl [acu-coherence-completion] :
    < O : X@DatabaseClass | db : DB, input : ('ax`coherence`completion_.[T]), output : nil, default : ME,   Atts >
    => < O : X@DatabaseClass |
          db : DB', input : nilTermList,
          output : (eMetaPrettyPrint(getFlatModule(ME'', DB'), axCohComplete(getFlatModule(ME'', DB')))),
          default : ME, Atts >
    if < DB' ; ME'' > := evalModExp(parseModExp(T), DB) .

  rl [error] :
     < O : X@DatabaseClass |
        db : db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, NQIL),
        input : TL, output : nil, default : ME, Atts >
     => < O : X@DatabaseClass |
           db : db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, nil),
           input : TL, output : NQIL, default : ME, Atts > .

  *** Auxiliary Functions

  op showViews : Database -> QidList .
  op showModules : Database -> QidList .

  eq showViews(db(MIS, MNS, VIS, (VE # VES), MNS', MNS'', MNS3, QIL))
    = (eMetaPrettyPrint(VE) '\n
       showViews(db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, QIL))) .
  eq showViews(
       db(MIS, MNS, VIS, emptyViewExpressionSet, MNS', MNS'', MNS3, QIL))
    = nil .

  eq showModules(
       db(MIS, (MN . MNS), VIS, VES, MNS', MNS'', MNS3, QIL))
    = (eMetaPrettyPrint(MN) '\n
       showModules(db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, QIL))) .
  eq showModules(
    db(MIS, emptyModuleNameSet, VIS, VES, MNS', MNS'', MNS3, QIL))
    = nil .

  rl [help] :
     < O : X@DatabaseClass | input : ('help`..@Command@), output : QIL, Atts >
     => < O : X@DatabaseClass | input : nilTermList, output : fm-help, Atts > .
endm

*******************************************************************************
fmod TEXT-STYLE is
--- pr META-LEVEL + PRE-VARIANT .
 pr META-LEVEL .

 var QL : QidList .

 op green : QidList -> QidList .
 eq green(QL) = '\g QL '\o .

 op yellow : QidList -> QidList .
 eq yellow(QL) = '\y QL '\o .

 op red : QidList -> QidList .
 eq red(QL) = '\r QL '\o .

 op bold : QidList -> QidList .
 eq bold(QL) = '\! QL '\o .
endfm

*******************************************************************************

***
*** The Full Maude Module
***

*** We now give the rules to initialize the loop, and to specify the
*** communication between the loop---the input/output of the system---and the
*** database.  Depending on the kind of input that the database receives, its
*** state will be changed, or some output will be generated.

mod FULL-MAUDE is
  pr META-FULL-MAUDE-SIGN .
  pr FM-DATABASE-HANDLING .
  inc LOOP-MODE .
  pr FM-BANNER .

*** The state of the persistent system, which is supported by the built-in
*** module \texttt{LOOP-MODE}, described in Section~\ref{loop}, is represented
*** as a single object.

  subsort Object < State .

  op o : -> Oid .
  op init : -> System .

  var  Atts : AttributeSet .
  var  X@DatabaseClass : DatabaseClass .
  var  O : Oid .
  var  DB : Database .
  var  ME : Header .
  var  QI : Qid .
  vars QIL QIL' QIL'' : QidList .
  var  TL : TermList .
  var  N : Nat .
  vars RP RP' : ResultPair .

  rl [init] :
     init
     => [nil,
         < o : Database |
            db : initialDatabase,
            input : nilTermList, output : nil,
            default : 'CONVERSION >,
         ('\n '\t '\s '\s '\s '\s '\s '\s '\s '\s '\s '\s string2qidList(banner) '\n)] .

*** When some text has been introduced in the loop, the first argument of the
*** operator \verb~[_,_,_,]~ is different from \texttt{nil}, and we can use
*** this fact to activate the following rule, that enters an input such as a
*** module or a command from the user into the database.  The constant
*** \texttt{GRAMMAR} names the module containing the signature defining the
*** top level syntax of Full Maude (see Section~\ref{sec:signature} and
*** Appendix~\ref{signature-full-maude}). This signature is used by the
*** \texttt{metaParse} function to parse the input. PD the input is
*** syntactically valid\footnote{Of course, the input may be syntactically
*** valid, but not semantically valid, since further processing---for example,
*** of bubbles---may reveal a semantic inconsistency.}, the parsed input is
*** placed in the \texttt{input} attribute of the database object; otherwise,
*** an error message is placed in the output channel of the loop.

  rl [in] :
    [QI QIL,
     < O : X@DatabaseClass |
         db : DB, input : nilTermList, output : nil, default : ME, Atts >,
     QIL']
    => if metaParse(GRAMMAR, QI QIL, '@Input@) :: ResultPair
       then [nil,
             < O : X@DatabaseClass | db : DB,
                 input : getTerm(metaParse(GRAMMAR, QI QIL, '@Input@)),
                 output : nil, default : ME, Atts >,
              QIL']
       else [nil,
             < O : X@DatabaseClass | db : DB, input : nilTermList,
                 output : ('\r 'Warning:
                           printSyntaxError(metaParse(GRAMMAR, QI QIL, '@Input@),
                             QI QIL)
                           '\n
                           '\r 'Error: '\o 'No 'parse 'for 'input. '\n),
                 default : ME, Atts >,
             QIL']
       fi .

*** When the \texttt{output} attribute of the persistent object contains a
*** nonempty list of quoted identifiers, the \texttt{out} rule moves it to the
*** third argument of the loop. Then the Core Maude system displays it in the
*** terminal.

  rl [out] :
    [QIL,
     < O : X@DatabaseClass |
         db : DB, input : TL, output : (QI QIL'), default : ME, Atts >,
     QIL'']
    => [QIL,
        < O : X@DatabaseClass |
            db : DB, input : TL, output : nil, default : ME, Atts >,
        (QI QIL' QIL'')] .
endm

*******************************************************************************

loop init .

eof
--- trace exclude FULL-MAUDE .

---- set show loop stats on .
---- set show loop timing on .
set show advisories on .

set trace off .
set trace select on .
trace select procModule4 .
set print conceal on .
print conceal fmod_is_sorts_.____endfm
              mod_is_sorts_._____endm
              db
              procDecl
              .
